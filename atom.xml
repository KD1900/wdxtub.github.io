<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-09-05T16:15:17.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[汇报后的小思考 - 博弈]]></title>
    <link href="http://wdxtub.com/2016/09/05/report-little-thought-2/"/>
    <id>http://wdxtub.com/2016/09/05/report-little-thought-2/</id>
    <published>2016-09-05T14:27:13.000Z</published>
    <updated>2016-09-05T16:15:17.000Z</updated>
    <content type="html"><![CDATA[<p>以前觉得『横看成岭侧成峰』，看到不同的东西，不过是因为角度不同罢了。今天才意识到，想要『一览众山小』，非『凌绝顶』不可。所谓大局观，是掌握更多信息，从更高的层次观察和思考问题。</p>
<a id="more"></a>
<hr>
<p>今天参加了两场『不太一样』的会议，一是跟市场部讨论商业智能相关的数据需求，二是和知识产权部一起向公关的老大汇报。</p>
<p>作为数据平台唯二的开发，面对市场部的各类需求，我的内心一方面是拒绝的，另一方面也深知个中的重要性。技术其实和猫一样，无论黑猫白猫，能抓到老鼠就是好猫。现阶段，我们更需要能创造出价值的技术，而不是摆在博物馆悉心呵护的技术。即使如此，问题依然也很多，比方说时间和人力都远远不够，我和另一个开发人员身上各自背着几个不同项目的设计/开发/维护任务，人力几乎是零冗余的。但是这些其实都不是理由，如果天时地利人和都准备有了，还怎么体现我们的价值呢？</p>
<p>在各项资源都吃紧的条件下，我们的策略一是和市场部相关同事梳理具体的需求逻辑，力求在现有系统的基础上做简单调整即可满足需求，同时也给出临时的权宜之计用作过渡；二是结合数据使用者的相关习惯有针对进行较通用的开发，业务的归业务，架构的归架构。</p>
<p>不可忽视的是不同背景不同专业不同角色思考问题角度的不同，开发人员一定要尽可能设身处地去为用户思考，而不是去过度追求设计及实现的优美，当然这并不意味着可以瞎写代码，而是根据实际需要而不是假想的需求来进行开发。</p>
<p>因为数据平台涉及公司各个业务线，需要对接的系统和数据源非常多，如何能够高效进行沟通协调，如何保证讨论时大家的理念概念模型一致，都是值得探索和研究的问题。我现在的策略很简单，就是以『新参者』的姿态，尽可能快得去学习如何把事情做好。</p>
<p>真正看到用户是如何使用自己做的系统的时候，才更能意识到哪里做好了，哪里没做好。但是这之中出现 bug 确实非常尴尬，虽然是因为经验不足了解不深所犯的错，不过错误的数据会导致错误的判断，我的内心是不安的。这次的尴尬经历也更让我意识到把工作做完和把工作做好之间的巨大差距，还是要以更高的标准来要求自己。</p>
<p>中午睡觉起来没多久就接到电话，五点要开会，会上跟公关老大汇报，虽然汇报内容我已经熟稔于心，但还是花了一个多小时重新准备了一次。和考试前复习的大多不会考一样，准备的内容大概只有百分之十有用，剩下的讨论都在我从来没有想过的层次上进行，有点方，但是也很高兴，因为看到自己的差距就有了目标，有了目标，好好努力就是了。</p>
<p>第一次和知识产权部门与公关部门打交道，让我意识到开发只是做好事情的一环，甚至是最基础的一环，眼界放开，每一环都很重要。在诸如占坑定标准的事儿上，技术能力不是最重要的，敏锐的嗅觉和超前的筹划才是。</p>
<p>班门弄斧不是我的爱好，汇报完我了解的内容，基本就在努力观察和学习前辈们思考和表达的方法，也算有幸一撇更高层次的博弈到底是怎么回事儿。程序员间的博弈其实蛮简单，无非是接口如何设计、工作如何划分、脏活累活哪个团队来接。但是到商业博弈的范畴，那可是真刀真枪，招式不多，但是每一次出击都得切入要害，看似风平浪静其实暗涌澎湃。</p>
<p>从老大的字里行间，能够感受到他对信息广度及获取渠道的在意，只有掌握各方的动向，知己知彼，才能结合不同地区社会运转的规律和组织架构的要点，从更高的层级来判断一件事情的价值。另一个很重要的判断依据，则是历史，前事不忘后事之师绝不只是要吸取教训这么简单，而是努力去利用各方面的经验。这么说来，还真应该再去好好看看历史和兵法，都是财富。</p>
<p>『上将伐谋，其次伐交，再次伐兵，其下攻城』，真正参与到项目中来，才意识到各种公司和组织在标准制定这件事情上的白热化竞争。这之中知识产权相关的工作，就是保护自己的壁垒，没有稳固的根基，哪能广积粮缓称王闷声发大财呢？</p>
<p>有的时候出了事故才是真正体现系统价值的时候，在没有出错的时候，总是会有人不相信到底能多错，不相信系统的能力。所以还是应了那句老话，塞翁失马焉知非福。</p>
<p>至于我为什么参与到这件事儿里来了，其实起因也非常简单，说白了就是一封邮件。可能因为一直以来的写作习惯，会注意上下文的逻辑及读者的感受。因此知识产权部门的同事对我的印象还蛮好的，事情才以我完全没有想到的方式在发展着。回过头来想想，即使我当时知道会因此参与到这个项目中来，能做到的程度也就和当初没啥差别。我不是为了别的什么，只是想把事情做好，只是想让大家知道，从我手中交出去的东西，是靠谱的。</p>
<p>大家身上都有很多值得我学习的地方，以后更要踏踏实实以『新参者』的心态向各行各业的老司机学习，再努力争取机会去实践。</p>
<p>最初了解『新参者』这个词，是在东野圭吾的侦探小说中，新参者就是『新来的人』的意思，主角名叫加贺，他的一句话让我印象特别深刻：</p>
<blockquote>
<p>我工作时经常想，残忍的凶杀案发生后，我们不仅要将凶手抓获，还有必要彻查案件发生的原因，否则同样的事情可能还会发生。真相中有很多值得我们学习的东西。</p>
</blockquote>
<p>为了写博客又晚睡了，但是用双手辅助完成整个思考的过程，才是一天最佳的结束方式吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以前觉得『横看成岭侧成峰』，看到不同的东西，不过是因为角度不同罢了。今天才意识到，想要『一览众山小』，非『凌绝顶』不可。所谓大局观，是掌握更多信息，从更高的层次观察和思考问题。</p>]]>
    
    </summary>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="汇报" scheme="http://wdxtub.com/tags/%E6%B1%87%E6%8A%A5/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【聊聊无人机】柒 碰撞规避]]></title>
    <link href="http://wdxtub.com/2016/09/03/drone-thought-collision-avoidance/"/>
    <id>http://wdxtub.com/2016/09/03/drone-thought-collision-avoidance/</id>
    <published>2016-09-02T23:29:07.000Z</published>
    <updated>2016-09-03T03:51:18.000Z</updated>
    <content type="html"><![CDATA[<p>对于消费级无人机来说，安全比性能更重要。撞机是小事，砸伤划伤人可就是大事了。本文就来说说，无人机规避碰撞的一些研究思路，以及个人的一个超有诚意的小想法。</p>
<a id="more"></a>
<hr>
<p>前面的系列文章主要介绍了美国对于无人机及其空域的划分及管控。因为各方面原因，没有办法在博客中介绍中国的管理思路（感兴趣可以自行搜索已公开的资料），不过可以提一下的是，欧洲的思路和中国的比较类似，与美国的方法有比较大的不同。不过这并不是本文的重点，今天还是来聊聊无人机规避碰撞的问题。</p>
<h2 id="u80CC_u666F_u4ECB_u7ECD"><a href="#u80CC_u666F_u4ECB_u7ECD" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>为了保证无人机的安全，各大厂商可谓是煞费苦心，从地理围栏、主动避障到各种自动化操作，层出不穷的各种方法主要是通过限制、辅助和自动化来降低无人机发生安全事故的风险。这种风险主要是两方面，一是无人机与物体（飞行器、行人、环境）相撞，二是无人机因为各种复杂状况超出处理能力而导致的坠落。</p>
<p>先说说第二个方面，无人机坠落俗称『炸机』，这里用来代称各种因为无人机硬件条件限制所导致的事故，包括但不限于：</p>
<ul>
<li>飞行中遇到大风失去平衡且在已有的动力条件下无法恢复所导致的坠落</li>
<li>电量不足以返航所以不知道在哪里就掉下来了</li>
<li>突然下雨，电机进水失去动力，于是掉下来</li>
</ul>
<p>为了解决以上这些问题，基本思路就是在飞行控制芯片中集成更加先进的算法，在硬件中塞更多的传感器以增加无人机的环境感知能力。那么问题来了，在电池技术没有什么突破的今天，更强大的算法意味着更多的计算，是要智能还是要续航，这种两难的问题就很尴尬了。</p>
<p>前段时间跟我司相机和飞控部门的同事聊过，因为计算能力限制，很多时候连基本的傅立叶变换都没有办法快速完成，也就意味着市面上大部分高大上的论文是没办法集成到无人机的智能系统中的。</p>
<p>回过头来说第一方面，要避免无人机意外撞机，首先需要解决的是让无人机知道周围有什么东西。不过开始之前，先来参考一下有人驾驶飞机的空中管制系统。从最原始的无线电通信，到之后 ATC（空中交通管制系统）的普及使得各类飞行基本得以『井水不犯河水』，能不能考虑把有人驾驶飞机的这一套用在无人机上呢？</p>
<p>很可惜，答案是否定的。与传统的有人驾驶飞机相比，无人机可以被认为是一个全封闭的自治系统（如果数据链路断了，飞手便无法控制），很难根据不同情况做出合适的反应；另外无人机的飞行路线也比较随意，不像有人驾驶飞机基本按照固定的航线飞行；更重要的，无人机的范围很大，无论是大小还是性能都有巨大差异，很难上一套统一的标准来满足所有类型无人机的需求。</p>
<p>抛开军用和商用无人机不说，民用消费级无人机正处于群雄并起的春秋战国时代，大家都想把自己的技术上升成标准。这个时候首发优势就很重要了，谁能先拿出一整套完整的方案，谁的市场占有率高，大约就可以强势促成标准。</p>
<p>以前我还不明白为什么各行各业都有自己的一套标准，直到自己参与其中才意识到，标准就是规矩，规矩背后就是协商好的『分赃』方法，不仅可以拦住搅局者，还能稳固自己的一亩三分地，这样回过头来看布雷顿森林体系，就觉得『哎呀真特么都是套路』。</p>
<p>好了不扯远了，接下来我们来看看现在比较常用的规避碰撞的技术。</p>
<h2 id="u73B0_u6709_u6280_u672F"><a href="#u73B0_u6709_u6280_u672F" class="headerlink" title="现有技术"></a>现有技术</h2><p>各大厂商的相关研发基本围绕着两个思路以达到『感知与躲避』的目的：</p>
<ol>
<li>依赖于多传感器的环境感知</li>
<li>依赖于智能算法的自主规避机制</li>
</ol>
<p>这里我分别来简单说一下。</p>
<p>依赖传感器的解决方案基本可以被认为是『非合作型』方法，之所以叫『非合作型』，主要是因为整个过程不需要与其他物体进行任何形式的通讯（或者是不具有通讯能力的，比方说鸟类）。基本的方法简单粗暴，五个字就可以概括——『声光电磁气』。从雷达到红外线到摄像头到气压计到指南针，基本可以认为是数字信号处理的过程，虽然可以把大部分计算用硬件实现，不过还是前面的问题，暂且不考虑具体的准确性，电量本身就是跨不过去的门槛。</p>
<p>依赖智能算法的解决方案其实也需要硬件配合，不过更多的是通讯的硬件，比方说 TCAS 和 ADS-B。有通讯基本意味着是『合作型』，通过数据链路共享信息，以达到智能规避碰撞的目的。</p>
<p>TCAS 的介绍可以参考下面摘录自《世界民航杂志120期》的内容：</p>
<blockquote>
<p>TCAS 全称是 Traffic Collision Avoidance System，主要由询问器、应答机、收发机和计算机组成。监视范围一般为前方30海里，上、下方为3000米，在侧面和后方的监视距离较小。（为了减少无线电干扰，管理条例对TCAS的功率有所限制。它把TCAS的前向作用距离限定在45英里左右，侧向和后向作用距离则更小。）</p>
<p>TCAS 的询问器发出脉冲信号，这种无线电信号称为询问信号，与地面发射的空中雷达交通管制信号类似。当其他飞机的应答器接收到询问信号时，会发射应答信号。TCAS 的计算机根据发射信号和应答信号间的时间间隔来计算距离。同时根据方向天线确定方位，为驾驶员提供信息和警告，这些信息显示在驾驶员的导航信息显示器上。</p>
<p>TCAS 可以提供语言建议警告，计算机可以计算出监视区内30架以内飞机的动向和可能的危险接近，使驾驶员有25－40秒的时间采取措施。（TCAS 可跟踪45架飞机，根据选定目标的优先级，最多显示30架飞机。）</p>
</blockquote>
<p>看起来很符合要求嘛！不过这样一套系统要 20 万人民币以上，估计短时间内很难降价到能够装载到民用消费级无人机身上。但是 TCAS 的整体思路是值得借鉴的，在下一节会详细介绍。</p>
<p>另一个比较新但是比较有潜力的技术是 ADS-B，全称是 Automatic Dependent Surveillance - Broadcast，会自动从相关机载设备获取参数向其他飞机或地面站广播飞机的位置、高度、速度、航向、识别号等信息。用百科中的一段原理介绍：</p>
<blockquote>
<p>ADS-B 系统是一个集通信与监视于一体的信息系统，由信息源、信息传输通道和信息处理与显示三部分组成。ADS-B的主要信息是飞机的 4 维位置信息(经度、纬度、高度和时间)和其它可能附加信息(冲突告警信息，飞行员输入信息，航迹角，航线拐点等信息)以及飞机的识别信息和类别信息。此外，还可能包括一些别的附加信息，如航向、空速、风速、风向和飞机外界温度等。这些信息可以由以下航空电子设备得到：1)全球卫星导航系统(GNSS);2)惯性导航系统(INS);3)惯性参考系统(IRS);4)飞行管理器；5)其它机载传感器。ADS-B 的信息传输通道以 ADS-B 报文形式，通过空-空、空-地数据链广播式传播。ADS-B 的信息处理与显示主要包括位置信息和其它附加信息的提取、处理及有效算法，并且形成清晰、直观的背景地图和航迹、交通态势分布、参数窗口以及报文窗口等，最后以伪雷达画面实时地提供给用户。</p>
</blockquote>
<p>ADS-B 其实早在十年前就开始了相关的研究和测试，不过目前还没有搭载 ADS-B 的民用消费级无人机（虽然比 TCAS 便宜，但是也要 1 万人民币以上），这种涉及行业和政府之间的沟通协调，往往需要比较长的时间。另外 NASA/Google/Amazon 也都在开发类似的自动化系统，一个技术最终是否能够落地，就要看哪家拿出来的方案更加靠谱了。不过我个人的观察是，因为空中环境的复杂性，可能会基于不同场景使用不同的方案，具体还需要大量的实地测试。</p>
<p>简单总结一下，目前无人机在安全性相关技术的探索，面临着以下问题</p>
<ul>
<li>计算量：硬件条件不允许高负荷计算</li>
<li>传感器：目前还没有集成多种感知能力且足够便宜的传感器能满足设计和冗余的需求</li>
<li>信息源：不同厂商目前并没有信息共享</li>
<li>政策标准：需要较长时间才能达成标准和政策</li>
<li>成本：基于硬件的解决方案在成本上比较有压力</li>
</ul>
<p>实话说，即使是特别昂贵的 TCAS，其实在设计上也有许多妥协，也因此有很多限制条件。目前不存在一种技术，能够一劳永逸解决无人机的安全性问题，如果有，恐怕就是『不起飞』。</p>
<p>之所以这么说，是因为接下来我的想法仅仅在一定条件下适用，而且基于软件的解决方案在现实的移动设备上稳定性存疑，可以作为某种意义上『感知与躲避』功能的补充和辅助，并不能取代硬件解决方案（虽然这部分我是无能为力的）。</p>
<h2 id="u6211_u7684_u60F3_u6CD5"><a href="#u6211_u7684_u60F3_u6CD5" class="headerlink" title="我的想法"></a>我的想法</h2><p>再强调一次，接下来的想法只针对特定的条件和场景，是『感知与躲避』功能的补充和辅助。目前能在我司的支持下做相关的研究探索我很开心，希望这个项目不要因为各种各样奇怪原因被迫中止/终止。如果不幸发生了最坏的情况，虽然目前的研究成果没办法带走（毕竟属于公司），如果有相关公司愿意支持这个项目，我还是很愿意从头再设计开发一次的，因为这对于无人机安全性提高还是有一定帮助的。</p>
<p>这里不会说得特别详细（不然就太没有职业道德了），主要说说思路。</p>
<h3 id="u603B_u4F53_u601D_u8DEF"><a href="#u603B_u4F53_u601D_u8DEF" class="headerlink" title="总体思路"></a>总体思路</h3><p>针对前面说的『计算量/传感器/信息源/政策标准/成本』几大问题，以 Cortana/Siri 的方式，通过数据连接转移复杂的计算，利用云的力量为无人机提供计算能力和智能调度能力的支持。</p>
<p>回想一下用 Siri 的方式，我们唯一需要做的就是用正常方式说话，然后通过网络传送到服务器，服务器进行处理之后再把结果返回给我们。这样一来，计算量/信息源/成本 这三个问题在用比较好网络连接的条件下就能够一定程度解决。</p>
<p>举个实际的例子：我在飞一台没有搭在 ADS-B 的无人机，但是无人机会把飞行信息发送到手机，手机会把这些信息上传到服务器上，服务器会据此计算/获取：</p>
<ul>
<li>无人机附近的天气状况（大风、降雨等恶劣天气的概率）</li>
<li>无人机附近的其他飞行器的飞行状况，并根据具体特征进行碰撞预警（比方说有另一架无人机在 200 米外，且相向飞行，那么双方都会在手机上接收到碰撞语境提示）</li>
<li>无人机附近的航线及其他计划飞行信息</li>
</ul>
<p>这样用户就可以在手机上获知周围的环境状况，并据此手动/自动进行对应操作。</p>
<h3 id="u9002_u7528_u6761_u4EF6"><a href="#u9002_u7528_u6761_u4EF6" class="headerlink" title="适用条件"></a>适用条件</h3><p>从前面的描述中，我们可以知道网络是这个系统中非常重要的一环，于是，适用条件/主要服务的飞行器是：</p>
<ul>
<li>没有搭载诸如 ADS-B 或 TCAS 雷达的飞行设备</li>
<li>较好的网络连接条件</li>
<li>遥控器与飞行器间能够维持比较稳定的通信链路</li>
</ul>
<p>实话说，都满足并不简单。尤其是后两个依赖通信的条件，需要找机会实地测试才能给出比较科学的结论。</p>
<h3 id="u6280_u672F_u6807_u51C6"><a href="#u6280_u672F_u6807_u51C6" class="headerlink" title="技术标准"></a>技术标准</h3><p>这部分涉及的问题很多，最近读了一些航空方面的综述，总结下来，需要回答的问题是：</p>
<ul>
<li>怎么样的空域条件可以认为是安全的</li>
<li>每台无人机所需要的安全空域的范围有多大</li>
<li>预警的级别及条件</li>
<li>数据传输的格式及安全性</li>
<li>针对不同性能和类型的飞行器的最低标准</li>
<li>紧急情况的预警机制</li>
</ul>
<p>这部分其实用现有的技术基本可以实现，就是具体的标准需要大量测试。</p>
<h3 id="u7B97_u6CD5_u63A2_u7D22"><a href="#u7B97_u6CD5_u63A2_u7D22" class="headerlink" title="算法探索"></a>算法探索</h3><p>目前我正在开发的是一套飞行器模拟器，能够模拟无人机的飞行及相关数据上报，这样在测试各类算法的时候能够有更多的数据依据（真实源数据由公司提供）。模拟器的思路很简单，就是基于用户的真实飞行数据进行仿真数据的生成，然后作为算法的输入，来测试算法的表现。</p>
<p>具体的测试标准也需要进行量化，不然就无从评估不同算法的有效程度。这部分需要更多和美国同事沟通，以及多多了解相关的研究（如果有认识的人在做这个请向我引荐一下谢谢！）</p>
<p>目前我的思路大约是机器学习 + 随机过程优化。这部分可以做得简单粗暴，不过要想更加智能，就得多花点时间研究了。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了一下碰撞规避的相关技术，并结合自己的工作提出了一点微小的设想，欢迎对无人机飞行感兴趣的同学来交流探讨，争取在 NASA/Google/Amazon 之前撸出一套靠谱可用的系统。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于消费级无人机来说，安全比性能更重要。撞机是小事，砸伤划伤人可就是大事了。本文就来说说，无人机规避碰撞的一些研究思路，以及个人的一个超有诚意的小想法。</p>]]>
    
    </summary>
    
      <category term="感知" scheme="http://wdxtub.com/tags/%E6%84%9F%E7%9F%A5/"/>
    
      <category term="无人机" scheme="http://wdxtub.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="碰撞" scheme="http://wdxtub.com/tags/%E7%A2%B0%E6%92%9E/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十二周 - 湫兮如风]]></title>
    <link href="http://wdxtub.com/2016/09/02/qiu-xi-ru-feng/"/>
    <id>http://wdxtub.com/2016/09/02/qiu-xi-ru-feng/</id>
    <published>2016-09-02T14:48:23.000Z</published>
    <updated>2016-09-02T16:28:46.000Z</updated>
    <content type="html"><![CDATA[<p>日月星辰悄悄，升了又落，我却不知白天黑夜的存在。</p>
<a id="more"></a>
<hr>
<p>白驹过隙，转瞬间，工作就满三个月了。有时候，觉得自己变了，变得现实，学着妥协，试着在各种压力中找到平衡；有时候，又觉得自己没变，一如既往地举着理想主义的旗帜，虽然做了最坏的打算，但还是用最积极的方式在做事。</p>
<p>在父母眼中我永远是长不大的孩子，不说千里，儿行百里母担忧。在发小眼中我永远是那个能吃的小胖墩，打打闹闹没个正形。长大一些，在同学眼中，可能是考试最稳定又最不稳定的，趁着早读吃早餐踩着铃声上课的『捣蛋』分子。工作之后，在同事眼中我又是怎么样呢？</p>
<p>管它是啥，自己开心最重要。</p>
<p>周末一直在聚会，周五晚上凑齐了四个『小学生』，虽然喝得走路歪歪扭扭，心里却感动得稀里哗啦，二十年的羁绊，真的已经比亲兄弟还要亲了。周六带着几个要好的同事在广州溜了一大圈，疯疯癫癫在优衣库试衣间拍奇葩照片，钻到小巷子里只为癞蛤蟆和天鹅肉。周日和高中同学聚了聚，在大洋彼岸漂泊，难免有各种酸甜苦辣，不过难过的时候想着有这么一帮好朋友，或多或少是些慰藉。</p>
<p>周六路过沙面的时候，不由得想起当年和老爸一起沿着江边一路从猎德骑到沙面白天鹅的日子。真的特别庆幸拥有这么多单车上的回忆，我和老爸大约骑遍了广州的东南西北，路过各种各样的风景，但最美的风景其实就在身边。现在想想，哪怕是骑着车去买馒头和烤鸭，都是特别美好的记忆。等工作稍微稳定一些，一定要再去创造些回忆。</p>
<p>周一五点多起床赶着首班动车回深圳上班。周中买了个折叠床和智能手环，解决了『睡』和『跑』的难题。工作中涉及的四五个项目我需要扮演不同的角色，如何合理安排时间平衡沟通和设计，开发和测试就成了一大难题，尤其是产品经理和开发这两个角色，很容易顾此失彼，具体的方法还在慢慢摸索中，反正之前看的书并没有能够解决我的疑惑。</p>
<p>忙忙碌碌之中，还是灵机一动找到了一个突破点，既有学术价值，也有应用价值，我很感兴趣，也非常值得研究。简单来说是智能防撞系统，详细的会在『聊聊无人机』系列中更新。人的自信就是靠把一件一件事情做好建立起来的，能够在刚工作的时候就独立扛起一个项目，开发一个完整的系统，并且在这个过程中学着跟各个部门打交道，我觉得是特别幸运的事情（其实也正是我选择回国的原因），虽然压力不小，不过我就是要 no zuo no die try one try。</p>
<p>这周新日志没写，而是结合工作的内容把之前的坑给补上了，通过一个假想的项目，把设计上的思考和具体实践中需要注意的地方写下来，是一个很好的学习和积累。不过第一次尝试，还是有些准备不足，以后要继续改进。另外因为字体源访问速度较慢的缘故，有两天博客的访问体验非常糟糕，没办法，折腾到一两点，死扣一点点的优化，用耐心去面对网络的复杂。</p>
<p>当然也有好消息！博客的访问量超过十万了！要不要搞个小活动感谢一下大家的支持呢？写书这周因为事务繁杂进展不多，不过最艰难的部分整理基本完成，之后可以按部就班一点点优化了。</p>
<p>有了主攻方向，感觉整个人都斗志昂扬了起来，是时候多快好省搞一波大新闻了！</p>
<p>每次日落日升，今夕何夕，请跟我乘风而去。有一天，想成为，你们的骄傲。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>日月星辰悄悄，升了又落，我却不知白天黑夜的存在。</p>]]>
    
    </summary>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="里程碑" scheme="http://wdxtub.com/tags/%E9%87%8C%E7%A8%8B%E7%A2%91/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十一周 - 大鱼]]></title>
    <link href="http://wdxtub.com/2016/08/26/big-fish/"/>
    <id>http://wdxtub.com/2016/08/26/big-fish/</id>
    <published>2016-08-26T10:46:17.000Z</published>
    <updated>2016-08-26T11:46:32.000Z</updated>
    <content type="html"><![CDATA[<p>海浪无声将夜幕深深淹没，漫过填空尽头的角落。看海天一色，听风起风落；大鱼的翅膀，已经太辽阔。</p>
<a id="more"></a>
<hr>
<p>伴随着稀里哗啦的大雨，我在从深圳平移到广州的路上写下了这篇周记。不过这周却是晴朗的，之前担心的事情一一顺遂。我不禁好奇，为什么我每周都有走上正轨的感觉，是轨道变太快还是我之前走太歪？</p>
<p>姑且叫做『与时俱进』好了。</p>
<p>上周日一个人在房间里看女排哭成一股泥石流，从决赛看到半决赛再到四分之一决赛，倒着看就能明显感觉到姑娘们的心劲儿上来了，尤其是郎平定海神针般杵在场边，颇有千军万马过，我自巍然不动的感觉。而世界级主攻朱婷就更是没话说了，每次她跳起来我就感觉稳了。最后一局 22 比 22 的那次『爆头』式大力杀球，让我甚至有点心疼对手了。这个故事告诉我们，老大当如郎平，上将当如朱婷（押韵的）。</p>
<p>虽然奥运会已经闭幕，但是奥运精神估计还有几个月的半衰期，经过两周比较系统的俯卧撑及跑步练习，上下肢力量，尤其是稳定性有了极大的提高，具体表现出来就是耐力更持久投篮更准确。这个故事告诉我们，要想把事情做好，不能三天打鱼两天晒网，系统训练虽然枯燥和辛苦，却是提高的唯一途径。</p>
<p>周末终于来了一次团队建设，不过随着开学的临近，不少好朋友要暂时离开了。每次要送别，我都会想到古龙的一句话，大意是走的时候我不送你，但倘若再来，无论大风大雨，我都要去接。我特别记得在北京三元桥地铁站的那次回头，瞬间涌上来的伤感淹没了记忆。好在现在我回来了，距离也不再是问题了。</p>
<p>聊聊工作，当救火队员完成支援工作之后（虽然主要是老司机扛着），我终于能够把大部分精力投入到自己负责的项目中去了。写写客户端写写服务端再当当 PM，日子就在设计接口、对接项目、隔空开会以及看论文写文档中度过了。虽然任务很多，不过这也逼着自己提高效率，也更能学到不同岗位不同角色所需要的能力，最重要的，心劲儿要满，心气儿不能高，这样才能沉下心做事，把方方面面的细节都考虑到。</p>
<p>虽然客户端和服务端都是我来写，不过对于 API 的设计、计算的优化、业务场景的理解以及基于用户体验出发的构思，都需要更多向身边有丰富经验的老司机们求教。从写教材这事儿我学到的一点就是，一旦意识到自己交付的是不太可能改变的东西，就更要仔细，代码和白纸黑字一样，第一次没做好，有弥补的机会是非常幸运的，要抱着一次就做好的心态，做到自己的最好。生活也是这样，每一分每一秒过去之后便无法改变，虽然人人都知道，但并不是每个人都能真正理解个中含义。自己擅长的要做好，自己不擅长的，要么找擅长的人，要么努力让自己成为擅长的人。</p>
<p>和同事一起看了谍影重重5，也买了一张大鱼海棠的原声带，生活与工作的平衡很难找到，但是也要尽力去试试。现在想想大鱼海棠的主题，其实任何选择都无可厚非，无论爱或者是被爱，都可以是幸福的，多一点真诚，少一些套路。和伯恩一样，我们都在不断的冲突和挣扎中拨开迷雾寻找自我，即使真相不一定是自己想要的，但也许真实的残酷要比海市蜃楼的美好要让人踏实。</p>
<p>大鱼在梦境的缝隙里游过，我松开时间的绳索，执子手吹散苍茫茫烟波。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>海浪无声将夜幕深深淹没，漫过填空尽头的角落。看海天一色，听风起风落；大鱼的翅膀，已经太辽阔。</p>]]>
    
    </summary>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="生活" scheme="http://wdxtub.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Go 之旅】V 项目实战：一起看飞机 - 客户端]]></title>
    <link href="http://wdxtub.com/2016/08/25/go-plane-3/"/>
    <id>http://wdxtub.com/2016/08/25/go-plane-3/</id>
    <published>2016-08-25T13:40:20.000Z</published>
    <updated>2016-08-31T14:18:15.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们搭建好了后台（虽然实际开发中我是客户端后台一起写的），这次来看看如何做一个配套的客户端（虽然从各种角度看都非常『简约』），小归小，还是有一点意思的。</p>
<a id="more"></a>
<hr>
<p>还记得系列第一篇中的设计稿吗？我把它捣鼓出来了：</p>
<p><img src="/images/14721336651764.jpg" alt=""><br>（感谢上镜的各位名人名言）</p>
<h2 id="u5177_u4F53_u5B9E_u73B0"><a href="#u5177_u4F53_u5B9E_u73B0" class="headerlink" title="具体实现"></a>具体实现</h2><p>因为早早确定了接口，其实 iOS 部分的实现比后端还要简单粗暴，即使如此，具体开发过程中的坑有很多，比如（大家看一下源代码应该就知道了）</p>
<ul>
<li>时隔太久我忘了 Objective-C 要咋写，花了十分钟才摆脱了 C++ 写法</li>
<li>iOS9 新增的强制 Https 需要改一下描述文件才能走 Http（毕竟只是一个测试）</li>
<li>为了调试方便所有的网络都走的是同步请求（理论上都得用异步来着）</li>
<li>为了测试方便，所有的信息会统一输出到中间的文本框中，我干脆直接叫它 <code>consoleTextView</code></li>
<li>为了测试方便，采用类似终端输出，快速对接接口</li>
<li>为了每次生成不一样的数据，随机生成用户 id，并利用手机本身的定位来获取位置</li>
<li>没有做缓存（服务器端也没有），所以速度还是比较慢。上线不到 1ms，但是涉及数据库操作的『位置』和『附近』功能，基本就需要 200ms 了，这部分还有很大的优化空间</li>
<li>天气部分使用 Yahoo 的 API，弄清楚格式即可</li>
<li>航线部分没找到免费的，暂时先不考虑（也没时间自己写爬虫嘛）</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>本来想着把这个项目撸完整一点的，不过因为工作压力和个人事务缠身，不得不仓促结尾。在可以预见的将来应该也不会继续填坑了，只有开源的代码可能能给大家一点帮助（至少服务端是可以的，客户端用了很多过分省事儿的方法，不太好）。</p>
<p>但是，但是。</p>
<p>这里预告一下，之后会用 Go 把我之前的毕业设计重新开发一次，并以开源服务的形式共享给大家。相信对于喜欢做笔记的同学来说，是一个非常好用的工具。<a href="https://github.com/wdxtub/wkk/wiki" target="_blank" rel="external">这里</a>是项目简介。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/wdxtub/watch-plane-together-ios" target="_blank" rel="external">项目代码</a></li>
<li><a href="https://github.com/wdxtub/wkk/wiki" target="_blank" rel="external">下一个要开发的项目 Wdxtub’s Knowledge Kit</a></li>
<li><a href="http://blog.csdn.net/mylizh/article/details/44838065" target="_blank" rel="external">iOS定位服务系列之一：获取当前位置信息</a></li>
<li><a href="http://www.sollyu.com/objective-c-synchronization-requests-requests-for-asynchronous-requests-get-and-post-requests/" target="_blank" rel="external">Objective-C 之同步请求、异步请求、GET请求、POST请求</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们搭建好了后台（虽然实际开发中我是客户端后台一起写的），这次来看看如何做一个配套的客户端（虽然从各种角度看都非常『简约』），小归小，还是有一点意思的。</p>]]>
    
    </summary>
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="项目" scheme="http://wdxtub.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="飞机" scheme="http://wdxtub.com/tags/%E9%A3%9E%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Go 之旅】IV 项目实战：一起看飞机 - 后台]]></title>
    <link href="http://wdxtub.com/2016/08/24/go-plane-2/"/>
    <id>http://wdxtub.com/2016/08/24/go-plane-2/</id>
    <published>2016-08-24T14:57:38.000Z</published>
    <updated>2016-08-31T14:05:24.000Z</updated>
    <content type="html"><![CDATA[<p>前面已经了解了『一起看飞机』的基本需求，这次我们来搭建一个完整的基于 beego 框架的后台。同时也会涉及调试测试部署等一系列配套工作，我觉得这些反而是工作中很重要的能力，但不知道为啥大部分书都略过了。</p>
<a id="more"></a>
<hr>
<h2 id="u5F00_u59CB_u4E4B_u524D"><a href="#u5F00_u59CB_u4E4B_u524D" class="headerlink" title="开始之前"></a>开始之前</h2><p>按照 <a href="http://beego.me/docs/install" target="_blank" rel="external">beego 的安装</a> 和 <a href="http://beego.me/docs/install/bee.md" target="_blank" rel="external">bee 工具简介</a> 中的介绍把 <code>beego</code> 和 <code>bee</code> 都安装好，然后在 <code>$GOPATH</code> 中我们能看到 <code>bin</code>, <code>pkg</code>, <code>src</code> 三个文件夹，进入 <code>src</code> 文件夹，之后的项目代码都会在这里。接着用以下命令来创建项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dawang @ dawang in ~/Documents/GO/src [16-08-24 14:36:44] C:2</span></span><br><span class="line">$ bee new watch-plane-together</span><br><span class="line">[INFO] Creating application...</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/conf/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/controllers/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/models/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/routers/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/tests/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/static/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/static/js/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/static/css/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/static/img/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/views/</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/conf/app.conf</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/controllers/default.go</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/views/index.tpl</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/routers/router.go</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/tests/default_test.go</span><br><span class="line">/Users/dawang/Documents/GO/src/watch-plane-together/main.go</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">14</span>:<span class="number">36</span>:<span class="number">51</span> [SUCC] New application successfully created!</span><br></pre></td></tr></table></figure>
<p>进入 <code>watch-plane-together</code> 文件夹，然后先跑起来试试看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dawang @ dawang in ~/Documents/GO/src/watch-plane-together on git:master x [16-08-24 15:56:09] C:130</span></span><br><span class="line">$ bee run</span><br><span class="line">bee   :<span class="number">1.4</span>.<span class="number">1</span></span><br><span class="line">beego :<span class="number">1.6</span>.<span class="number">1</span></span><br><span class="line">Go    :go version go1.<span class="number">7</span> darwin/amd64</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">11</span> [INFO] Uses <span class="string">'watch-plane-together'</span> as <span class="string">'appname'</span></span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">11</span> [INFO] Initializing watcher...</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">11</span> [TRAC] Directory(/Users/dawang/Documents/GO/src/watch-plane-together/controllers)</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">11</span> [TRAC] Directory(/Users/dawang/Documents/GO/src/watch-plane-together)</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">11</span> [TRAC] Directory(/Users/dawang/Documents/GO/src/watch-plane-together/routers)</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">11</span> [TRAC] Directory(/Users/dawang/Documents/GO/src/watch-plane-together/tests)</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">11</span> [INFO] Start building...</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">13</span> [SUCC] Build was successful</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">13</span> [INFO] Restarting watch-plane-together ...</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">13</span> [INFO] ./watch-plane-together is running...</span><br><span class="line"><span class="number">2016</span>/<span class="number">08</span>/<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">13</span> [asm_amd64.s:<span class="number">2086</span>][I] http server Running on :<span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>一切正常的话，访问 <code>localhost:8080</code> 就可以见到：</p>
<p><img src="/images/14720513974639.jpg" alt=""></p>
<p>到底发生了什么？结合具体的目录结构，我们来看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dawang @ dawang in ~/Documents/GO/src/watch-plane-together on git:master x [16-08-24 16:02:16]</span></span><br><span class="line">$ tree ./</span><br><span class="line">./</span><br><span class="line">├── README.md</span><br><span class="line">├── conf</span><br><span class="line">│   └── app.conf</span><br><span class="line">├── controllers</span><br><span class="line">│   └── default.go</span><br><span class="line">├── main.go</span><br><span class="line">├── models</span><br><span class="line">├── routers</span><br><span class="line">│   └── router.go</span><br><span class="line">├── static</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── img</span><br><span class="line">│   └── js</span><br><span class="line">├── tests</span><br><span class="line">│   └── default_test.go</span><br><span class="line">├── views</span><br><span class="line">│   └── index.tpl</span><br><span class="line">└── watch-plane-together</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> directories, <span class="number">9</span> files</span><br></pre></td></tr></table></figure>
<p>我们运行 <code>bee run</code> 之后，程序从 <code>main.go</code> 中开始执行，具体做的工作是把 <code>routers</code> 文件夹中的对应路由规则与具体的控制器进行绑定，比方说 <code>routers/router.go</code> 中有一句为 </p>
<p><code>beego.Router(&quot;/&quot;, &amp;controllers.MainController{})</code></p>
<p>然后对应于 <code>controllers/default.go</code> 中的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MainController <span class="keyword">struct</span> &#123;</span><br><span class="line">	beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (c *MainController) Get() &#123;</span><br><span class="line">	c.Data[<span class="string">"Website"</span>] = <span class="string">"wdxtub.com"</span></span><br><span class="line">	c.Data[<span class="string">"Email"</span>] = <span class="string">"dacrocodilee@gmail.com"</span></span><br><span class="line">	c.TplName = <span class="string">"index.tpl"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们给 MainController 添加了 Get() 方法，用于处理基本的 get 请求。而在具体的模板中，使用两个大括号加点号（这里直接输入会导致 hexo 解析异常，所以就用文字描述了）进行引用。</p>
<p>最后，我们可以在 <code>conf/app.conf</code> 中添加一行 <code>EnableAdmin = true</code>，我们就可以在 <code>localhost:8088</code> 中见到一个监控页面，像这样：</p>
<p><img src="/images/14720514130726.jpg" alt=""></p>
<p>基本的套路就是这么简单！然后我们来简单设计下 API，方便之后的开发。</p>
<h2 id="API__u89C4_u5212"><a href="#API__u89C4_u5212" class="headerlink" title="API 规划"></a>API 规划</h2><p>服务 API 的设计其实不算特别难，类似于起函数名。不过随着项目的不断开发，随意的命名会导致项目复杂度指数爆炸。所以我们要采用更为现代化的套路 - RESTful API。</p>
<h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>在我看来 RESTful API 和成语差不多，通过一定的规约和沉淀，把互联网连接的低语境拔高的高语境，所谓高语境的意思是大家已经了解一组通用的条件和原则，在此基础上沟通可以极大降低沟通成本。</p>
<p>先来看几个基本概念：</p>
<ul>
<li>资源(Resources)：我们平常上网访问的一张图片、一个文档、一个视频等。这些资源我们通过URI来定位，也就是一个URI表示一个资源</li>
<li>表现(Representation)：资源是做一个具体的实体信息，他可以有多种的展现方式。而把实体展现出来就是表现层，例如一个 txt 文本信息，他可以输出成 html、json、xml 等格式，一个图片他可以 jpg、png 等方式展现，这个就是表现层的意思。 URI 确定一个资源，而在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述</li>
<li>状态转化(State Transfer)：访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，肯定涉及到数据和状态的变化。而 HTTP 协议是无状态的，那么这些状态肯定保存在服务器端，所以如果客户端想要通知服务器端改变数据和状态的变化，肯定要通过某种方式来通知它。客户端能通知服务器端的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。</li>
</ul>
<p>简单点来说，RESTful 的核心思想类似于面向对象，把原先的过程导向转变为资源导向，然后围绕着资源做文章。</p>
<p>这里需要保证请求是无状态的，有以下几个好处：</p>
<ul>
<li>客户端可以缓存数据来改进性能</li>
<li>在接口层帮助系统分层解耦，限制复杂度，底层可以更加独立</li>
<li>易于扩展，没有机器间关联</li>
</ul>
<p><img src="/images/14720514271343.jpg" alt=""></p>
<h3 id="API__u603B_u89C8"><a href="#API__u603B_u89C8" class="headerlink" title="API 总览"></a>API 总览</h3><p>根据 RESTful 的风格，接口中不应该出现动词，而利用 GET/PUT/POST/DELETE 来进行具体的动作，对应到『一起看飞机』这个项目，API 总览：</p>
<ul>
<li><code>/api/position</code> 客户端每隔一段调用一次该接口<ul>
<li><code>POST</code> 上传当前位置到服务器（状态变为上线）</li>
<li><code>DELETE</code> 结束上传位置（状态变为下线，或通过超时判断）</li>
</ul>
</li>
<li><code>/api/weather</code><ul>
<li><code>GET</code> 获取用户附近的天气状况</li>
</ul>
</li>
<li><code>/api/flight</code><ul>
<li><code>GET</code> 获取用户附近的航班情况</li>
</ul>
</li>
<li><code>/api/near</code><ul>
<li><code>GET</code> 获取用户附近的人</li>
</ul>
</li>
</ul>
<p>调试用接口</p>
<ul>
<li><code>/debug/position</code><ul>
<li><code>POST</code> 获取指定用户的当前位置</li>
</ul>
</li>
<li><code>/debug/weather</code><ul>
<li><code>GET</code> 获取指定位置附近的天气状况</li>
</ul>
</li>
<li><code>/debug/flight</code><ul>
<li><code>GET</code> 获取指定位置附近的航班</li>
</ul>
</li>
<li><code>/debug/near</code><ul>
<li><code>POST</code> 获取用户或指定位置附近的人</li>
</ul>
</li>
<li><code>/debug/upload</code><ul>
<li><code>POST</code> 测试 json 数据上传</li>
</ul>
</li>
</ul>
<p>这里因为时间关系，只用非常简单粗暴的方式实现了 debug 接口。所有的数据处理都在 controller 层完成，并未涉及任何 model（暂时还不需要）</p>
<h3 id="Debug__u63A5_u53E3"><a href="#Debug__u63A5_u53E3" class="headerlink" title="Debug 接口"></a>Debug 接口</h3><p>坐标采用 WGS84 标准，不同的标准有很多，<a href="http://blog.csdn.net/ma969070578/article/details/41013547" target="_blank" rel="external">参考来源</a>：</p>
<ul>
<li>WGS84 坐标系：即地球坐标系，国际上通用的坐标系。设备一般包含GPS芯片或者北斗芯片获取的经纬度为 WGS84 地理坐标系, 谷歌地图采用的是 WGS84 地理坐标系（中国范围除外）</li>
<li>GCJ02 坐标系：即火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由 WGS84 坐标系经加密后的坐标系。谷歌中国地图和搜搜中国地图采用的是 GCJ02 地理坐标系</li>
<li>BD09坐标系：即百度坐标系，GCJ02 坐标系经加密后的坐标系; 搜狗坐标系、图吧坐标系等，估计也是在 GCJ02 基础上加密而成的</li>
</ul>
<p>另一个坐标转换的<a href="https://github.com/wandergis/coordtransform" target="_blank" rel="external">项目</a></p>
<p>这里因为时间关系，只用非常简单粗暴的方式实现了 debug 接口。所有的数据处理都在 controller 层完成，并未涉及任何 model（暂时还不需要）</p>
<p>Debug 接口主要用于内部测试，对于参数的传递要求比较灵活，主要是基于地理位置进行测试，输入除 position 外都是经纬度坐标</p>
<ul>
<li><code>/debug</code> (GET) 连接测试函数</li>
<li><code>/debug/position</code> (POST) 获取指定用户的当前位置</li>
<li><code>/debug/weather</code> (GET) 获取指定位置附近的天气状况</li>
<li><code>/debug/flight</code> (GET) 获取指定位置附近的航班</li>
<li><code>/debug/near</code> (POST) 获取指定位置附近的航班</li>
<li><code>/debug/upload</code> (POST) 测试复杂数据上传</li>
</ul>
<h2 id="u6570_u636E_u5E93_u8BBE_u8BA1"><a href="#u6570_u636E_u5E93_u8BBE_u8BA1" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>设计数据库之前，我们先要做一些准备工作：</p>
<ul>
<li>安装 Go 的数据库驱动 <code>go get github.com/go-sql-driver/mysql</code></li>
<li>连接到测试用数据库 <code>mysql -h[host ip] -P[host port] -u[user name] -p[password]</code></li>
<li>查看已有的数据库 <code>show databases;</code></li>
<li>新建数据库 <code>create database wptdb</code></li>
<li>使用该数据库 <code>use wptdb</code></li>
<li>清空某表 <code>truncate table history</code></li>
</ul>
<p>因为我们需要记录在线的人，所以得要一个表，叫做 <code>current</code>；另外我们需要记录历史纪录，所以需要另外一个表，叫做 <code>history</code>，这两个表的差别在于其中一个会对数据进行修改和删除，另一个则不会。</p>
<p>因为功能不同，这两个表的设计也不尽相同（主要是主键的选择）。<code>current</code> 表需要经常更新，<code>history</code> 表更多是记录轨迹和时间。</p>
<p>Current 表的初步设计，这里在基本信息中加入了一个 <code>region</code> 字段，用来标识所在分区，这样在检索的时候可以极大提高效率。为什么要用 BIGINT 这里说一下。经度范围 0-360，维度为 0-180，如果精确到 0.001 的话，就是<br><code>36000*18000=648,000,000</code>，加上为高度预留的 3 位，就是 12 位，是超过 INT 所能表示的大小的。时间戳为 UNIX 时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`current`</span> (</span><br><span class="line">    <span class="string">`uid`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`latitude`</span> <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`longitude`</span> <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`altitude`</span> <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`timestamp`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`region`</span> <span class="built_in">BIGINT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`online`</span> TINYINT <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`uid`</span>)</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>History 表的初步设计主要是保证每条数据的唯一性（也就是主键），以及同一个 id 的数据要尽可能放在一起方便检索。这里的 <code>actionid</code> 是由 <code>uid</code> 和 <code>timestamp</code> 拼接而成的。而 <code>location</code> 是由 经纬度和高度拼接而成的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`history`</span>(</span><br><span class="line">    <span class="string">`actionid`</span> <span class="built_in">CHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`location`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`timestamp`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`actionid`</span>)</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<h2 id="u6846_u67B6_u642D_u5EFA"><a href="#u6846_u67B6_u642D_u5EFA" class="headerlink" title="框架搭建"></a>框架搭建</h2><p>借助 beego，对于框架部分我们需要做的不多，主要就是配置好路由和对应的 Controller，具体可以参见代码。简单来说，就是新建一个 <code>struct</code> 包含 <code>beego.Controller</code>，然后对应写函数，并在路由中注册，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.go</span></span><br><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"watch-plane-together/controllers"</span></span><br><span class="line">	<span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> init() &#123;</span><br><span class="line">    beego.Router(<span class="string">"/"</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">    beego.Router(<span class="string">"/debug/"</span>, &amp;controllers.DebugController&#123;&#125;)</span><br><span class="line">    beego.Router(<span class="string">"/debug/position"</span>, &amp;controllers.DebugController&#123;&#125;, <span class="string">"post:DebugPosition"</span>)</span><br><span class="line">    beego.Router(<span class="string">"/debug/weather"</span>, &amp;controllers.DebugController&#123;&#125;, <span class="string">"get:DebugWeather"</span>)</span><br><span class="line">    beego.Router(<span class="string">"/debug/flight"</span>, &amp;controllers.DebugController&#123;&#125;, <span class="string">"get:DebugFlight"</span>)</span><br><span class="line">    beego.Router(<span class="string">"/debug/near"</span>, &amp;controllers.DebugController&#123;&#125;, <span class="string">"post:DebugNear"</span>)</span><br><span class="line">    beego.Router(<span class="string">"/debug/upload"</span>, &amp;controllers.DebugController&#123;&#125;, <span class="string">"post:DebugUpload"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要在 <code>debug.go</code> 中对应编写 <code>DebugPosition</code>, <code>DebugWeather</code>, <code>DebugFlight</code> 和 <code>DebugUpload</code> 方法即可。这里需要注意，附近的人具体的算法没有实现，会在之后专门介绍。</p>
<h2 id="u6D4B_u8BD5_u90E8_u7F72"><a href="#u6D4B_u8BD5_u90E8_u7F72" class="headerlink" title="测试部署"></a>测试部署</h2><p>接口测试可以使用 Chrome 插件 Postman，部署的话，因为 Go 直接静态编译，扔到服务器上运行即可，或者参考<a href="http://beego.me/docs/deploy/" target="_blank" rel="external">这里</a></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>因为 beego 的缘故，其实只需要不到 200 行代码就可以完成基本的 demo 后台搭建，后面的 mvc 封装等等可以随着项目进行具体调整，作为一个简单的展示大约是足够的，进一步的学习就需要多多阅读源码，真正用 Go 的思路来写代码了。 </p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/wdxtub/Watch-Plane-Together/tree/master" target="_blank" rel="external">项目源代码</a></li>
<li><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/08.3.html" target="_blank" rel="external">8.3 REST</a></li>
<li><a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="external">go-sql-driver/mysql</a></li>
<li><a href="http://www.cnblogs.com/good_hans/archive/2010/03/29/1700046.html" target="_blank" rel="external">Mysql 远程登录及常用命令</a></li>
<li><a href="http://blog.csdn.net/hanxuemin12345/article/details/7818662" target="_blank" rel="external">数据库中删除语句Drop、Delete、Truncate的相同点和不同点的比较（举例说明）</a></li>
<li><a href="http://blog.csdn.net/pandajava/article/details/45667001" target="_blank" rel="external">MySQL 插入条件判断</a></li>
<li><a href="http://blog.rpplusplus.me/blog/2014/03/18/yahoo-weather-api/" target="_blank" rel="external">Yahoo Weather API</a></li>
<li><a href="https://github.com/bitly/go-simplejson" target="_blank" rel="external">bitly/go-simplejson</a></li>
<li><a href="https://developer.yahoo.com/weather/archive.html" target="_blank" rel="external">Yahoo! Weather RSS Feed</a></li>
<li><a href="https://developer.yahoo.com/yql/console/" target="_blank" rel="external">Yahoo YQL Console</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面已经了解了『一起看飞机』的基本需求，这次我们来搭建一个完整的基于 beego 框架的后台。同时也会涉及调试测试部署等一系列配套工作，我觉得这些反而是工作中很重要的能力，但不知道为啥大部分书都略过了。</p>]]>
    
    </summary>
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="项目" scheme="http://wdxtub.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="飞机" scheme="http://wdxtub.com/tags/%E9%A3%9E%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Go 之旅】III 项目实战：一起看飞机 - 项目介绍]]></title>
    <link href="http://wdxtub.com/2016/08/24/go-plane-1/"/>
    <id>http://wdxtub.com/2016/08/24/go-plane-1/</id>
    <published>2016-08-24T14:57:34.000Z</published>
    <updated>2016-08-24T15:06:01.000Z</updated>
    <content type="html"><![CDATA[<p>经过之前的两篇文章，应该已经对 Go 有了一定的了解，不过想要真正掌握，还是得做项目，这里我结合工作的内容，设计了『一起看飞机』这么一个无厘头项目，将通过三篇文章来介绍具体的设计和实现。</p>
<a id="more"></a>
<hr>
<p>实话实说，因为我对博客的热爱，本来我是打算做一个博客系统的，简单搜索了一下，已经有几百个轮子了，所以我只好开了这么一个奇怪的脑洞。</p>
<h2 id="u603B_u4F53_u4ECB_u7ECD"><a href="#u603B_u4F53_u4ECB_u7ECD" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>假设有很多飞机的狂热爱好者，假设这些爱好者都喜欢看飞机，假设这些看飞机的爱好者想要一起看飞机，在这么多假设时候，产品经理感觉找到了一个刚需，所以决定开发一个『一起看飞机』的 APP，帮助飞机爱好者凑到一起看飞机。</p>
<p>为了早日上线，产品经理决定第一个版本只需要做很少的功能，甚至都不需要一个图形界面，用文字先凑合就行。我花了五分钟花了一个草图，产品经理表示可以，如下：</p>
<p><img src="/images/14720510281192.jpg" alt=""></p>
<p>只能说，简约不简单！</p>
<h2 id="u57FA_u672C_u529F_u80FD"><a href="#u57FA_u672C_u529F_u80FD" class="headerlink" title="基本功能"></a>基本功能</h2><p>好吧，其实简约也简单，具体需要的功能是</p>
<ul>
<li>告知用户附近的人，包括距离和昵称</li>
<li>获取位置告知用户当前的天气、温度、风向</li>
<li>获取用户附近的航线</li>
</ul>
<p>如果不考虑具体展示的话，其实就是维护一个数据库，然后在用户上报位置的时候做一些查询并返回。</p>
<p>虽然看起来很简单，但是也已经足够我们通过这个无厘头项目来了解 Go 了，将会涉及的后台相关技术和原理有：</p>
<ul>
<li>Web 基本工作方式</li>
<li>连接数据库</li>
<li>处理 JSON 格式的文件</li>
<li>Socket 与 WebSocket</li>
<li>RESTful API 的设计和实现</li>
<li>数据的简单加密和解密</li>
<li>错误处理、调试和测试</li>
<li>部署与维护</li>
</ul>
<p>当然我们也会简单涉及一些客户端（Web 和 iOS）的编程，以及创建一些自己用的调试用接口。</p>
<p>接下来的文章中，我会从后台开始搭建起，尽量用简单且清晰的方式把 Web 开发的方方面面展现给大家。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/wdxtub/Watch-Plane-Together/tree/master" target="_blank" rel="external">项目源代码</a></li>
<li><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/index.html" target="_blank" rel="external">Go Web 编程</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过之前的两篇文章，应该已经对 Go 有了一定的了解，不过想要真正掌握，还是得做项目，这里我结合工作的内容，设计了『一起看飞机』这么一个无厘头项目，将通过三篇文章来介绍具体的设计和实现。</p>]]>
    
    </summary>
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="项目" scheme="http://wdxtub.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="飞机" scheme="http://wdxtub.com/tags/%E9%A3%9E%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 指南]]></title>
    <link href="http://wdxtub.com/2016/08/23/git-guide/"/>
    <id>http://wdxtub.com/2016/08/23/git-guide/</id>
    <published>2016-08-23T14:37:08.000Z</published>
    <updated>2016-08-23T14:39:01.000Z</updated>
    <content type="html"><![CDATA[<p>虽然网上 Git 相关指南已经够多了，不过没有自己整理过一次，用得时候还是经常忘，所以这里按照自己的思路来写一篇，跟大家分享一下。</p>
<a id="more"></a>
<hr>
<p>本指南会按照自己工作的经验来进行相关命令的选择，力求贴近实战。慢慢更新中</p>
<h2 id="u68C0_u51FA_u4ED3_u5E93"><a href="#u68C0_u51FA_u4ED3_u5E93" class="headerlink" title="检出仓库"></a>检出仓库</h2><p>一般来说，刚到公司，参与某个项目，第一件事情就是看代码，在开了项目的 Git 权限之后，我们要做的第一步就是把代码克隆到本地，命令为：</p>
<p><code>git clone username@host:/path/to/repository</code></p>
<h2 id="u672C_u5730_u4ED3_u5E93_u7ED3_u6784"><a href="#u672C_u5730_u4ED3_u5E93_u7ED3_u6784" class="headerlink" title="本地仓库结构"></a>本地仓库结构</h2><p>本地仓库由 git 维护的三棵“树”组成。第一个是你的<strong>工作目录</strong>，它持有实际文件；第二个是<strong>暂存区（Index）</strong>，它像个缓存区域，临时保存你的改动；最后是 <strong>HEAD</strong>，它指向你最后一次提交的结果。</p>
<p><img src="/images/14719631395607.jpg" alt=""></p>
<h2 id="u5DE5_u4F5C_u6D41_u7A0B"><a href="#u5DE5_u4F5C_u6D41_u7A0B" class="headerlink" title="工作流程"></a>工作流程</h2><p>在熟悉了代码之后，组长交给你一个任务。因为是多人共同开发，所以用分支来进行隔离。</p>
<ul>
<li>创建分支 <code>git checkout -b new_branch_name</code></li>
<li>如果主分支经常改动，用 <code>git pull</code> 拉取最新的代码</li>
</ul>
<p>因为我们都是武艺高强的程序员，所以很快就完成了开发和测试，需要提交代码</p>
<ul>
<li>添加文件 <code>git add *</code></li>
<li>提交到 HEAD <code>git commit -m &quot;message&quot;</code></li>
<li>推送改动 <code>git push origin new_branch_name</code></li>
<li>然后可以在 Gitlab 网页中发起合并请求，等组长 review 通过后便可以进行代码合并</li>
<li>删除分支 <code>git branch -d new_branch_name</code></li>
</ul>
<h2 id="u610F_u5916_u5904_u7406"><a href="#u610F_u5916_u5904_u7406" class="headerlink" title="意外处理"></a>意外处理</h2><p>如果操作失误，可以使用 <code>git checkout -- filename</code> 来替换最后一次提交的文件。</p>
<p>如果想丢弃本地所有改动并与服务器同步，可以使用 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>
<h2 id="u5176_u4ED6_u64CD_u4F5C"><a href="#u5176_u4ED6_u64CD_u4F5C" class="headerlink" title="其他操作"></a>其他操作</h2><ul>
<li><code>git init</code> 用来创建新仓库，不过在公司里一般有内部的 Gitlab，很少需要用到</li>
<li><code>git clone /path/to/repository</code> 克隆本地仓库，一般比较少用到</li>
</ul>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git - 简明指南</a></li>
<li><a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md" target="_blank" rel="external">Git Workflows and Tutorials</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然网上 Git 相关指南已经够多了，不过没有自己整理过一次，用得时候还是经常忘，所以这里按照自己的思路来写一篇，跟大家分享一下。</p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://wdxtub.com/tags/Git/"/>
    
      <category term="版本控制" scheme="http://wdxtub.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跑步与技术债]]></title>
    <link href="http://wdxtub.com/2016/08/22/running-and-tech-debt/"/>
    <id>http://wdxtub.com/2016/08/22/running-and-tech-debt/</id>
    <published>2016-08-22T13:49:48.000Z</published>
    <updated>2016-08-22T15:39:39.000Z</updated>
    <content type="html"><![CDATA[<p>单纯跑步是很快乐的，但是有一个配速，就要努力跑。单纯做技术也是快乐的，但是有一堆技术债，就不只是努力可以搞得定的了。今天我们来聊聊技术债的问题。</p>
<a id="more"></a>
<hr>
<p>关于技术债的文章大多以非常规范的口吻一板一眼在写，读起来有些膈应，所以我决定写一篇接地气的，正好最近把公司里软件相关的项目接触了个遍，在对接的时候还是深深能感受到短平快带来的技术债。一家之言，随便聊聊，以下所有内容都属于梦话，我就这么一写，您就这么一看，关了网页就忘掉吧。</p>
<p>每天我跑步回家总路程大约是 4.3 公里，需要过四个十字路口和一个天桥。四个十字路口有两个在第一公里，第二和第四公里各有一个，而天桥也是在第四公里。</p>
<p>那么问题来了，如果我想要把全程的配速稳定在五分钟以内，具体需要怎么分配时间？</p>
<p>理想情况下当然是匀速，但是因为马路并不是像跑步机这样的恒定的理想环境，就需要处理各种各样的意外情况了。比如：</p>
<ul>
<li>在第一公里因为两个十字路口的原因花了六分钟</li>
<li>在第四公里的天桥处为了节省体力走路上台阶和爬坡</li>
<li>因为没有午休在第三公里后体力迅速枯竭</li>
</ul>
<p>要怎么办？</p>
<p>先说说我的策略</p>
<ul>
<li>第一公里：因为等待十字路口红绿灯的时间不可控也没有办法跳过，所以得尽可能在不受红绿灯制约的路上『要回来一点时间』，包括预估信号灯的变化并据此调整速度（比如说离路口还有一百米，看到是红灯，其实就可以稍微放慢点速度以节省体力）只要能在 5 分 30 秒之内完成，后面就不会太辛苦（后面的平均时间需要 4 分 50 秒以下）</li>
<li>第二公里：只有一个十字路口，后面将是路况较好的路段，所以在十字路口前可以适当保留体力，然后进入较高速的匀速阶段（大约 4 分 30 秒左右）</li>
<li>第三公里：几乎全程无阻碍（除了下班的人群），是为未来保留余量的最佳时机（大约 4 分 30 秒左右）</li>
<li>第四公里：体力需要精打细算，一般来说经过天桥的折磨，后面得依靠呼吸和发力部位来调整（能在 5 分 20 秒左右完成就很好）</li>
</ul>
<p>幸运的是一般来说还是能勉强达标的，可是做技术就没有跑步这么简单粗暴了。</p>
<ul>
<li>老板催得急，要的就是短平快，粗糙就粗糙吧，质量差点没关系</li>
<li>人力不够，不停被打断，很多应完成的计划都处于做了一点但是又没做完的尴尬境地</li>
<li>没有测试，祈祷式编程</li>
<li>没有文档或者文档除了原来的开发团队谁都看不懂，没办法拓展</li>
<li>架构设计随意或者过分依赖框架，最终一大堆代码耦合在一起成了烂摊子谁都不愿意管</li>
<li>重复工作没有自动化，不得不耗费大量时间在零碎小事上</li>
<li>团队沟通不畅，下面的人忙的要死上面的人却感觉大家都很空闲</li>
<li>朝令夕改，各种临时的紧急需求</li>
<li>步调不一，有种无头苍蝇般瞎忙</li>
<li>流程混乱，同一个事情绕来绕去，当然一定要说为了『安全』，只能说从一开始就不信任员工吧</li>
</ul>
<p>就好像第一公里跑了十五分钟，后面跑得再快，也没办法追回来了。但是老板却又觉得肯定是能追回来的，那么结果倒是蛮清晰的，就看哪一天弦绷断了呗。</p>
<p>以上除了跑步部分都是道听途说和胡拼八凑，没有任何一点对号入座的意思。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>单纯跑步是很快乐的，但是有一个配速，就要努力跑。单纯做技术也是快乐的，但是有一堆技术债，就不只是努力可以搞得定的了。今天我们来聊聊技术债的问题。</p>]]>
    
    </summary>
    
      <category term="人才" scheme="http://wdxtub.com/tags/%E4%BA%BA%E6%89%8D/"/>
    
      <category term="技术债" scheme="http://wdxtub.com/tags/%E6%8A%80%E6%9C%AF%E5%80%BA/"/>
    
      <category term="跑步" scheme="http://wdxtub.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[主流程序员的自我修养]]></title>
    <link href="http://wdxtub.com/2016/08/21/im-a-programmer-too/"/>
    <id>http://wdxtub.com/2016/08/21/im-a-programmer-too/</id>
    <published>2016-08-21T14:10:16.000Z</published>
    <updated>2016-08-21T15:05:58.000Z</updated>
    <content type="html"><![CDATA[<p>工作也有一段时间了，无论是亲身实践还是观察他人，或多或少能意识到怎么样才是一个『好』的工程师。本文是我的一点思考。</p>
<a id="more"></a>
<hr>
<p>在美国的时候，教授常常跟我说，engineering 和 engineer 在大家看来是特别神圣的词，因为这意味着他们做的事情和他们本身，都是为了解决问题而存在的。而在开源运动风风火火的今天，写代码其实只是工程师应该具备的能力的一小部分。还有很多代码之外的东西，需要去学习和实践。</p>
<p>调试是最基本的技能之一，IDE 是如此强大，搞得很多人以为调试就是设个断点或者输出一下值，但其实并不是这样的，或者说，这不是问题的核心。那么问题的核心是什么？</p>
<p><strong>掌控</strong></p>
<p>通过断点或输出来分离代码确定错误点，然后进行修复。这里一定要弄清楚是因为程序员的无心之失导致的错误，还是因为系统设计的模糊性导致的实现不一致。前者只牵一发，后者要动全身。而对于需要 7x24 运行的服务来说，对于服务质量的掌控，很多时候是通过日志实现的。日志这个是个大话题，通过汇总线上的各类数据，可以确定重点代码进行重点优化，尤其是在计算资源或者带宽资源吃紧的时候，从数据出发才是有的放矢。一般来说需要注意两个地方，一是 IO，二是资源共享。</p>
<p>IO 部分的优化通常是要么是利用缓存，尽量一次多做一点事情，要么是减少数据的传输量，不过这个无形之中增加了设计的复杂度，具体使用的时候需要权衡。资源共享部分涉及某种确定资源使用的机制，比方说锁或者信号量之类的，这部分本身就是很难的，比较好的办法是设计时就尽量隔离，不要过分依赖于资源共享。</p>
<p>另一个增加掌控的方法是写文档，文档可以看作是在时间尺度上的掌控，因为认真写文档的代码，即使过几年再看，也很容易跟上当时的思路，否则就容易迷失在茫茫跳转中。而面对糟糕的代码，文档其实也是很好的重构工具，尤其是在测试紧缺的情况下，通过文字辅助理解可能是最为保险的选择。</p>
<p>关于团队其实是另一个话题，不过说到底原则其实很简单：把自己手头上的事情用心做好，并以此带动同事，成为值得信任的人，才有可能赢得信任。今天看女排赛后采访，听郎平说了两个词『承担』和『包容』，的的确确是成为顶梁柱所必备的素质。</p>
<p>工程师应该把时间花在关键问题上，无聊且机械化的事情，哪怕第一次可能会比较麻烦，必须要交给机器来做。所谓关键问题，就是那些能真正创造价值，或者能让创造价值的过程更好的问题。更重要的是，要让提供资源的人能够意识到解决这些问题的价值。</p>
<p>不过话说回来，掌控也需要一个度，也要容忍一定的黑盒，总不能啥都重新发明一次轮子吧。所谓『掌控』，不是啥都亲力亲为，最后累得死去活来还不一定能达到效果，而是找到关键点，用最少的成本来达到自己想要的效果。</p>
<p>没错，我说的就是《永恒的终结》。观测师和程序员其实挺像的，而我也一定会像小说中那样，愿意为自己珍惜的东西，拼尽一切。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工作也有一段时间了，无论是亲身实践还是观察他人，或多或少能意识到怎么样才是一个『好』的工程师。本文是我的一点思考。</p>]]>
    
    </summary>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="能力" scheme="http://wdxtub.com/tags/%E8%83%BD%E5%8A%9B/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第十周 - 茶酒伴]]></title>
    <link href="http://wdxtub.com/2016/08/19/tea-wine-friend/"/>
    <id>http://wdxtub.com/2016/08/19/tea-wine-friend/</id>
    <published>2016-08-19T14:44:32.000Z</published>
    <updated>2016-08-19T16:04:15.000Z</updated>
    <content type="html"><![CDATA[<p>青山在，杨柳湾，无人等风来。杏花开，绿水盘，新芽莫摘采。知是一年春又来，冰雪也消散。山路若陡缓步迈，斗酒洒羁绊。</p>
<a id="more"></a>
<hr>
<p>这周平静却暗藏汹涌。周一从广州直接赶回深圳上班，周二到周五跑了四天，终于借着奥运会的东风成绩有所突破。因为台风的缘故，白天总是下雨，所以打着伞穿着拖鞋赶车上班，下班的时候总不能把第二天要用的伞和拖鞋留在公司，所以只好左手拖鞋右手伞往家里跑，路人一定很诧异为啥有个人疯疯癫癫气喘吁吁手里拿着这么奇怪的组合，没想到以这种奇葩的形式不走寻常路。</p>
<p>这两周和另一个老司机一起把公司的数据和日志平台搭建好并正式启用。因为各种历史遗留原因，我们一边填之前别人挖的坑以保证服务质量，一边着手搭建新的更加通用和规范的平台。写文档、设规范流程、重构代码居然能在两周之内搞完，我都被这样的效率震惊了。现在后台的开发和维护已经慢慢走上正轨，总算是有了一个好的地基了。</p>
<p>不过做这些填坑的活简单来说就是没有太多汇报的东西，领导并不会在意代码质量，很多时候他们在意的是能汇报些什么，不同决策之间也没有同步好，总体来说还有成吨地方可以改进。现在慢慢可以理解为什么跨部门合作一定要抄送对方的领导了，不然人家完全不鸟你好嘛。所以这样的后果就是大家都只做可以汇报的工作，于是越来越追求短平快，能用但摇摇欲坠，最终积重难返。</p>
<p>只能说我做事的风格不是这样的，我也不想改变，还是要做真正有价值对得起自己的事情，从我手上交出去的，一定是达到我自己的标准的，而不是简单做完就好，希望能让我看到事情在往好的方面发展的迹象吧。</p>
<p>关于写书，最近有比较大的思路调整（感谢我的编辑及时给我寄来的相关新书），也正式开始正文部分的写作和润色，真的是『鬼知道我经历了什么』。不过目前来看我还是比较满意自己的写作质量的，希望这两三个月能够持续输出，交出一份漂亮的答卷。另外因为自己写了一系列关于 ELK 的文章，（又）有出版社的编辑来约稿，不过因为时间精力能力的原因只能往后排，相信经过更多时间的磨练，写出来的东西会更好吧。这也再次说明了写博客的好处，做的哪怕是微小的工作，也要努力让大家知道，不然就成了小透明了（在公司里我也要想办法展示自己，但绝不要踩在别人头上的那种）。</p>
<p>最后插播两条新闻，一是分别针对国内外的读者部署的两套博客，通过 DNS 解析来定位，应该是极大提高了国内读者的访问体验。二是 Dota2 Ti6 Wings 战队夺冠，真乃『护国神翼』，我们太需要一个这样的故事，专注于本职工作的团队才最有资格获得最高荣誉，而不是那些直播和卖饼的。</p>
<p>这周完美执行了减肥和健身计划（吃了五天沙拉），下周要继续努力。</p>
<p>雨生哀，镜尘满，韶颜虽易改。弃脂彩，肠何断，拂手去青苔。衷心诉了春过半，平生光影短。儿女情长愁摩愁，不如茶相伴。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>青山在，杨柳湾，无人等风来。杏花开，绿水盘，新芽莫摘采。知是一年春又来，冰雪也消散。山路若陡缓步迈，斗酒洒羁绊。</p>]]>
    
    </summary>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="生活" scheme="http://wdxtub.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Logstash 连接 Kafka 指南]]></title>
    <link href="http://wdxtub.com/2016/08/18/logstash-kafka-guide/"/>
    <id>http://wdxtub.com/2016/08/18/logstash-kafka-guide/</id>
    <published>2016-08-18T12:00:31.000Z</published>
    <updated>2016-08-18T12:01:08.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我对 Logstash 颇有微词，但是与系统自带的 rsyslog 相比还是好用很多的，本文介绍如何快速连接 Logstash 与 Kafka。</p>
<a id="more"></a>
<hr>
<h2 id="u603B_u4F53_u601D_u8DEF"><a href="#u603B_u4F53_u601D_u8DEF" class="headerlink" title="总体思路"></a>总体思路</h2><p>还是之前的场景，我需要把各个业务的线上服务器日志接入到统一的日志处理平台中。具体会用 Kafka 做中间件，所以需要解决的就是如何把日志传到 Kafka。原先的考虑是利用系统自带的 rsyslog，这样我只需要自动配置一下 rsyslog 的处理发送规则就可以了，免去了安装和维护的麻烦。但是系统自带的 rsyslog 版本太低，所以到头来还是要更新维护，那就不如直接用更强大且更好用的 Logstash 了。</p>
<p>需要注意的有两点：</p>
<ul>
<li>不要即时推送日志，以免增加服务器负担</li>
<li>能够妥善处理 logrotate 的情况</li>
</ul>
<p>幸运的是，这 Logstash 都考虑到了，我们只需要简单配置一下即可。</p>
<h2 id="u5B89_u88C5_Java"><a href="#u5B89_u88C5_Java" class="headerlink" title="安装 Java"></a>安装 Java</h2><p>因为大部分线上服务器跑的是 Ruby，所以需要先安装一下 Java</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install oracle-java8-installer</span><br></pre></td></tr></table></figure>
<h2 id="u5B89_u88C5_Logstash"><a href="#u5B89_u88C5_Logstash" class="headerlink" title="安装 Logstash"></a>安装 Logstash</h2><p>在 <a href="http://wdxtub.com/2016/07/26/elk-guide/">ELK 指南</a>中介绍了用 <code>apt-get</code> 进行安装的方法，这里介绍如何手动下载安装</p>
<ul>
<li>下载到服务器 <code>wget https://download.elastic.co/logstash/logstash/logstash-all-plugins-2.3.4.tar.gz</code></li>
<li>解压 <code>tar -xvzf logstash-all-plugins-2.3.4.tar.gz</code></li>
<li>进入 Logstash 文件夹并创建配置文件夹（个人习惯） <code>cd logstash-2.3.4; mkdir confs</code></li>
</ul>
<p>之后所有的配置文件均可放在 <code>confs</code> 文件夹中。</p>
<h2 id="u914D_u7F6E_Logstash__u5230_Kafka"><a href="#u914D_u7F6E_Logstash__u5230_Kafka" class="headerlink" title="配置 Logstash 到 Kafka"></a>配置 Logstash 到 Kafka</h2><p>这里 Logstash 相当于 producer</p>
<h3 id="Input__u8BFB_u53D6_u6587_u4EF6"><a href="#Input__u8BFB_u53D6_u6587_u4EF6" class="headerlink" title="Input 读取文件"></a>Input 读取文件</h3><p>Logstash 使用一个名叫 FileWatch 的 Ruby Gem 库来监听文件变化。这个库支持 glob 展开文件路径，而且会记录一个叫 <code>.sincedb</code> 的数据库文件来跟踪被监听的日志文件的当前读取位置。通过记录下来的 <code>inode</code>, <code>major number</code>, <code>minor number</code> 和 <code>pos</code> 就可以保证不漏过每一条日志。一个可能的配置文件是这样的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; [<span class="string">"/data/home/service/project/current/log/logstash_production.log"</span>, <span class="string">"/data/home/service/project/current/log/logstash_production.log.1"</span>]</span><br><span class="line">    codec =&gt; <span class="string">"json"</span></span><br><span class="line">    add_field =&gt; &#123; <span class="string">"topic"</span> =&gt; <span class="string">"djiservice"</span>&#125;</span><br><span class="line">    stat_interval =&gt; <span class="number">1800</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里说一下 File rotation 的情况，为了处理被 rotate 的情况，最好把 rotate 之后的文件名也加到 path 中（如上面所示），这里注意，如果 <code>start_position</code> 被设为 <code>beginning</code>，被 rotate 的文件因为会被认为是新文件，而重新导入。如果用默认值 <code>end</code>，那么在最后一次读之后到被 rotate 结束前生成的日志不会被采集。</p>
<p>其他一些配置的设定原因</p>
<ul>
<li><code>add_field</code> 添加一个 topic 字段，用作之后导入 elasticsearch 的索引标识</li>
<li><code>stat_interval</code> 单位是秒，这里 30 分钟进行一次检测，不过测试的时候需要去掉这个配置</li>
<li><code>codec</code> 因为已经处理成 logstash 兼容格式，就直接以 json 解析</li>
</ul>
<h3 id="Filter__u5185_u5BB9_u5B9A_u5236"><a href="#Filter__u5185_u5BB9_u5B9A_u5236" class="headerlink" title="Filter 内容定制"></a>Filter 内容定制</h3><p>Filter 主要是对数据进行一些处理，比如说我用的是：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="name">filter</span> &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    remove_field =&gt; [<span class="string">"format"</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="name">geoip</span> &#123;</span><br><span class="line">    source =&gt; <span class="string">"ip"</span></span><br><span class="line">    fields =&gt; [<span class="string">"location"</span>, <span class="string">"city_name"</span>, <span class="string">"country_name"</span>, <span class="string">"country_code2"</span>,<span class="string">"country_code3"</span>, <span class="string">"region_name"</span>, <span class="string">"continent_code"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做的操作一是移除无效的域，二是把 ip 转换为地理位置，方便后期的处理。</p>
<h3 id="Output__u8F93_u51FA_u5230_Kafka"><a href="#Output__u8F93_u51FA_u5230_Kafka" class="headerlink" title="Output 输出到 Kafka"></a>Output 输出到 Kafka</h3><p>因为 Logstash 自带 Kafka 插件，直接配置上即可，比如：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="name">output</span> &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    topic_id =&gt; <span class="string">"test"</span></span><br><span class="line">    bootstrap_servers =&gt; <span class="string">"kafka_url:port"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是基本的配置及其设定原因</p>
<ul>
<li><code>topic_id</code> 指定 topic 来进行发送</li>
<li><code>bootstrap_servers</code> 这里是 Kafka 的接入地址</li>
</ul>
<p>其他一些需要注意的配置</p>
<ul>
<li><code>acks</code> 可以选的值为 <code>0</code>, <code>1</code>, <code>all</code>，这里解释一下，0 表示不需要 server 返回就认为请求已完成；1 表示需要 leader 返回才认为请求完成；all 表示需要所有的服务器返回才认为请求完成</li>
<li><code>batch_size</code> 单位是字节，如果是发送到同一分区，会攒够这个大小才发送一次请求</li>
<li><code>block_on_buffer_full</code> 这个设置在缓冲区慢了之后阻塞还是直接报错</li>
<li><code>buffer_memory</code> 发送给服务器之前的缓冲区大小，单位是字节</li>
<li><code>client_id</code> 可以在这里设定有意义的名字，就不一定要用 ip 和 端口来区分</li>
<li><code>compression_type</code> 压缩方式，默认是 <code>none</code>，其他可选的是 <code>gzip</code> 和 <code>snappy</code></li>
</ul>
<h2 id="u5229_u7528_Logstash__u4ECE_Kafka__u5BFC_u51FA_u6570_u636E_u5230_Elasticsearch"><a href="#u5229_u7528_Logstash__u4ECE_Kafka__u5BFC_u51FA_u6570_u636E_u5230_Elasticsearch" class="headerlink" title="利用 Logstash 从 Kafka 导出数据到 Elasticsearch"></a>利用 Logstash 从 Kafka 导出数据到 Elasticsearch</h2><p>这一步就比较简单了，先从 Kafka 中读取，然后写入到 elasticsearch，这里 Logstash 作为 consumer</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="name">output</span> &#123;</span><br><span class="line">  input &#123;</span><br><span class="line">    kafka &#123;</span><br><span class="line">      zk_connect =&gt; <span class="string">"localhost:2181"</span></span><br><span class="line">      topic_id =&gt; <span class="string">"log"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="name">stdout</span> &#123;</span><br><span class="line">     codec =&gt; rubydebug</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="name">elasticsearch</span> &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"url:port"</span>]</span><br><span class="line">    user =&gt; <span class="string">"name"</span></span><br><span class="line">    password =&gt; <span class="string">"password"</span></span><br><span class="line">    index =&gt; <span class="string">"%&#123;service&#125;-%&#123;+YYYY-MM-dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以按照配置的服务名称和日期来切割。</p>
<p>至此，我们完成了从 Logstash 到 Kafka 再到 Elasticsearch 的连接，下一步就可以用 kibana 来展示日志的监控分析结果了。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">Logstash 下载</a></li>
<li><a href="https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.html" target="_blank" rel="external">配置文件格式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我对 Logstash 颇有微词，但是与系统自带的 rsyslog 相比还是好用很多的，本文介绍如何快速连接 Logstash 与 Kafka。</p>]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://wdxtub.com/tags/Kafka/"/>
    
      <category term="Logstash" scheme="http://wdxtub.com/tags/Logstash/"/>
    
      <category term="日志" scheme="http://wdxtub.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rsyslog 连接 Kafka 指南]]></title>
    <link href="http://wdxtub.com/2016/08/17/rsyslog-kafka-guide/"/>
    <id>http://wdxtub.com/2016/08/17/rsyslog-kafka-guide/</id>
    <published>2016-08-17T13:04:14.000Z</published>
    <updated>2016-08-17T13:07:38.000Z</updated>
    <content type="html"><![CDATA[<p>从去耦合和安全性考虑，最近在负责把公司内各个业务的日志统一接入到 Kafka 再进行下一步的处理，除了常见的 ELK 方案，我还尝试了系统自带的 rsyslog，以下是具体的配置过程。</p>
<a id="more"></a>
<hr>
<p>Kafka 集群的配置可以在<a href="http://wdxtub.com/2016/08/15/kafka-guide/">这里</a>查阅，这里不再赘述，认为大家已经有一个可以正常运行的 Kafka 集群，并且创建了一个名为 test 的 topic</p>
<h2 id="Nginx__u914D_u7F6E"><a href="#Nginx__u914D_u7F6E" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><p>因为 Kafka 集群的通讯是走内网 ip，而外网访问的端口因为安全考虑只开了少数几个（这里是 8080），所以我们用 Nginx 反向代理来连通内外网</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">upstream mq_pool&#123;</span><br><span class="line">server ip1:<span class="number">13647</span> weight=<span class="number">1</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">server localhost:<span class="number">13647</span> weight=<span class="number">1</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listen <span class="number">8080</span>;</span><br><span class="line">allow all;</span><br><span class="line">proxy_pass mq_pool;</span><br><span class="line">proxy_connect_timeout <span class="number">24</span>h;</span><br><span class="line">proxy_timeout <span class="number">24</span>h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置的意思大概是把所有 8080 端口的消息转发到 <code>mq_pool</code> 的两台机器上（负载均衡），其他的就是常规配置。</p>
<h2 id="Kafka_server__u914D_u7F6E"><a href="#Kafka_server__u914D_u7F6E" class="headerlink" title="Kafka server 配置"></a>Kafka server 配置</h2><p>用 Nginx 反向代理之后，可以认为完全是内网环境，所以 Kafka 设置中的<code>advertised.listeners</code> 是唯一能设定外网访问的地方，所以要设置为<strong>外网可以访问的地址（也就是 Nginx 中配置的地址和端口）</strong></p>
<p>然后需要注意的是修改 config 文件夹中的 producer 和 consumer 的配置，把集群的信息统一配置好</p>
<p>如果在测试 producer/consumer 的时候出现 <code>WARN Error while fetching metadata with correlation id</code> 错误，一般重新开启 producer/ consumer 即可（可能需要多试几次）</p>
<h2 id="Python__u6D4B_u8BD5"><a href="#Python__u6D4B_u8BD5" class="headerlink" title="Python 测试"></a>Python 测试</h2><p>为了检测外网访问，我们可以用 python 进行测试，先安装一个 <a href="https://github.com/dpkp/kafka-python" target="_blank" rel="external">Kafka 客户端</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install kafka-python</span><br></pre></td></tr></table></figure>
<p>然后在 python 中执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line">producer = KafkaProducer(bootstrap_servers=<span class="string">'url:port'</span>)</span><br><span class="line">producer.send(<span class="string">'test'</span>, <span class="string">'hello from python'</span>)</span><br></pre></td></tr></table></figure>
<p>如果一切正常，应该可以在 Kafka 的 consumer 中见到这条消息。</p>
<h2 id="Rsyslog__u914D_u7F6E"><a href="#Rsyslog__u914D_u7F6E" class="headerlink" title="Rsyslog 配置"></a>Rsyslog 配置</h2><p>一般来说默认的 rsyslog 版本较低，如果想要连接 kafka，我们需要先升级到最新版本。这里可以用 <code>rsyslogd -N1</code> 来查看目前机器上的版本。</p>
<p>执行下面的命令升级</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:adiscon/v8-stable </span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rsyslog</span><br><span class="line"><span class="comment"># 安装 kafka 插件</span></span><br><span class="line">sudo apt-get install rsyslog-kafka rsyslog-imptcp</span><br></pre></td></tr></table></figure>
<p>如果一切正常，我们就可以来配置 rsyslog 了，打开 <code>/etc/rsyslog.d/</code> 文件夹，创建一个配置文件 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">module(<span class="operator"><span class="keyword">load</span>=<span class="string">"omkafka"</span>)</span><br><span class="line"><span class="keyword">module</span>(<span class="keyword">load</span>=<span class="string">"imfile"</span>)</span><br><span class="line"></span><br><span class="line">ruleset(<span class="keyword">name</span>=<span class="string">"kafka"</span>) &#123;</span><br><span class="line">  <span class="keyword">action</span> (</span><br><span class="line">    <span class="keyword">type</span>=<span class="string">"omkafka"</span></span><br><span class="line">    topic=<span class="string">"test"</span></span><br><span class="line">    broker=<span class="string">"broker.ip:port"</span></span><br><span class="line">    <span class="keyword">template</span>=<span class="string">"json"</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>(<span class="keyword">type</span>=<span class="string">"imfile"</span> Tag=<span class="string">"wdxtub"</span> <span class="keyword">File</span>=<span class="string">"/data/log/logstash_production.log"</span> Ruleset=<span class="string">"kafka"</span>)</span></span><br></pre></td></tr></table></figure>
<p>然后我们重启服务 <code>sudo service rsyslog restart</code> 应该就可以在 kafka 自带的 consumer 中看到日志了。</p>
<p><code>bin/kafka-console-consumer.sh --zookeeper bi03:2181,bi02:2181 --from-beginning --topic test</code></p>
<p>至此，配置完成。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.jianshu.com/p/1b7fdb1cff3c" target="_blank" rel="external">日志收集之rsyslog to kafka</a></li>
<li><a href="http://www.rsyslog.com/tag/omkafka/" target="_blank" rel="external">Tag Archives: omkafka</a></li>
<li><a href="http://www.rsyslog.com/doc/master/configuration/modules/omkafka.html" target="_blank" rel="external">omkafka: write to Apache Kafka</a></li>
<li><a href="http://youfu.xyz/2016/04/27/rsyslog-json-kafka/" target="_blank" rel="external">rsyslog存储json日志到kafka</a></li>
<li><a href="https://dzone.com/articles/recipe-rsyslog-kafka-logstash-1" target="_blank" rel="external">Recipe: rsyslog + Kafka + Logstash</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>从去耦合和安全性考虑，最近在负责把公司内各个业务的日志统一接入到 Kafka 再进行下一步的处理，除了常见的 ELK 方案，我还尝试了系统自带的 rsyslog，以下是具体的配置过程。</p>]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://wdxtub.com/tags/Kafka/"/>
    
      <category term="rsyslog" scheme="http://wdxtub.com/tags/rsyslog/"/>
    
      <category term="日志" scheme="http://wdxtub.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Coding.net 静态博客托管指南]]></title>
    <link href="http://wdxtub.com/2016/08/17/add-coding-platform/"/>
    <id>http://wdxtub.com/2016/08/17/add-coding-platform/</id>
    <published>2016-08-17T11:47:31.000Z</published>
    <updated>2016-08-17T14:43:07.000Z</updated>
    <content type="html"><![CDATA[<p>因为众所周知的原因，Github 在国内的访问体验并不好。为了节省国内用户的时间，我决定把博客同时托管于 Github 和 Coding 两个平台。本文是具体的操作指南。</p>
<a id="more"></a>
<hr>
<h2 id="Coding__u5E73_u53F0_u64CD_u4F5C"><a href="#Coding__u5E73_u53F0_u64CD_u4F5C" class="headerlink" title="Coding 平台操作"></a>Coding 平台操作</h2><p>首先去<a href="https://coding.net" target="_blank" rel="external">官网</a>注册，然后在账户设置中添加 <code>SSH 公钥</code>，具体的步骤为（Mac 下，且已部署到 github）：</p>
<ul>
<li>输入命令 <code>cat ~/.ssh/id_rsa.pub</code></li>
<li>然后把输出的以 <code>ssh-rsa</code> 开头的字符串粘贴到网页中</li>
<li>接着测试一下 <code>ssh -T git@git.coding.net</code></li>
<li>成功的话应该出现 <code>Hello wdxtub! You&#39;ve connected to Coding.net via SSH successfully!</code></li>
</ul>
<h2 id="Hexo__u914D_u7F6E_u6587_u4EF6_u4FEE_u6539"><a href="#Hexo__u914D_u7F6E_u6587_u4EF6_u4FEE_u6539" class="headerlink" title="Hexo 配置文件修改"></a>Hexo 配置文件修改</h2><p>然后我们需要修改 hexo 的配置文件，主要是部署的部分，增加一行</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Deployment&#10;## Docs: http://hexo.io/docs/deployment.html&#10;deploy:&#10;  type: git&#10;  repository:&#10;    github: git@github.com:wdxtub/wdxtub.github.io.git&#10;    # &#22686;&#21152;&#36825;&#19968;&#34892;&#10;    coding: git@git.coding.net:wdxtub/wdxtub.git&#10;  branch: master</span><br></pre></td></tr></table></figure>
<p>然后 <code>hexo g -d</code> 部署即可，如果出现问题，可以删除 <code>.deploy_git</code> 文件夹后再尝试一次</p>
<h2 id="u914D_u7F6E_u57DF_u540D_u89E3_u6790"><a href="#u914D_u7F6E_u57DF_u540D_u89E3_u6790" class="headerlink" title="配置域名解析"></a>配置域名解析</h2><p>我的域名是在万网买的，所以直接在阿里云后台进行修改，这里海外走 github，默认走 coding（也就是国内）</p>
<p><img src="/images/14714441200850.jpg" alt=""></p>
<p>稍等一会儿，我们来测试一下，先是连接 VPN 的时候</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Documents/Blog [22:37:43]</span></span><br><span class="line">$ traceroute wdxtub.com</span><br><span class="line">traceroute to prod.github.map.fastlylb.net (<span class="number">151.101</span>.<span class="number">100.133</span>), <span class="number">64</span> hops max, <span class="number">52</span> byte packets</span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Documents/Blog [22:41:52]</span></span><br><span class="line">$ ping wdxtub.com</span><br><span class="line">--- prod.github.map.fastlylb.net ping statistics ---</span><br><span class="line"><span class="number">13</span> packets transmitted, <span class="number">13</span> packets received, <span class="number">0.0</span>% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = <span class="number">48.754</span>/<span class="number">53.315</span>/<span class="number">66.105</span>/<span class="number">4.174</span> ms</span><br></pre></td></tr></table></figure>
<p>然后是断开 VPN 的时候 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Documents/Blog [22:39:35]</span></span><br><span class="line">$ traceroute wdxtub.com</span><br><span class="line">traceroute: Warning: wdxtub.com has multiple addresses; using <span class="number">103.218</span>.<span class="number">243.203</span></span><br><span class="line">traceroute to pages.coding.net (<span class="number">103.218</span>.<span class="number">243.203</span>), <span class="number">64</span> hops max, <span class="number">52</span> byte packets</span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Documents/Blog [22:39:59]</span></span><br><span class="line">$ ping wdxtub.com</span><br><span class="line">--- pages.coding.net ping statistics ---</span><br><span class="line"><span class="number">14</span> packets transmitted, <span class="number">14</span> packets received, <span class="number">0.0</span>% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = <span class="number">17.390</span>/<span class="number">23.946</span>/<span class="number">37.623</span>/<span class="number">5.742</span> ms</span><br></pre></td></tr></table></figure>
<p>可以看到国内的访问应该有了大幅度的速度提升。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.jeyzhang.com/blog-on-gitcafe-with-dns-settings.html" target="_blank" rel="external">如何将博客托管至Coding及相应的DNS设置</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为众所周知的原因，Github 在国内的访问体验并不好。为了节省国内用户的时间，我决定把博客同时托管于 Github 和 Coding 两个平台。本文是具体的操作指南。</p>]]>
    
    </summary>
    
      <category term="博客" scheme="http://wdxtub.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="托管" scheme="http://wdxtub.com/tags/%E6%89%98%E7%AE%A1/"/>
    
      <category term="访问" scheme="http://wdxtub.com/tags/%E8%AE%BF%E9%97%AE/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我们需要怎样的计算机科学教育]]></title>
    <link href="http://wdxtub.com/2016/08/16/how-to-teach-cs/"/>
    <id>http://wdxtub.com/2016/08/16/how-to-teach-cs/</id>
    <published>2016-08-16T12:55:18.000Z</published>
    <updated>2016-08-16T14:44:34.000Z</updated>
    <content type="html"><![CDATA[<p>一直在想，轮到我自己来写教材，书的主题是什么。有的从软件硬件接口入手，有的从体系架构入手，还有的从性能设计入手。这些切入角度都不错，不过我今天找到了更好的——从『计算思维』入手。</p>
<a id="more"></a>
<hr>
<p>这两个月把各类计算机系统的课本和计算机科学经典书籍大致都翻了一遍，悟出了一个很重要的道理：一本好的教材，一本好书，一定是有灵魂的，不然纵使有了骨架和血肉，也像行尸走肉一样，拼拼凑凑，毫无生机。</p>
<p>另外一个让我很有感触的是工作之后的变化，从中能清晰认识到高校教育和工程实践中存在的巨大鸿沟。工程中会用到大量成熟半成熟的工具和应用，但是在高校中往往没有足够时间来进行磨练（毕竟是以学期为单位），不过这倒不是重点，高等教育的初衷并不是职业技能培训，而是帮助同学构建广泛而有时效性的知识体系，培养独立解决问题的能力。</p>
<p>而我们的学科设计和教材往往两头够不着，在各种条件的制约下成了『四不像』。而具体到计算机科学上，我的感觉是没有真正让同学们喜欢上这门本来非常有趣的学科，症结在哪里？今天无意间找到了答案——计算思维。其实倒也不复杂：从我们的教材开始，就没有着力去培养『计算思维』，或者说没有把一门实践学科以实践的方式来进行教学。</p>
<p><img src="/images/14713585528520.jpg" alt=""><br>（感谢曲鳖带我去湾区的计算机博物馆，真正看到了历史的痕迹，给我非常大的触动）</p>
<p>那么，计算思维到底说的是什么，不同人有不同的理解，我们来看看 Jeannette M. Wing 最初于 2006 年提出时的<a href="https://www.cs.cmu.edu/~15110-s13/Wing06-ct.pdf" target="_blank" rel="external">定义</a>（是我 CMU 的教授，也跟着沾沾光）</p>
<blockquote>
<p>计算思维是运用计算机科学的基础概念进行问题求解、系统设计以及人类行为理解等涵盖计算机科学之广度的一系列思维活动</p>
</blockquote>
<p>具体的表现呢？</p>
<ul>
<li>本质是抽象和自动化</li>
<li>递归思维</li>
<li>通过约简、嵌入、转化和仿真等方法，把一个困难的问题转化为我们已经有办法解决的问题</li>
<li>通过合适的表示及建模方法来使问题得以解决</li>
<li>把数据转换成代码，把代码转换为数据</li>
<li>通过抽象和分解来解决复杂问题</li>
<li>通过简洁和优雅来判断系统设计的优劣</li>
<li>通过冗余、容灾和错误处理来从最坏情况中恢复</li>
<li>…..</li>
</ul>
<p>仔细回忆一下，其实我们所学的很多东西，都是围绕着『计算思维』的，或者说，是为了培养『计算思维』而准备的。而一旦拥有了『计算思维』，就意味着能够以计算机科学的角度去思考，才能更好地去利用计算机的力量来解决问题。</p>
<p>然后我们就会发现，教育工作者和企业最希望学生拥有的能力，都包含在其中了，比如：</p>
<ul>
<li>持续学习能力 -&gt; 利用抽象和自动化等特性</li>
<li>独立解决问题的能力 -&gt; 通过抽象和分解来解决复杂问题</li>
<li>逻辑分析能力 -&gt; 通过约简、嵌入、转化和仿真等方法，把一个困难的问题转化为我们已经有办法解决的问题</li>
<li>开源精神 -&gt; 通过简洁和优雅来判断系统设计的优劣</li>
<li>理论与实际结合 -&gt; 把数据转换成代码，把代码转换为数据</li>
</ul>
<p>所以核心是：<strong>想办法在课程设计上和习题上击中这些要点</strong>。比如说，开一门课一定是因为学生的能力培养需要什么，而不是为了教书而教书。也应该摒弃『计算机基础教学就是教学生怎么将计算机作为工具使用』这种错误思想，而是着眼于培养『计算思维』能力。</p>
<p>据此，给自己开出的药方是：</p>
<ul>
<li>用经典案例结合计算学科基本问题讲述计算机科学的来龙去脉，并结合相关学科展望学科融合与跨界发展</li>
<li>通过动手实验了解计算机本质与解决问题的基本步骤（习题要好好设计）</li>
<li>每一章节都要围绕『计算思维』来写，帮助读者建立完整的思维框架，尤其是在抽象和自动化这两个层面上</li>
<li>针对重要的设计思想一定要用翔实的例子帮助读者理解清楚，更重要的是点出设计背后的思考，也就是『为什么要这么设计』</li>
<li>多一点私心：加入更多中国与汉字相关的内容，让读者了解我们在数字浪潮中的位置（比如说处理器相关的内容在介绍 x86-64 的基础上加入龙芯的内容）</li>
</ul>
<p>憋了这么久，就是在等这『悟道』的一天，有趣的是，兜兜转转居然是在 CMU 的网站上找到了最重要的灵感，正如当初选择上 15213 这门神课，仿佛一切都被安排好了。</p>
<p>有了魂，剩下的血肉就好组织了。</p>
<p>在这个特殊的日子，让我说一句：苟利国家生死以，岂因祸福避趋之。(提前 +1S)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直在想，轮到我自己来写教材，书的主题是什么。有的从软件硬件接口入手，有的从体系架构入手，还有的从性能设计入手。这些切入角度都不错，不过我今天找到了更好的——从『计算思维』入手。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="教育" scheme="http://wdxtub.com/tags/%E6%95%99%E8%82%B2/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Go 之旅】II 我的笨办法学 Go]]></title>
    <link href="http://wdxtub.com/2016/08/15/learn-go-the-hard-way/"/>
    <id>http://wdxtub.com/2016/08/15/learn-go-the-hard-way/</id>
    <published>2016-08-15T11:43:14.000Z</published>
    <updated>2016-08-23T14:39:22.000Z</updated>
    <content type="html"><![CDATA[<p>在学习新语言这个事情上，笨办法往往是最高效的办法。效仿『笨办法学 Python』和『笨办法学 Ruby』，我来写一篇『笨办法学 Go』吧！</p>
<a id="more"></a>
<hr>
<h2 id="u5F00_u59CB_u4E4B_u524D"><a href="#u5F00_u59CB_u4E4B_u524D" class="headerlink" title="开始之前"></a>开始之前</h2><p>在上一篇日志中我们大概对 Go 有了基本的认识，不过还不够系统，也远达不到掌握。所以就通过简单的例子和大量的编码练习来快速入门吧！因为 Go 的语法非常简洁明了，所以重点在于用习题突出一些特性，力求简短。</p>
<p>学新语言的关键点有三个：实践、能力培养和习惯养成。这些可能要比语言的语法本身更加重要！本日志基于 Go 1.6.3，仿照『笨办法学语言』系列的模式，用闯关的方式来学习。</p>
<p>具体的安装和基础知识可以参考 <a href="http://wdxtub.com/2016/08/11/golang-first-step/">Go 快速入门</a></p>
<p>本文的配套代码可以在<a href="https://github.com/wdxtub/learn-go-the-hard-way" target="_blank" rel="external">这里</a>查阅。</p>
<h2 id="u4E60_u9898_1__u7B2C_u4E00_u4E2A_u7A0B_u5E8F"><a href="#u4E60_u9898_1__u7B2C_u4E00_u4E2A_u7A0B_u5E8F" class="headerlink" title="习题 1 第一个程序"></a>习题 1 第一个程序</h2><p>我们先从简单的弄起，按照惯例，是一个 Hello World。新建一个名为 <code>ex1.go</code> 的文件，内容为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="comment">// 一个变量声明</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"dawang"</span></span><br><span class="line">    <span class="comment">// 也是一个变量声明</span></span><br><span class="line">    gender := <span class="string">"male"</span></span><br><span class="line">    fmt.Println(<span class="string">"What a great day! Let's Go!"</span>)</span><br><span class="line">    fmt.Println(name + <span class="string">"'s gender is "</span> + gender) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行 <code>go run ex1.go</code>，可以看到结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex1.go</span><br><span class="line">What a great day! Let<span class="string">'s Go!</span><br><span class="line">dawang'</span>s gender is male</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>注释用 <code>//</code> 或 <code>/* */</code>，与 C/C++ 一样</li>
<li>变量声明用 <code>var</code> 或 <code>:=</code></li>
<li>输出语句需要引用 fmt 包</li>
<li>函数的声明用 <code>func</code>，每个程序都需要一个 <code>main</code> 函数</li>
<li>程序基本结构</li>
<li>包 Package，每个程序都需要一个 main 包</li>
</ul>
<h2 id="u4E60_u9898_2__u6570_u5B57_u548C_u6570_u5B66_u8FD0_u7B97"><a href="#u4E60_u9898_2__u6570_u5B57_u548C_u6570_u5B66_u8FD0_u7B97" class="headerlink" title="习题 2 数字和数学运算"></a>习题 2 数字和数学运算</h2><p>主要来了解一下基本的运算符使用和最关键的取地址操作，代码在 <code>ex2.go</code> 中，如下 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Here are some basic fact:"</span>)</span><br><span class="line">  fmt.Println(<span class="string">"2 hour has"</span>, <span class="number">2</span>*<span class="number">60</span> , <span class="string">"seconds"</span>, )</span><br><span class="line">  fmt.Println(<span class="string">"Averge days in a month is"</span>, <span class="number">365.0</span> / <span class="number">12</span>)</span><br><span class="line">  fmt.Println(<span class="string">"Is it true that 3 + 2 &lt; 5 - 7?"</span>, (<span class="number">3</span> + <span class="number">2</span>) &lt; (<span class="number">5</span> - <span class="number">7</span>))</span><br><span class="line">  name := <span class="string">"wdxtub.com"</span></span><br><span class="line">  fmt.Println(<span class="string">"The address for variable 'name' is"</span>, &amp;name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex2.go</span><br><span class="line">Here are some basic fact:</span><br><span class="line"><span class="number">2</span> hour has <span class="number">120</span> seconds</span><br><span class="line">Averge days <span class="keyword">in</span> a month is <span class="number">30.416666666666668</span></span><br><span class="line">Is it <span class="literal">true</span> that <span class="number">3</span> + <span class="number">2</span> &lt; <span class="number">5</span> - <span class="number">7</span>? <span class="literal">false</span></span><br><span class="line">The address <span class="keyword">for</span> variable <span class="string">'name'</span> is <span class="number">0</span>xc42000a410</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>遍历的声明</li>
<li>数值大小的比较</li>
<li>取变量的地址</li>
</ul>
<h2 id="u4E60_u9898_3__u8F93_u5165_u8F93_u51FA"><a href="#u4E60_u9898_3__u8F93_u5165_u8F93_u51FA" class="headerlink" title="习题 3 输入输出"></a>习题 3 输入输出</h2><p>输入输出主要涉及两个包，一个是 <code>fmt</code>，一个是 <code>bufio</code>。这里我们只做一个简单的任务，就是把用户输入的东西再输出出来，见 <code>ex3.go</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"bufio"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  reader := bufio.NewReader(os.Stdin)</span><br><span class="line">  fmt.Printf(<span class="string">"Type something: "</span>)</span><br><span class="line">  <span class="keyword">if</span> line, err := reader.ReadString(<span class="string">'\n'</span>); err != <span class="constant">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Something Wrong"</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"You just typed:"</span>, line)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex3.go</span><br><span class="line">Type something: Today is a bad day?</span><br><span class="line">You just typed: Today is a bad day?</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li><code>bufio</code> 包的简单使用</li>
</ul>
<h2 id="u4E60_u9898_4__u547D_u4EE4_u884C_u53C2_u6570"><a href="#u4E60_u9898_4__u547D_u4EE4_u884C_u53C2_u6570" class="headerlink" title="习题 4 命令行参数"></a>习题 4 命令行参数</h2><p>很多时候我们把需要配置的部分设置成命令行参数是非常方便的选择，代码可参见 <code>ex4.go</code>，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  name := <span class="string">"dawang"</span> <span class="comment">// 设置默认名字</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// os.Args[0] 是程序名，后面才是自带的参数</span></span><br><span class="line">    name = strings.Join(os.Args[<span class="number">1</span>:], <span class="string">" "</span>) <span class="comment">// 把所有除程序名之外的内容用空格拼起来</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"Hello"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex4.go da wang</span><br><span class="line">Hello da wang</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>包 os, strings 的简单尝试</li>
<li>命令行参数的获取</li>
</ul>
<h2 id="u4E60_u9898_5__u8BFB_u5199_u6587_u4EF6_u3001_u6761_u4EF6_u5224_u65AD_u548C_u51FD_u6570"><a href="#u4E60_u9898_5__u8BFB_u5199_u6587_u4EF6_u3001_u6761_u4EF6_u5224_u65AD_u548C_u51FD_u6570" class="headerlink" title="习题 5 读写文件、条件判断和函数"></a>习题 5 读写文件、条件判断和函数</h2><p>这个例子会稍微复杂一点，我们会同时涉及读写文件、条件判断和函数（这样我们才能完成一些有趣的工作），不过因为 Go 本身的设计比较简洁，所以并不会像想象中那么复杂，我们做的工作就是把一个文件的内容复制到另一个文件中，具体见 <code>ex5.go</code>，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"bufio"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"io"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  infileName, outfileName, err := loadFromCmd()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果从命令行中读取参数错误，则打印错误信息并退出程序</span></span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认接收标准输入输出</span></span><br><span class="line">  infile, outfile := os.Stdin, os.Stdout</span><br><span class="line">  <span class="keyword">if</span> infileName != <span class="string">""</span> &#123;</span><br><span class="line">    <span class="comment">// 处理输入文件不存在的情况</span></span><br><span class="line">    <span class="keyword">if</span> infile, err = os.Open(infileName); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> infile.Close()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> outfileName != <span class="string">""</span> &#123;</span><br><span class="line">    <span class="comment">// 处理输出文件</span></span><br><span class="line">    <span class="keyword">if</span> outfile, err = os.Create(outfileName); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outfile.Close()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具体进行处理</span></span><br><span class="line">  <span class="keyword">if</span> err = process(infile, outfile); err != <span class="constant">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从命令行读取参数</span></span><br><span class="line"><span class="keyword">func</span> loadFromCmd() (infileName, outfileName <span class="typename">string</span>, err error) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; (os.Args[<span class="number">1</span>] == <span class="string">"-h"</span> || os.Args[<span class="number">1</span>] == <span class="string">"--help"</span>)&#123;</span><br><span class="line">    err = fmt.Errorf(<span class="string">"usage: %s [&lt;] infile.txt [&gt;] outfile.txt"</span>, filepath.Base(os.Args[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, <span class="string">""</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">    infileName = os.Args[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">2</span> &#123;</span><br><span class="line">      outfileName = os.Args[<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> infileName != <span class="string">""</span> &amp;&amp; infileName == outfileName &#123;</span><br><span class="line">    log.Fatal(<span class="string">"won't overwrite the infile"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> infileName, outfileName, <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理文件</span></span><br><span class="line"><span class="keyword">func</span> process(infile io.Reader, outfile io.Writer)(err error) &#123;</span><br><span class="line">  reader := bufio.NewReader(infile)</span><br><span class="line">  writer := bufio.NewWriter(outfile)</span><br><span class="line">  <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="constant">nil</span> &#123;</span><br><span class="line">      err = writer.Flush()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  eof := <span class="constant">false</span></span><br><span class="line">  <span class="keyword">for</span> !eof &#123;</span><br><span class="line">    <span class="keyword">var</span> line <span class="typename">string</span></span><br><span class="line">    line, err = reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">      err = <span class="constant">nil</span></span><br><span class="line">      eof = <span class="constant">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = writer.WriteString(line); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里引入了几个我们之前没有见过的包，简单介绍一下：</p>
<ul>
<li><code>bufio</code> 带缓冲的 io 处理</li>
<li><code>io</code> 底层 io 功能</li>
<li><code>log</code> 日志相关</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>defer 语句会在包含它的函数执行完成之后执行（延迟执行），通常可以用作收尾工作</li>
<li>利用函数分离长串代码，一个函数只做一个事情</li>
<li>利用返回值来做检查</li>
</ul>
<h2 id="u4E60_u9898_6__u679A_u4E3E_u7C7B_u578B"><a href="#u4E60_u9898_6__u679A_u4E3E_u7C7B_u578B" class="headerlink" title="习题 6 枚举类型"></a>习题 6 枚举类型</h2><p>与枚举类型配合有一个变量叫做 <code>iota</code>，每次调用的时候其值都会默认加一，下面是一个很有趣的例子，需要大家仔细感受一下，见 <code>ex6.go</code>，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BitFlag <span class="typename">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Active BitFlag = <span class="number">1</span> &lt;&lt; <span class="constant">iota</span> <span class="comment">// 1 &lt;&lt; 0 == 1</span></span><br><span class="line">  Send <span class="comment">// 隐式设置为 1 &lt;&lt; iota，所以 1 &lt;&lt; 1 == 2</span></span><br><span class="line">  Receive <span class="comment">// 隐式设置为 1 &lt;&lt; iota，所以 1 &lt;&lt; 2 == 4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (flag BitFlag) String() <span class="typename">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> flags []<span class="typename">string</span></span><br><span class="line">  <span class="keyword">if</span> flag &amp; Active == Active &#123;</span><br><span class="line">    flags = <span class="built_in">append</span>(flags, <span class="string">"Active"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> flag &amp; Send == Send &#123;</span><br><span class="line">    flags = <span class="built_in">append</span>(flags, <span class="string">"Send"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> flag &amp; Receive == Receive &#123;</span><br><span class="line">    flags = <span class="built_in">append</span>(flags, <span class="string">"Receive"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(flags) &gt; <span class="number">0</span> &#123; <span class="comment">// 这里，int(flag) 用于防止无限循环，至关重要</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d(%s)"</span>, <span class="typename">int</span>(flag), strings.Join(flags, <span class="string">"|"</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"0()"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> flag = Active | Send</span><br><span class="line">  fmt.Println(BitFlag(<span class="number">0</span>), Active, Send, flag, Receive, flag|Receive)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex6.go</span><br><span class="line"><span class="number">0</span>() <span class="number">1</span>(Active) <span class="number">2</span>(Send) <span class="number">3</span>(Active|Send) <span class="number">4</span>(Receive) <span class="number">7</span>(Active|Send|Receive)</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li><code>iota</code> 的用法</li>
<li>如何给指定类型重写 <code>String()</code> 方法来自定义输出</li>
</ul>
<h2 id="u4E60_u9898_7__u503C_u4E0E_u5F15_u7528"><a href="#u4E60_u9898_7__u503C_u4E0E_u5F15_u7528" class="headerlink" title="习题 7 值与引用"></a>习题 7 值与引用</h2><p>关于值和引用前面已经说过，这里需要注意的是数组在 Go 中是按值传递的，所以传递一个大数组的代价非常大，不过我们通常用切片来进行代替，传递切片的成本与字符串差不多。</p>
<p>这里我们分别用两种方式来传递参数，具体见 <code>ex7.go</code>，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  i := <span class="number">9</span></span><br><span class="line">  j := <span class="number">5</span></span><br><span class="line">  product := <span class="number">0</span></span><br><span class="line">  fmt.Println(<span class="string">"Origin Data:"</span>, i, j)</span><br><span class="line">  swapAndProduct1(&amp;i, &amp;j, &amp;product)</span><br><span class="line">  fmt.Println(<span class="string">"Swapped1:"</span>, i, j, product)</span><br><span class="line"></span><br><span class="line">  i = <span class="number">9</span></span><br><span class="line">  j = <span class="number">5</span></span><br><span class="line">  i, j, product = swapAndProduct2(i, j)</span><br><span class="line">  fmt.Println(<span class="string">"Swapped2:"</span>, i, j, product)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> swapAndProduct1(x, y, product *<span class="typename">int</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> *x &gt; *y &#123;</span><br><span class="line">    *x, *y = *y, *x</span><br><span class="line">  &#125;</span><br><span class="line">  *product = *x * *y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> swapAndProduct2(x, y <span class="typename">int</span>) (<span class="typename">int</span>, <span class="typename">int</span>, <span class="typename">int</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">    x, y = y, x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x, y, x * y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex7.go</span><br><span class="line">Origin Data: <span class="number">9</span> <span class="number">5</span></span><br><span class="line">Swapped1: <span class="number">5</span> <span class="number">9</span> <span class="number">45</span></span><br><span class="line">Swapped2: <span class="number">5</span> <span class="number">9</span> <span class="number">45</span></span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>两种交换方式看起来结果一样，不过第二种不是原地交换，这里需要注意一下</li>
<li>不过第二种不需要操心太多的 <code>*</code>，可读性更好</li>
</ul>
<h2 id="u4E60_u9898_8__u6570_u7EC4_u4E0E_u5207_u7247"><a href="#u4E60_u9898_8__u6570_u7EC4_u4E0E_u5207_u7247" class="headerlink" title="习题 8 数组与切片"></a>习题 8 数组与切片</h2><p>Go 语言的数组是一个定长的序列，其中的元素类型相同，数组的创建语法和切片有些类似，注意要区别一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组声明</span></span><br><span class="line">[length]Type</span><br><span class="line">[N]Type&#123;value1, value2, ..., valueN&#125;</span><br><span class="line">[...]Type&#123;value1, value2, ..., valueN&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片声明</span></span><br><span class="line"><span class="built_in">make</span>([]Type, length, capacity)</span><br><span class="line"><span class="built_in">make</span>([]Type, length)</span><br><span class="line">[]Type&#123;&#125;</span><br><span class="line">[]Type&#123;value1, value2, ..., valueN&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吗，唯一的区别其实在于 <code>[]</code> 中的内容，如果有，则是数组，如果没有，则是切片。具体的例子可见 <code>ex8.go</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  <span class="comment">// 声明数组</span></span><br><span class="line">  cities := [...]<span class="typename">string</span>&#123;<span class="string">"Shanghai"</span>, <span class="string">"Guangzhou"</span>, <span class="string">"Shenzhen"</span>, <span class="string">"Beijing"</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"%-8T %2d %q\n"</span>, cities, <span class="built_in">len</span>(cities), cities)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明切片</span></span><br><span class="line">  s := []<span class="typename">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>&#125;</span><br><span class="line">  t := s[:<span class="number">5</span>]</span><br><span class="line">  u := s[<span class="number">3</span>:<span class="built_in">len</span>(s)-<span class="number">1</span>]</span><br><span class="line">  fmt.Println(s, t, u)</span><br><span class="line">  u[<span class="number">1</span>] = <span class="string">"x"</span></span><br><span class="line">  fmt.Println(s, t, u)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历切片</span></span><br><span class="line">  <span class="keyword">for</span> i, letter := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Println(i, letter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex9.go</span><br><span class="line">[<span class="number">4</span>]string  <span class="number">4</span> [<span class="string">"Shanghai"</span> <span class="string">"Guangzhou"</span> <span class="string">"Shenzhen"</span> <span class="string">"Beijing"</span>]</span><br><span class="line">[A B C D E F G] [A B C D E] [D E F]</span><br><span class="line">[A B C D x F G] [A B C D x] [D x F]</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br><span class="line"><span class="number">3</span> D</span><br><span class="line"><span class="number">4</span> x</span><br><span class="line"><span class="number">5</span> F</span><br><span class="line"><span class="number">6</span> G</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>数组和切片的区别</li>
<li>数组和切片的基本使用</li>
</ul>
<h2 id="u4E60_u9898_9__u6620_u5C04"><a href="#u4E60_u9898_9__u6620_u5C04" class="headerlink" title="习题 9 映射"></a>习题 9 映射</h2><p>简单来说就是字典，用来保存键值对，先来说说基本用法</p>
<ul>
<li><code>m[k] = v</code> 基本的赋值，会覆盖</li>
<li><code>Delete(m, k)</code> 从 m 中删除 k，如果 k 不存在，啥都不发生</li>
<li><code>v := m[k]</code> 取值，如果 k 不存在，v 为 0</li>
<li><code>v, found := m[k]</code> 取值，如果存在，值保存在 v 中，found 为 true，反之，v 为 0 且 found 为 false</li>
<li><code>len(m)</code> 返回 m 中键值对的数量</li>
</ul>
<p>创建映射的语法为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建映射</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, initialCapacity)</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType)</span><br><span class="line"><span class="keyword">map</span>[KeyType]ValueType&#123;&#125;</span><br><span class="line"><span class="keyword">map</span>[KeyType]ValueType&#123;key1: value1, key2: value2, ..., keyN: valueN&#125;</span><br></pre></td></tr></table></figure>
<p>具体的例子可参见 <code>ex9.go</code>，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  massForPlanet := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">float64</span>)</span><br><span class="line">  massForPlanet[<span class="string">"Mercury"</span>] = <span class="number">0.06</span></span><br><span class="line">  massForPlanet[<span class="string">"Venus"</span>] = <span class="number">0.82</span></span><br><span class="line">  massForPlanet[<span class="string">"Earth"</span>] = <span class="number">1.00</span></span><br><span class="line">  massForPlanet[<span class="string">"Mars"</span>] = <span class="number">0.11</span></span><br><span class="line">  fmt.Println(massForPlanet)</span><br><span class="line">  massForPlanet[<span class="string">"Jupiter"</span>] = <span class="number">317.82</span></span><br><span class="line">  massForPlanet[<span class="string">"Saturn"</span>] = <span class="number">95.16</span></span><br><span class="line">  massForPlanet[<span class="string">"Uranus"</span>] = <span class="number">14.371</span></span><br><span class="line">  massForPlanet[<span class="string">"Neptune"</span>] = <span class="number">17.147</span></span><br><span class="line">  fmt.Println(massForPlanet)</span><br><span class="line">  big := <span class="string">"Jupiter"</span></span><br><span class="line">  fmt.Println(big, massForPlanet[big])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>映射的基本使用</li>
</ul>
<h2 id="u4E60_u9898_10_Switch__u8BED_u53E5"><a href="#u4E60_u9898_10_Switch__u8BED_u53E5" class="headerlink" title="习题 10 Switch 语句"></a>习题 10 Switch 语句</h2><p>Go 中有两种类型的 switch 语句，可以用表达式或者类型本身来进行分支跳转，另外 Go 的 switch 语句是不会自动向下执行的，如果需要的话，就得加上 <code>fallthrough</code> 关键词。Go 语言的表达式 switch 语句非常有用，很多时候可以代替 if 语句，还更加紧凑。</p>
<p>两种类型的示例可见 <code>ex10.go</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  <span class="comment">// 表达式 switch</span></span><br><span class="line">  <span class="keyword">var</span> suffix = <span class="string">".gz"</span></span><br><span class="line">  <span class="keyword">var</span> result <span class="typename">string</span></span><br><span class="line">  <span class="keyword">switch</span> suffix &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">".gz"</span>:</span><br><span class="line">    result = <span class="string">"This is a Gzip file"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">".tar"</span>, <span class="string">".tar.gz"</span>, <span class="string">".tgz"</span>:</span><br><span class="line">    result = <span class="string">"This is a Tar file"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">".zip"</span>:</span><br><span class="line">    result = <span class="string">"This is a Zip file"</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(result)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型 switch</span></span><br><span class="line">  classifier(<span class="number">5</span>, -<span class="number">17.9</span>, <span class="string">"LOL"</span>, <span class="constant">nil</span>, <span class="constant">true</span>, <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> classifier(items...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">    <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="typename">bool</span>:</span><br><span class="line">      fmt.Printf(<span class="string">"Param #%d is a bool\n"</span>, i)</span><br><span class="line">    <span class="keyword">case</span> <span class="typename">float64</span>:</span><br><span class="line">      fmt.Printf(<span class="string">"Param #%d is a float64\n"</span>, i)</span><br><span class="line">    <span class="keyword">case</span> <span class="typename">int</span>, <span class="typename">int8</span>, <span class="typename">int16</span>, <span class="typename">int32</span>, <span class="typename">int64</span>:</span><br><span class="line">      fmt.Printf(<span class="string">"Param #%d is a int\n"</span>, i)</span><br><span class="line">    <span class="keyword">case</span> <span class="typename">uint</span>, <span class="typename">uint8</span>, <span class="typename">uint16</span>, <span class="typename">uint32</span>, <span class="typename">uint64</span>:</span><br><span class="line">      fmt.Printf(<span class="string">"Param #%d is an unsigned int\n"</span>, i)</span><br><span class="line">    <span class="keyword">case</span> <span class="constant">nil</span>:</span><br><span class="line">      fmt.Printf(<span class="string">"Param #%d is nil\n"</span>, i)</span><br><span class="line">    <span class="keyword">case</span> <span class="typename">string</span>:</span><br><span class="line">      fmt.Printf(<span class="string">"Param #%d is a string\n"</span>, i)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Printf(<span class="string">"Param #%d is unknown type\n"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex10.go</span><br><span class="line">This is a Gzip file</span><br><span class="line">Param <span class="comment">#0 is a int</span></span><br><span class="line">Param <span class="comment">#1 is a float64</span></span><br><span class="line">Param <span class="comment">#2 is a string</span></span><br><span class="line">Param <span class="comment">#3 is nil</span></span><br><span class="line">Param <span class="comment">#4 is a bool</span></span><br><span class="line">Param <span class="comment">#5 is unknown type</span></span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>可变参数列表的声明</li>
<li><code>interface{}</code> 空接口的使用</li>
<li>两种类型的 switch 语句</li>
<li>for 循环语句</li>
</ul>
<h2 id="u4E60_u9898_11__u5E76_u53D1"><a href="#u4E60_u9898_11__u5E76_u53D1" class="headerlink" title="习题 11 并发"></a>习题 11 并发</h2><p>Go 语言中可以轻松创建 goroutine，可以利用 channel 进行类型安全的单向/双向通信或同步 goroutine，因为其机制是传递数据而非共享数据。这里我们用一个坐标系转换的例子来说明，具体可见 <code>ex11.go</code>，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"bufio"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> polar <span class="keyword">struct</span>&#123;</span><br><span class="line">  radius <span class="typename">float64</span></span><br><span class="line">  theta <span class="typename">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cartesian <span class="keyword">struct</span> &#123;</span><br><span class="line">  x <span class="typename">float64</span></span><br><span class="line">  y <span class="typename">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> prompt = <span class="string">"输入一个弧长 radius 和角度 theta，例如 12.5 90，或 %s 来退出"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> init() &#123;</span><br><span class="line">  <span class="keyword">if</span> runtime.GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line">    prompt = fmt.Sprintf(prompt, <span class="string">"Ctrl+Z, Enter"</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prompt = fmt.Sprintf(prompt, <span class="string">"Ctrl+D"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  questions := <span class="built_in">make</span>(<span class="keyword">chan</span> polar)</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(questions)</span><br><span class="line">  answers := createSolver(questions)</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(answers)</span><br><span class="line">  interact(questions, answers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> createSolver(questions <span class="keyword">chan</span> polar) <span class="keyword">chan</span> cartesian &#123;</span><br><span class="line">  answers := <span class="built_in">make</span>(<span class="keyword">chan</span> cartesian)</span><br><span class="line">  <span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      polarCoord := &lt;-questions</span><br><span class="line">      theta := polarCoord.theta * math.Pi / <span class="number">180.0</span></span><br><span class="line">      x := polarCoord.radius * math.Cos(theta)</span><br><span class="line">      y := polarCoord.radius * math.Sin(theta)</span><br><span class="line">      answers &lt;- cartesian&#123;x, y&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">return</span> answers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="string">"Polar radius=%.02f theta=%.02f degree -&gt; Cartesian x=%.02f y=%.02f\n"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> interact(questions <span class="keyword">chan</span> polar, answers <span class="keyword">chan</span> cartesian) &#123;</span><br><span class="line">  reader := bufio.NewReader(os.Stdin)</span><br><span class="line">  fmt.Println(prompt)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Radius and angle: "</span>)</span><br><span class="line">    line, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> radius, theta <span class="typename">float64</span></span><br><span class="line">    <span class="keyword">if</span> _, err := fmt.Sscanf(line, <span class="string">"%f %f"</span>, &amp;radius, &amp;theta); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      fmt.Println(os.Stderr, <span class="string">"invalid input"</span>)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    questions &lt;- polar&#123;radius, theta&#125;</span><br><span class="line">    coord := &lt;-answers</span><br><span class="line">    fmt.Printf(result, radius, theta, coord.x, coord.y)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的输出为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex11.go</span><br><span class="line">输入一个弧长 radius 和角度 theta，例如 <span class="number">12.5</span> <span class="number">90</span>，或 Ctrl+D 来退出</span><br><span class="line">Radius and angle: <span class="number">12.5</span> <span class="number">90</span></span><br><span class="line">Polar radius=<span class="number">12.50</span> theta=<span class="number">90.00</span> degree -&gt; Cartesian x=<span class="number">0.00</span> y=<span class="number">12.50</span></span><br><span class="line">Radius and angle: ^D</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>通过 struct 定义结构体</li>
<li><code>runtime</code> 包提供运行时控制，比方说确定程序运行的平台</li>
<li><code>func init()</code> 不能显式调用，会在执行 <code>main()</code> 之前自动执行</li>
<li>通道的行为跟先进先出队列一致，可以堵塞，能够以此来进行同步</li>
<li>goroutine 执行机制的简单理解</li>
</ul>
<h2 id="u4E60_u9898_12_Select__u8BED_u53E5"><a href="#u4E60_u9898_12_Select__u8BED_u53E5" class="headerlink" title="习题 12 Select 语句"></a>习题 12 Select 语句</h2><p>在一个 Select 语句中，Go 语言会按顺序从头至尾评估每一个发送和接收语句，如果有一条可以执行，那就执行，不然如果没有 default 语句，就阻塞，下面是一个简单的模拟骰子的例子，具体见 <code>ex12.go</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  channels := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="typename">bool</span>, <span class="number">6</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> channels &#123;</span><br><span class="line">    channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      channels[rand.Intn(<span class="number">6</span>)] &lt;- <span class="constant">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">36</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="typename">int</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">      x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">      x = <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">2</span>]:</span><br><span class="line">      x = <span class="number">3</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">3</span>]:</span><br><span class="line">      x = <span class="number">4</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">4</span>]:</span><br><span class="line">      x = <span class="number">5</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-channels[<span class="number">5</span>]:</span><br><span class="line">      x = <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%d "</span>, x)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex12.go</span><br><span class="line"><span class="number">6</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">3</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span> <span class="number">6</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>生成随机数的方法</li>
<li>select 语句的基本用法</li>
</ul>
<h2 id="u4E60_u9898_13__u9519_u8BEF_u4E0E_u5F02_u5E38"><a href="#u4E60_u9898_13__u9519_u8BEF_u4E0E_u5F02_u5E38" class="headerlink" title="习题 13 错误与异常"></a>习题 13 错误与异常</h2><p>通过内置的 <code>panic()</code> 和 <code>recover()</code> 函数，Go 提供了一套异常处理机制，虽然可以以此实现通用的异常处理机制，但并不推荐这样做。</p>
<p>Go 将错误和异常两者区分对待。错误是指可能出错的东西，程序需要以优雅的方式将其处理。而异常是指『不可能』发生的事情。</p>
<p>Go 语言中处理错误的惯用法是将错误以函数或者方法最后一个返回值的形式将其返回，并总是在调用它的地方检查返回的错误值。</p>
<p>本例来自 <a href="http://xhrwang.me/2014/12/30/golang-fundamentals-9-error-panic-recover.html" target="_blank" rel="external">Golang 语言基础之九： error, panic, recover</a>，见 <code>ex13.go</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单的例子</span></span><br><span class="line"><span class="keyword">func</span> SimplePanicRecover() &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Panic info is: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"SimplePanicRecover function panic-ed!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 defer 中也调用了 panic 函数时，最后被调用的 panic 函数的参数会被后面的 recover 函数获取到</span></span><br><span class="line"><span class="comment">// 一个函数中可以定义多个 defer 函数，按照 FILO 的规则执行</span></span><br><span class="line"><span class="keyword">func</span> MultiPanicRecover() &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Panic info is: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"MultiPanicRecover defer inner panic"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Panic info is: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"MultiPanicRecover function panic-ed!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数</span></span><br><span class="line"><span class="keyword">func</span> RecoverPlaceTest() &#123;</span><br><span class="line">  <span class="comment">// 下面一行代码中 recover 函数会返回 nil，但也不影响程序运行</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">recover</span>()</span><br><span class="line">  <span class="comment">// recover 函数返回 nil</span></span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">"recover() is: "</span>, <span class="built_in">recover</span>())</span><br><span class="line">  <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="keyword">func</span>() &#123;</span><br><span class="line">      <span class="comment">// 由于不是在 defer 调用函数中直接调用 recover 函数，recover 函数会返回 nil</span></span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Panic info is: "</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Panic info is: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"RecoverPlaceTest function panic-ed!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果函数没有 panic，调用 recover 函数不会获取到任何信息，也不会影响当前进程。</span></span><br><span class="line"><span class="keyword">func</span> NoPanicButHasRecover() &#123;</span><br><span class="line">  <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"NoPanicButHasRecover Panic info is: "</span>, err)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"NoPanicButHasRecover Panic info is: "</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个调用 recover 函数的函数</span></span><br><span class="line"><span class="keyword">func</span> CallRecover() &#123;</span><br><span class="line">  <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Panic info is: "</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义个函数，在其中 defer 另一个调用了 recover 函数的函数</span></span><br><span class="line"><span class="keyword">func</span> RecoverInOutterFunc() &#123;</span><br><span class="line">  <span class="keyword">defer</span> CallRecover()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"RecoverInOutterFunc function panic-ed!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  SimplePanicRecover()</span><br><span class="line">  MultiPanicRecover()</span><br><span class="line">  RecoverPlaceTest()</span><br><span class="line">  NoPanicButHasRecover()</span><br><span class="line">  RecoverInOutterFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex13.go</span><br><span class="line">Panic info is:  SimplePanicRecover <span class="keyword">function</span> panic-ed!</span><br><span class="line">Panic info is:  MultiPanicRecover <span class="keyword">function</span> panic-ed!</span><br><span class="line">Panic info is:  MultiPanicRecover defer inner panic</span><br><span class="line">Panic info is:  RecoverPlaceTest <span class="keyword">function</span> panic-ed!</span><br><span class="line">recover() is:  &lt;nil&gt;</span><br><span class="line">NoPanicButHasRecover Panic info is:  &lt;nil&gt;</span><br><span class="line">Panic info is:  RecoverInOutterFunc <span class="keyword">function</span> panic-ed!</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>panic 的机制</li>
<li>recover 的机制</li>
</ul>
<h2 id="u4E60_u9898_14_Interface"><a href="#u4E60_u9898_14_Interface" class="headerlink" title="习题 14 Interface"></a>习题 14 Interface</h2><p>关于接口的内容比较特别，因为 Go 中没有类的概念，而且是通过 interface 类型转换支持在动态类型语言中常见的 鸭子类型 达到运行时多态的效果。</p>
<p>更多详情请参考 <a href="http://xhrwang.me/2014/12/29/golang-fundamentals-8-interface.html" target="_blank" rel="external">Golang 语言基础之八： interface</a>，代码在 <code>ex14.go</code> 中（同样来自 <a href="http://xhrwang.me/2014/12/29/golang-fundamentals-8-interface.html" target="_blank" rel="external">Golang 语言基础之八： interface</a>），如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口类型 PeopleGetter 包含获取基本信息的方法</span></span><br><span class="line"><span class="keyword">type</span> PeopleGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">  GetName() <span class="typename">string</span></span><br><span class="line">  GetAge() <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口类型 EmployeeGetter 包含获取薪水的方法</span></span><br><span class="line"><span class="comment">// EmployeeGetter 接口中嵌入了 PeopleGetter 接口，前者将获取后者的所有方法</span></span><br><span class="line"><span class="keyword">type</span> EmployeeGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">  PeopleGetter</span><br><span class="line">  GetSalary() <span class="typename">int</span></span><br><span class="line">  Help()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构 Employee</span></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">  name   <span class="typename">string</span></span><br><span class="line">  age    <span class="typename">int</span></span><br><span class="line">  salary <span class="typename">int</span></span><br><span class="line">  gender <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构 Employee 的方法</span></span><br><span class="line"><span class="keyword">func</span> (self *Employee) GetName() <span class="typename">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (self *Employee) GetAge() <span class="typename">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (self *Employee) GetSalary() <span class="typename">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.salary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (self *Employee) Help() &#123;</span><br><span class="line">  fmt.Println(<span class="string">"This is help info."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名接口可以被用作变量或者结构属性类型</span></span><br><span class="line"><span class="keyword">type</span> Man <span class="keyword">struct</span> &#123;</span><br><span class="line">  gender <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetGender() <span class="typename">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (self *Employee) GetGender() <span class="typename">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.gender</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义执行回调函数的接口</span></span><br><span class="line"><span class="keyword">type</span> Callbacker <span class="keyword">interface</span> &#123;</span><br><span class="line">  Execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数类型 func() 的新类型 CallbackFunc</span></span><br><span class="line"><span class="keyword">type</span> CallbackFunc <span class="keyword">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 CallbackFunc 的 Execute() 方法</span></span><br><span class="line"><span class="keyword">func</span> (self CallbackFunc) Execute() &#123; self() &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  <span class="comment">// 空接口的使用，空接口类型的变量可以保存任何类型的值</span></span><br><span class="line">  <span class="comment">// 空格口类型的变量非常类似于弱类型语言中的变量</span></span><br><span class="line">  <span class="keyword">var</span> varEmptyInterface <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"varEmptyInterface is of type %T\n"</span>, varEmptyInterface)</span><br><span class="line">  varEmptyInterface = <span class="number">100</span></span><br><span class="line">  fmt.Printf(<span class="string">"varEmptyInterface is of type %T\n"</span>, varEmptyInterface)</span><br><span class="line">  varEmptyInterface = <span class="string">"Golang"</span></span><br><span class="line">  fmt.Printf(<span class="string">"varEmptyInterface is of type %T\n"</span>, varEmptyInterface)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Employee 实现了 PeopleGetter 和 EmployeeGetter 两个接口</span></span><br><span class="line">  varEmployee := Employee&#123;</span><br><span class="line">    name:   <span class="string">"Jack Ma"</span>,</span><br><span class="line">    age:    <span class="number">50</span>,</span><br><span class="line">    salary: <span class="number">100000000</span>,</span><br><span class="line">    gender: <span class="string">"Male"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"varEmployee is: "</span>, varEmployee)</span><br><span class="line">  varEmployee.Help()</span><br><span class="line">  fmt.Println(<span class="string">"varEmployee.name = "</span>, varEmployee.GetName())</span><br><span class="line">  fmt.Println(<span class="string">"varEmployee.age = "</span>, varEmployee.GetAge())</span><br><span class="line">  fmt.Println(<span class="string">"varEmployee.salary = "</span>, varEmployee.GetSalary())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 匿名接口对象的使用</span></span><br><span class="line">  varMan := Man&#123;&amp;Employee&#123;</span><br><span class="line">    name:   <span class="string">"Nobody"</span>,</span><br><span class="line">    age:    <span class="number">20</span>,</span><br><span class="line">    salary: <span class="number">10000</span>,</span><br><span class="line">    gender: <span class="string">"Unknown"</span>,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  fmt.Println(<span class="string">"The gender of Nobody is: "</span>, varMan.gender.GetGender())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接口类型转换，从超集到子集的转换是可以的</span></span><br><span class="line">  <span class="comment">// 从方法集的子集到超集的转换会导致编译错误</span></span><br><span class="line">  <span class="comment">// 这种情况下 switch 不支持 fallthrough</span></span><br><span class="line">  <span class="keyword">var</span> varEmpInter EmployeeGetter = &amp;varEmployee</span><br><span class="line">  <span class="keyword">switch</span> varEmpInter.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="constant">nil</span>:</span><br><span class="line">    fmt.Println(<span class="string">"nil"</span>)</span><br><span class="line">  <span class="keyword">case</span> PeopleGetter:</span><br><span class="line">    fmt.Println(<span class="string">"PeopleGetter"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"Unknown"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 “执行回调函数的接口对象” 执行回调函数</span></span><br><span class="line">  <span class="comment">// 这种做法的优势是函数显式地 “实现” 特定接口</span></span><br><span class="line">  varCallbacker := CallbackFunc(<span class="keyword">func</span>() &#123; <span class="built_in">println</span>(<span class="string">"I am a callback function."</span>) &#125;)</span><br><span class="line">  varCallbacker.Execute()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex14.go</span><br><span class="line">varEmptyInterface is of <span class="built_in">type</span> &lt;nil&gt;</span><br><span class="line">varEmptyInterface is of <span class="built_in">type</span> int</span><br><span class="line">varEmptyInterface is of <span class="built_in">type</span> string</span><br><span class="line">varEmployee is:  &#123;Jack Ma <span class="number">50</span> <span class="number">100000000</span> Male&#125;</span><br><span class="line">This is <span class="built_in">help</span> info.</span><br><span class="line">varEmployee.name =  Jack Ma</span><br><span class="line">varEmployee.age =  <span class="number">50</span></span><br><span class="line">varEmployee.salary =  <span class="number">100000000</span></span><br><span class="line">The gender of Nobody is:  Unknown</span><br><span class="line">PeopleGetter</span><br><span class="line">I am a callback function.</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>interface 的定义和使用</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>本文通过 14 个简单的例子来说明了 Go 的基本用法，如果能大致理解，就可以开始具体的探险了，让我们边学边练，搞一个练手项目吧。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/wdxtub/learn-go-the-hard-way" target="_blank" rel="external">配套代码</a></li>
<li><a href="http://xhrwang.me/2014/12/30/golang-fundamentals-9-error-panic-recover.html" target="_blank" rel="external">Golang 语言基础之九： error, panic, recover</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在学习新语言这个事情上，笨办法往往是最高效的办法。效仿『笨办法学 Python』和『笨办法学 Ruby』，我来写一篇『笨办法学 Go』吧！</p>]]>
    
    </summary>
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="笨鸟" scheme="http://wdxtub.com/tags/%E7%AC%A8%E9%B8%9F/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka 指南]]></title>
    <link href="http://wdxtub.com/2016/08/15/kafka-guide/"/>
    <id>http://wdxtub.com/2016/08/15/kafka-guide/</id>
    <published>2016-08-15T11:38:04.000Z</published>
    <updated>2016-08-17T13:03:52.000Z</updated>
    <content type="html"><![CDATA[<p>提到消息系统，目前最火热的非 Kafka 莫属，公司也打算利用 Kafka 进行各业务日志统一收集，这里结合自己的实践来分享一下具体的配置及使用。Kafka 版本 0.10.0.1</p>
<a id="more"></a>
<hr>
<h2 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h2><p>作为云计算大数据的套件，Kafka 是一个分布式的、可分区的、可复制的消息系统。该有的功能基本都有，而且有自己的特色：</p>
<ul>
<li>以 topic 为单位进行消息归纳</li>
<li>向 topic 发布消息的是 producer</li>
<li>从 topic 获取消息的是 consumer</li>
<li>集群方式运行，每个服务叫 broker</li>
<li>客户端和服务器通过 TCP 进行通信</li>
</ul>
<p>在Kafka集群中，没有“中心主节点”的概念，集群中所有的服务器都是对等的，因此，可以在不做任何配置的更改的情况下实现服务器的的添加与删除，同样的消息的生产者和消费者也能够做到随意重启和机器的上下线。</p>
<p>对每个 topic 来说，Kafka 会对其进行分区，每个分区都由一系列有序的、不可变的消息组成，这些消息被连续的追加到分区中。分区中的每个消息都有一个连续的序列号叫做 offset,用来在分区中唯一的标识这个消息。</p>
<p>发布消息通常有两种模式：队列模式(queuing)和发布-订阅模式(publish-subscribe)。队列模式中，consumers 可以同时从服务端读取消息，每个消息只被其中一个 consumer 读到；发布-订阅模式中消息被广播到所有的 consumer 中。更常见的是，每个 topic 都有若干数量的 consumer 组，每个组都是一个逻辑上的『订阅者』，为了容错和更好的稳定性，每个组由若干 consumer 组成。这其实就是一个发布-订阅模式，只不过订阅者是个组而不是单个 consumer。</p>
<p>通过分区的概念，Kafka可以在多个consumer组并发的情况下提供较好的有序性和负载均衡。将每个分区分只分发给一个consumer组，这样一个分区就只被这个组的一个consumer消费，就可以顺序的消费这个分区的消息。因为有多个分区，依然可以在多个consumer组之间进行负载均衡。注意consumer组的数量不能多于分区的数量，也就是有多少分区就允许多少并发消费。</p>
<p>Kafka 只能保证一个分区之内消息的有序性，在不同的分区之间是不可以的，这已经可以满足大部分应用的需求。如果需要 topic 中所有消息的有序性，那就只能让这个 topic 只有一个分区，当然也就只有一个 consumer 组消费它。</p>
<h2 id="u5355_u673A_u914D_u7F6E"><a href="#u5355_u673A_u914D_u7F6E" class="headerlink" title="单机配置"></a>单机配置</h2><p>按照下列步骤即可（来自官网教程）</p>
<p><strong>1. 下载 Kafka</strong></p>
<ul>
<li>下载 <code>wget http://apache.01link.hk/kafka/0.10.0.0/kafka_2.11-0.10.0.0.tgz</code> 或者 <code>wget http://ftp.cuhk.edu.hk/pub/packages/apache.org/kafka/0.10.0.0/kafka_2.11-0.10.0.0.tgz</code>（看哪个源比较快）</li>
<li>解压 <code>tar -xzf kafka_2.11-0.10.0.0.tgz</code> </li>
<li>进入文件夹 <code>cd kafka_2.11-0.10.0.0/</code></li>
</ul>
<p><strong>2. 启动服务</strong></p>
<ul>
<li>启动 ZooKeeper <code>bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code>（利用 <code>&amp;</code>放到后台方便继续操作）</li>
<li>启动 Kafka <code>bin/kafka-server-start.sh config/server.properties &amp;</code></li>
</ul>
<p><strong>3. 创建一个叫做 dawang 的 topic，它只有一个分区，一个副本</strong></p>
<ul>
<li>创建 <code>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic dawang</code></li>
<li>查看 <code>bin/kafka-topics.sh --list --zookeeper localhost:2181</code></li>
<li>还可以配置 broker 让它自动创建 topic</li>
</ul>
<p><strong>4. 发送消息。Kafka 使用一个简单的命令行producer，从文件中或者从标准输入中读取消息并发送到服务端。默认的每条命令将发送一条消息。</strong></p>
<ul>
<li>发送消息 <code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic dawang</code>（然后可以随意输入内容，回车可以发送，ctrl+c 退出）</li>
</ul>
<p><strong>5. 启动 consumer。可以读取消息并输出到标准输出：</strong></p>
<ul>
<li>接收消息 <code>bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic dawang --from-beginning</code></li>
<li>在一个终端中运行 consumer 命令行，另一个终端中运行 producer 命令行，就可以在一个终端输入消息，另一个终端读取消息。这两个命令都有自己的可选参数，可以在运行的时候不加任何参数可以看到帮助信息。</li>
</ul>
<p><strong>6. 搭建一个多个 broker 的集群，启动有 3 个 broker 组成的集群，这些 broker 节点也都在本机</strong></p>
<p>首先复制一下配置文件：<code>cp config/server.properties config/server-1.properties</code> 和 <code>cp config/server.properties config/server-2.properties</code></p>
<p>两个文件需要改动的内容为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">config/server-<span class="number">1.</span>properties:</span><br><span class="line">    broker.id=<span class="number">1</span></span><br><span class="line">    listeners=PLAINTEXT:<span class="comment">//:9093</span></span><br><span class="line">    <span class="built_in">log</span>.dir=/tmp/kafka-logs-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">config/server-<span class="number">2.</span>properties:</span><br><span class="line">    broker.id=<span class="number">2</span></span><br><span class="line">    listeners=PLAINTEXT:<span class="comment">//:9094</span></span><br><span class="line">    <span class="built_in">log</span>.dir=/tmp/kafka-logs-<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里我们把 broker id, 端口号和日志地址配置成和之前不一样，然后我们启动这两个 broker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server-<span class="number">1</span>.properties &amp;</span><br><span class="line">bin/kafka-server-start.sh config/server-<span class="number">2</span>.properties &amp;</span><br></pre></td></tr></table></figure>
<p>然后创建一个复制因子为 3 的 topic</p>
<p><code>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic oh3topic</code></p>
<p>可以使用 <code>describe</code> 命令来显示 topic 详情</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper localhost:<span class="number">2181</span> --topic oh3topic</span><br><span class="line">Topic:oh3topic	PartitionCount:<span class="number">1</span>	ReplicationFactor:<span class="number">3</span>	Configs:</span><br><span class="line">	Topic: oh3topic	Partition: <span class="number">0</span>	Leader: <span class="number">0</span>	Replicas: <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>	Isr: <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里简单解释一下</p>
<ul>
<li>Leader 是给定分区的节点编号，每个分区的部分数据会随机指定不同的节点</li>
<li>Replicas 是该日志会保存的复制</li>
<li>Isr 表示正在同步的复制</li>
</ul>
<p>我们也可以来看看之前的另一个 topic 的情况</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper <span class="string">localhost:</span><span class="number">2181</span> --topic dawang</span><br><span class="line"><span class="string">Topic:</span>dawang	<span class="string">PartitionCount:</span><span class="number">1</span>	<span class="string">ReplicationFactor:</span><span class="number">1</span>	<span class="string">Configs:</span></span><br><span class="line"><span class="label">	Topic:</span> dawang	<span class="string">Partition:</span> <span class="number">0</span>	<span class="string">Leader:</span> <span class="number">0</span>	<span class="string">Replicas:</span> <span class="number">0</span>	<span class="string">Isr:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>最后我们可以按照同样的方法来生产和消费消息，例如</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">生产</span></span><br><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">console</span><span class="literal">-</span><span class="comment">producer</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">broker</span><span class="literal">-</span><span class="comment">list</span> <span class="comment">localhost:9092</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">oh3topic</span></span><br><span class="line"><span class="comment">#</span> <span class="comment">消费</span></span><br><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">console</span><span class="literal">-</span><span class="comment">consumer</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">from</span><span class="literal">-</span><span class="comment">beginning</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">oh3topic</span></span><br></pre></td></tr></table></figure>
<p>开俩终端就可以一边生产消息，一边消费消息了。</p>
<h2 id="u96C6_u7FA4_u914D_u7F6E"><a href="#u96C6_u7FA4_u914D_u7F6E" class="headerlink" title="集群配置"></a>集群配置</h2><p>kafka 使用 ZooKeeper 用于管理、协调代理。每个 Kafka 代理通过 Zookeeper 协调其他 Kafka 代理。当 Kafka 系统中新增了代理或某个代理失效时，Zookeeper 服务将通知生产者和消费者。生产者与消费者据此开始与其他代理协调工作。</p>
<h3 id="u5B89_u88C5_Java"><a href="#u5B89_u88C5_Java" class="headerlink" title="安装 Java"></a>安装 Java</h3><p>先给两台机子安装 Java</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install oracle-java8-installer</span><br></pre></td></tr></table></figure>
<h3 id="u66F4_u65B0_Hosts"><a href="#u66F4_u65B0_Hosts" class="headerlink" title="更新 Hosts"></a>更新 Hosts</h3><p>这里用两台机器做例子（理论上最好是 3 台起步，偶数个不是不可以的，但是zookeeper集群是以宕机个数过半才会让整个集群宕机的，所以奇数个集群更佳），分别配置 <code>/etc/hosts</code> 文件为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost</span><br><span class="line"><span class="number">10.1</span><span class="number">.1</span><span class="number">.164</span> bi03</span><br><span class="line"><span class="number">10.1</span><span class="number">.1</span><span class="number">.44</span> bi02</span><br></pre></td></tr></table></figure>
<h3 id="u4FEE_u6539_Zookeeper__u914D_u7F6E_u6587_u4EF6"><a href="#u4FEE_u6539_Zookeeper__u914D_u7F6E_u6587_u4EF6" class="headerlink" title="修改 Zookeeper 配置文件"></a>修改 Zookeeper 配置文件</h3><p>修改 <code>config/zookeeper.properties</code> 为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dataDir=/data/home/logger/kafka_2<span class="number">.11</span>-<span class="number">0.10</span><span class="number">.0</span><span class="number">.0</span>/zookeeper-logs/</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"><span class="preprocessor"># maxClientCnxns=<span class="number">0</span></span></span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">5</span></span><br><span class="line">syncLimit=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">server<span class="number">.1</span>=bi03:<span class="number">13645</span>:<span class="number">13646</span></span><br><span class="line">server<span class="number">.2</span>=bi02:<span class="number">13645</span>:<span class="number">13646</span></span><br></pre></td></tr></table></figure>
<p>参数的意义为：</p>
<ul>
<li>initLimit: zookeeper集群中的包含多台 server，其中一台为 leader，集群中其余的 server 为 follower。initLimit 参数配置初始化连接时，follower 和 leader 之间的最长心跳时间。此时该参数设置为 5，说明时间限制为 5 倍 tickTime，即 <code>5*2000=10000ms=10s</code></li>
<li>syncLimit: 该参数配置 leader 和 follower 之间发送消息，请求和应答的最大时间长度。此时该参数设置为 2，说明时间限制为 2 倍 tickTime，即 4000ms</li>
<li>server.X=A:B:C 其中 X 是一个数字, 表示这是第几号 server。A 是该 server 所在的 IP 地址。B 配置该 server 和集群中的 leader 交换消息所使用的端口。C 配置选举 leader 时所使用的端口。</li>
</ul>
<h3 id="u7ED9_u670D_u52A1_u5668_u7F16_u53F7"><a href="#u7ED9_u670D_u52A1_u5668_u7F16_u53F7" class="headerlink" title="给服务器编号"></a>给服务器编号</h3><p>在 dataDir 目录下建立一个 myid 文件，分别为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># server<span class="number">.1</span></span></span><br><span class="line">echo <span class="number">1</span> &gt; myid</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># server<span class="number">.2</span></span></span><br><span class="line">echo <span class="number">2</span> &gt; myid</span><br></pre></td></tr></table></figure>
<h3 id="u542F_u52A8_Zookeeper"><a href="#u542F_u52A8_Zookeeper" class="headerlink" title="启动 Zookeeper"></a>启动 Zookeeper</h3><p>然后在每台机子上启动 zookeeper 服务 </p>
<p><code>bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></p>
<p>所有机子的 zookeeper 都启动之前会报错，这都是正常的</p>
<p>如果不想要任何输出</p>
<p><code>nohup bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></p>
<h3 id="u4FEE_u6539_Kafka__u914D_u7F6E_u6587_u4EF6"><a href="#u4FEE_u6539_Kafka__u914D_u7F6E_u6587_u4EF6" class="headerlink" title="修改 Kafka 配置文件"></a>修改 Kafka 配置文件</h3><p>修改 <code>config/server.properties</code>，几个要改的部分是 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># 允许删除 topic</span></span><br><span class="line"><span class="keyword">delete</span>.topic.enable=<span class="literal">true</span></span><br><span class="line">broker.id=<span class="number">0</span> <span class="preprocessor"># 这里不能重复</span></span><br><span class="line">listeners=PLAINTEXT:<span class="comment">//bi03:13647 # 这里要配置成本机的 host name</span></span><br><span class="line"><span class="preprocessor"># 这里需要配置成外网能够访问的地址及端口</span></span><br><span class="line">advertised.listeners=PLAINTEXT:<span class="comment">//external.ip:8080</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.dirs=/data/home/logger/kafka_2<span class="number">.11</span>-<span class="number">0.10</span><span class="number">.0</span><span class="number">.0</span>/kafka-logs</span><br><span class="line">num.partitions=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">zookeeper.connect=bi03:<span class="number">2181</span>,bi02:<span class="number">2181</span></span><br></pre></td></tr></table></figure>
<h3 id="u542F_u52A8_Kafka"><a href="#u542F_u52A8_Kafka" class="headerlink" title="启动 Kafka"></a>启动 Kafka</h3><p>在每个节点上执行</p>
<p><code>bin/kafka-server-start.sh config/server.properties &amp;</code></p>
<p>如果不想要任何输出</p>
<p><code>nohup bin/kafka-server-start.sh config/server.properties &amp;</code></p>
<h3 id="u9A8C_u8BC1_u5B89_u88C5"><a href="#u9A8C_u8BC1_u5B89_u88C5" class="headerlink" title="验证安装"></a>验证安装</h3><p>创建一个 topic</p>
<p><code>bin/kafka-topics.sh --create --zookeeper bi03:2181,bi02:2181 --replication-factor 2 --partitions 1 --topic test</code></p>
<p>查看集群状态</p>
<p><code>bin/kafka-topics.sh --describe --zookeeper bi03:2181,bi02:2181 --topic test</code></p>
<p>生产消息，这里注意要生产到前面设置的监听端口，而不是 zookeeper 的端口</p>
<p><code>bin/kafka-console-producer.sh --broker-list bi03:13647,bi02:13647 --topic test</code></p>
<p>消费消息，这里注意是 zookeeper 的端口，而不是 kafka 的端口</p>
<p><code>bin/kafka-console-consumer.sh --zookeeper bi03:2181,bi02:2181 --from-beginning --topic test</code></p>
<p>显示 topic 列表</p>
<p><code>bin/kafka-topics.sh --zookeeper bi03:2181,bi02:2181 --list</code></p>
<p>删除 topic</p>
<p><code>bin/kafka-topics.sh --zookeeper bi03:2181,bi02:2181 --delete --topic hello</code></p>
<h3 id="u5176_u4ED6_u914D_u7F6E"><a href="#u5176_u4ED6_u914D_u7F6E" class="headerlink" title="其他配置"></a>其他配置</h3><p>Kafka 使用键值对的属性文件格式来进行配置，比如 <code>config/server.properties</code>，具体的值可以从文件中读取，或者在代码中进行指定。最重要的三个属性是：</p>
<ul>
<li><code>broker.id</code>: broker 的编号，不能相同</li>
<li><code>log.dirs</code>: 日志保存的文件夹，默认为 <code>/tmp/kafka-logs</code></li>
<li><code>zookeeper.connect</code>: zookeeper 的 host</li>
</ul>
<p>其他一些我觉得比较有用的属性为</p>
<ul>
<li><code>auto.create.topics.enable</code> 是否允许自动创建 topic，boolean 值，默认为 <code>true</code></li>
<li><code>auto.leader.rebalance.enable</code> 是否允许 leader 进行自动平衡，boolean 值，默认为 <code>true</code></li>
<li><code>background.threads</code> 后台进程数目，int 值，默认为 10 个</li>
<li><code>compression.type</code> 指定 topic 的压缩方式，string 值，可选有<ul>
<li><code>gzip</code>, <code>snappy</code>, <code>lz4</code> 压缩方法</li>
<li><code>uncompressed</code> 不压缩</li>
<li><code>producer</code> 跟随 producer 的压缩方式</li>
</ul>
</li>
<li><code>delete.topic.enable</code> 是否允许删除 topic，boolean 值，默认为 false（主要用于控制 admin 界面中的控制）</li>
<li><code>leader.imbalance.check.interval.seconds</code> 检查是否平衡的时间间隔，long 值，默认为 300</li>
<li><code>leader.imbalance.per.broker.percentage</code> 允许的不平衡的百分比，超出则会进行重平衡，int 值，默认为 10</li>
<li><code>log.flush.interval.messages</code> 攒了多少条消息之后会把数据刷入磁盘，long 值，默认是 9223372036854775807</li>
<li><code>log.flush.interval.ms</code> 每条消息在保存到磁盘中前会在内存中待多久，单位毫秒，long 值，如果不设定，默认使用 <code>log.flush.scheduler.interval.ms</code>，也就是 9223372036854775807</li>
</ul>
<p>更多的配置可以参考<a href="http://kafka.apache.org/documentation.html#brokerconfigs" target="_blank" rel="external">这里</a>，以上的配置均针对 broker，因为目前我只用 broker 的部分</p>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><p>所有的工具都可以在 <code>bin/</code> 文件夹下查看，如果不带任何参数，就会给出所有命令的列表说明，这里只简要说明一些常用的命令</p>
<h3 id="u521B_u5EFA_u548C_u79FB_u9664_topic"><a href="#u521B_u5EFA_u548C_u79FB_u9664_topic" class="headerlink" title="创建和移除 topic"></a>创建和移除 topic</h3><p>可以手动创建 topic，或在数据进来时自动创建不存在的 topic，如果是自动创建的话，可能需要根据<a href="http://kafka.apache.org/documentation.html#topic-config" target="_blank" rel="external">这里</a>来进行对应调整。</p>
<p><strong>创建 topic</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --create --topic my_topic_name --partitions 20 --replication-factor 3 --config x=y</code></p>
<p>replication-factor 控制复制的份数，建议 2-3 份来兼顾容错和效率。partitions 控制该 topic 将被分区的数目，partitions 的数目最好不要超过服务器的个数（因为分区的意义是增加并行效率，而服务器数量决定了并行的数量，假设只有 2 台服务器，分 4 个区和 2 个区其实差别不大）。另外，topic 的名称不能超过 249 个字符</p>
<p><strong>修改 topic</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --alter --topic my_topic_name --partitions 40</code></p>
<p>这里需要注意，即使修改了分区的个数，已有的数据也不会进行变动，Kafka 不会做任何自动重分布</p>
<p><strong>增加配置</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --alter --topic my_topic_name --config x=y</code></p>
<p><strong>移除配置</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --alter --topic my_topic_name --delete-config x</code></p>
<p><strong>删除 topic</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --delete --topic my_topic_name</code></p>
<p>这个需要 <code>delete.topic.enable=true</code>，目前 Kafka 不支持减少 topic 的分区数目</p>
<h3 id="u4F18_u96C5_u5173_u95ED"><a href="#u4F18_u96C5_u5173_u95ED" class="headerlink" title="优雅关闭"></a>优雅关闭</h3><p>Kafka 会自动检测 broker 的状态并根据机器状态选举出新的 leader。但是如果需要进行配置更改停机的时候，我们就需要使用优雅关闭了，好处在于：</p>
<ol>
<li>会把所有的日志同步到磁盘上，避免重启之后的日志恢复，减少重启时间</li>
<li>会在关闭前把以这台机为 leader 的分区数据迁移到其他节点，会减少不可用的时间</li>
</ol>
<p>但是这个需要开启 <code>controlled.shutdown.enable=true</code>。</p>
<p>刚重启之后的节点不是任何分区的 leader，所以这时候需要进行重新分配：</p>
<p><code>bin/kafka-preferred-replica-election.sh --zookeeper zk_host:port/chroot</code></p>
<p>这里需要开启 <code>auto.leader.rebalance.enable=true</code></p>
<p>然后可以使用脚本 <code>bin/kafka-server-stop.sh</code></p>
<p>注意，如果配置文件中没有 <code>auto.leader.rebalance.enable=true</code>，就还需要重新平衡</p>
<h2 id="u6DF1_u5165_u7406_u89E3"><a href="#u6DF1_u5165_u7406_u89E3" class="headerlink" title="深入理解"></a>深入理解</h2><p>这里只是一部分摘录，更多内容可查阅参考链接（尤其是美团技术博客的那篇）</p>
<h3 id="u6587_u4EF6_u7CFB_u7EDF"><a href="#u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="文件系统"></a>文件系统</h3><p>Kafka 大量依赖文件系统去存储和缓存消息。而文件系统最终会放在硬盘上，不过不用担心，很多时候硬盘的快慢完全取决于使用它的方式。设计良好的硬盘架构可以和内存一样快。</p>
<p>所以与传统的将数据缓存在内存中然后刷到硬盘的设计不同，Kafka直接将数据写到了文件系统的日志中，因此也避开了 JVM 的劣势——Java 对象占用空间巨大，数据量增大后垃圾回收有困难。使用文件系统，即使系统重启了，也不需要刷新数据，也简化了维护数据一致性的逻辑。</p>
<p>对于主要用于日志处理的消息系统，数据的持久化可以简单的通过将数据追加到文件中实现，读的时候从文件中读就好了。这样做的好处是读和写都是 O(1) 的，并且读操作不会阻塞写操作和其他操作。这样带来的性能优势是很明显的，因为性能和数据的大小没有关系了。</p>
<p>既然可以使用几乎没有容量限制（相对于内存来说）的硬盘空间建立消息系统，就可以在没有性能损失的情况下提供一些一般消息系统不具备的特性。比如，一般的消息系统都是在消息被消费后立即删除，Kafka却可以将消息保存一段时间（比如一星期），这给consumer提供了很好的机动性和灵活性。</p>
<h3 id="u4E8B_u52A1_u5B9A_u4E49"><a href="#u4E8B_u52A1_u5B9A_u4E49" class="headerlink" title="事务定义"></a>事务定义</h3><p>数据传输的事务定义通常有以下三种级别：</p>
<ul>
<li>最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输。</li>
<li>最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.</li>
<li>精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的。</li>
</ul>
<p>Kafka 的机制和 git 有点类似，有一个 commit 的概念，一旦提交且 broker 在工作，那么数据就不会丢失。如果 producer 发布消息时发生了网络错误，但又不确定实在提交之前发生的还是提交之后发生的，这种情况虽然不常见，但是必须考虑进去，现在Kafka版本还没有解决这个问题，将来的版本正在努力尝试解决。</p>
<p>并不是所有的情况都需要“精确的一次”这样高的级别，Kafka 允许 producer 灵活的指定级别。比如 producer 可以指定必须等待消息被提交的通知，或者完全的异步发送消息而不等待任何通知，或者仅仅等待 leader 声明它拿到了消息（followers没有必要）。</p>
<p>现在从 consumer 的方面考虑这个问题，所有的副本都有相同的日志文件和相同的offset，consumer 维护自己消费的消息的 offset。如果 consumer 崩溃了，会有另外一个 consumer 接着消费消息，它需要从一个合适的 offset 继续处理。这种情况下可以有以下选择：</p>
<ul>
<li>consumer 可以先读取消息，然后将 offset 写入日志文件中，然后再处理消息。这存在一种可能就是在存储 offset 后还没处理消息就 crash 了，新的 consumer 继续从这个 offset 处理，那么就会有些消息永远不会被处理，这就是上面说的『最多一次』</li>
<li>consumer 可以先读取消息，处理消息，最后记录o ffset，当然如果在记录 offset 之前就 crash 了，新的 consumer 会重复的消费一些消息，这就是上面说的『最少一次』</li>
<li>『精确一次』可以通过将提交分为两个阶段来解决：保存了 offset 后提交一次，消息处理成功之后再提交一次。但是还有个更简单的做法：将消息的 offset 和消息被处理后的结果保存在一起。比如用 Hadoop ETL 处理消息时，将处理后的结果和 offset 同时保存在 HDFS 中，这样就能保证消息和 offser 同时被处理了</li>
</ul>
<h3 id="u6027_u80FD_u4F18_u5316"><a href="#u6027_u80FD_u4F18_u5316" class="headerlink" title="性能优化"></a>性能优化</h3><p>Kafka 在提高效率方面做了很大努力。Kafka 的一个主要使用场景是处理网站活动日志，吞吐量是非常大的，每个页面都会产生好多次写操作。读方面，假设每个消息只被消费一次，读的量的也是很大的，Kafka 也尽量使读的操作更轻量化。</p>
<p>线性读写的情况下影响磁盘性能问题大约有两个方面：太多的琐碎的 I/O 操作和太多的字节拷贝。I/O 问题发生在客户端和服务端之间，也发生在服务端内部的持久化的操作中。</p>
<p><strong>消息集(message set)</strong></p>
<p>为了避免这些问题，Kafka 建立了<strong>消息集(message set)</strong>的概念，将消息组织到一起，作为处理的单位。以消息集为单位处理消息，比以单个的消息为单位处理，会提升不少性能。Producer 把消息集一块发送给服务端，而不是一条条的发送；服务端把消息集一次性的追加到日志文件中，这样减少了琐碎的 I/O 操作。consumer 也可以一次性的请求一个消息集。</p>
<p>另外一个性能优化是在字节拷贝方面。在低负载的情况下这不是问题，但是在高负载的情况下它的影响还是很大的。为了避免这个问题，Kafka 使用了标准的二进制消息格式，这个格式可以在 producer, broker 和 producer 之间共享而无需做任何改动。</p>
<p><strong>zero copy</strong></p>
<p>Broker 维护的消息日志仅仅是一些目录文件，消息集以固定队的格式写入到日志文件中，这个格式 producer 和 consumer 是共享的，这使得 Kafka 可以一个很重要的点进行优化：消息在网络上的传递。现代的 unix 操作系统提供了高性能的将数据从页面缓存发送到 socket 的系统函数，在 linux 中，这个函数是 <code>sendfile</code></p>
<p>为了更好的理解 <code>sendfile</code> 的好处，我们先来看下一般将数据从文件发送到 socket 的数据流向：</p>
<ul>
<li>操作系统把数据从文件拷贝内核中的页缓存中</li>
<li>应用程序从页缓存从把数据拷贝自己的内存缓存中</li>
<li>应用程序将数据写入到内核中 socket 缓存中</li>
<li>操作系统把数据从 socket 缓存中拷贝到网卡接口缓存，从这里发送到网络上。</li>
</ul>
<p>这显然是低效率的，有 4 次拷贝和 2 次系统调用。<code>sendfile</code> 通过直接将数据从页面缓存发送网卡接口缓存，避免了重复拷贝，大大的优化了性能。</p>
<p>在一个多consumers的场景里，数据仅仅被拷贝到页面缓存一次而不是每次消费消息的时候都重复的进行拷贝。这使得消息以近乎网络带宽的速率发送出去。这样在磁盘层面你几乎看不到任何的读操作，因为数据都是从页面缓存中直接发送到网络上去了。</p>
<p><strong>数据压缩</strong></p>
<p>很多时候，性能的瓶颈并非CPU或者硬盘而是网络带宽，对于需要在数据中心之间传送大量数据的应用更是如此。当然用户可以在没有 Kafka 支持的情况下各自压缩自己的消息，但是这将导致较低的压缩率，因为相比于将消息单独压缩，将大量文件压缩在一起才能起到最好的压缩效果。</p>
<p>Kafka 采用了端到端的压缩：因为有『消息集』的概念，客户端的消息可以一起被压缩后送到服务端，并以压缩后的格式写入日志文件，以压缩的格式发送到 consumer，消息从 producer 发出到 consumer 拿到都被是压缩的，只有在 consumer 使用的时候才被解压缩，所以叫做『端到端的压缩』。Kafka支持GZIP和Snappy压缩协议。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://kafka.apache.org/" target="_blank" rel="external">Apache Kafka</a></li>
<li><a href="http://kafka.apache.org/documentation.html#quickstart" target="_blank" rel="external">Quick Start</a></li>
<li><a href="http://www.aboutyun.com/thread-12882-1-1.html" target="_blank" rel="external">Kafka入门经典教程</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-kafka/" target="_blank" rel="external">Apache kafka 工作原理介绍</a></li>
<li><a href="http://www.coderli.com/setup-kafka-cluster-step-by-step/" target="_blank" rel="external">事无巨细 Apache Kafka 0.9.0.1 集群环境搭建</a></li>
<li><a href="http://blog.csdn.net/dhtx_wzgl/article/details/46892231" target="_blank" rel="external">kafka集群搭建</a></li>
<li><a href="http://tech.meituan.com/kafka-fs-design-theory.html" target="_blank" rel="external">Kafka文件存储机制那些事</a></li>
<li><a href="http://kaimingwan.com/post/kafka/kafkayuan-li-yi-ji-she-ji-shi-xian-si-xiang" target="_blank" rel="external">kafka原理以及设计实现思想</a></li>
<li><a href="http://www.dexcoder.com/dexcoder/article/2194" target="_blank" rel="external">kafka设计原理介绍</a></li>
<li><a href="http://blog.jobbole.com/99195/" target="_blank" rel="external">Kafka集群操作指南</a></li>
<li><a href="https://www.quora.com/What-is-the-actual-role-of-ZooKeeper-in-Kafka" target="_blank" rel="external">What is the actual role of ZooKeeper in Kafka?</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>提到消息系统，目前最火热的非 Kafka 莫属，公司也打算利用 Kafka 进行各业务日志统一收集，这里结合自己的实践来分享一下具体的配置及使用。Kafka 版本 0.10.0.1</p>]]>
    
    </summary>
    
      <category term="分布式" scheme="http://wdxtub.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="日志" scheme="http://wdxtub.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="消息队列" scheme="http://wdxtub.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[好问题收集]]></title>
    <link href="http://wdxtub.com/2016/08/14/good-question/"/>
    <id>http://wdxtub.com/2016/08/14/good-question/</id>
    <published>2016-08-13T23:54:53.000Z</published>
    <updated>2016-08-14T00:24:21.000Z</updated>
    <content type="html"><![CDATA[<p>好的问题往往能引发人的思考，而思考的过程其实比答案更加重要。这里收集了各类我在网上看到的有趣问题。在这里跟大家分享一下，有空会更新。</p>
<a id="more"></a>
<hr>
<h2 id="Insightful_Questions__u667A_u6027_u95EE_u9898"><a href="#Insightful_Questions__u667A_u6027_u95EE_u9898" class="headerlink" title="Insightful Questions 智性问题"></a>Insightful Questions 智性问题</h2><p>来自即刻的对应栏目，截至 16/08/15</p>
<ul>
<li>Is it more common for a country to have more parties on the left or the right? 在一个国家中是不是通常左倾或者右倾党派会有一个占多数？</li>
<li>Would you give up your right to privacy to live in a Utopia? 为了生活在一个理想的乌托邦里，你会放弃隐私吗？</li>
<li>Do we need a visual image in order to be in love? 我们可以在不见到对方形象的情况下坠入爱河吗</li>
<li>Entropy is constantly increasing in the universe. Does this directly affect human lifestyle gradually? Is our world meant to be more chaotic with age? 雨中中熵总是增加的，这会直接性地渐渐改变人类的生活方式吗，我们的人类社会随着时间发展会变得更混乱无序吗？</li>
<li>Can an non sapient animal distinguish dreams from reality? 对没有智力的动物而言，它们能分清梦境与现实吗？</li>
<li>When does a human become a separative living being with their own rights? 一个人从何时起可以界定为具有自身权利的独立个体？</li>
<li>How would people react if the Simulation theory was proven correct? 如果我们真的发现自己生活在虚拟世界中，人类群体会作何反应？</li>
<li>Should people have the right to choose exactly where to funnel their tax dollars, and stop the spending of the tax dollars should they disagree with the service government is spending it on? 人民有权选择缴纳具体的税收项目吗？当人民不同意政府某些财政支出的时候，可以停止交税吗？</li>
<li>Does ironic racism still count as racism? 玩笑式的种族歧视话语仍然被当作真正的种族歧视吗？</li>
<li>Is reality just our perception of reality? 所谓『现实』是否仅仅是现实在我们的知觉中的反映？</li>
<li>How many generations could a dictatorship last if the first dictator was benevolent and intelligent? 如果第一代独裁者仁慈且智慧，他的独裁政权能持续多少代？</li>
<li>How do you rescue a group of people which may contain a murderer? 如果想救的一群人中混有杀人凶手，该怎么办？</li>
<li>Should people have the right to discriminate? 人们有歧视的权力吗？</li>
<li>Are ethics universal and unchanging, or culturally relative and man made? 伦理学是普世不变的还是随文化与人为而改变？</li>
<li>Is prejudice, when based upon one’s own life experiences, such a bad thing? 基于生活经验而来的偏见是不是一定不对呢？</li>
<li>Is pirating books online that you could also “rent” digitally from a library hurting anyone? 如果可以在图书馆接到免费电子版，那在网上下载同一本书的盗版会对任何人造成损害吗？</li>
<li>Would an artificial intelligence strive for survival? 人工智慧会有求生欲望</li>
<li>How would our society, emotions and law be affected if we learned death was an unquestionable good for people? 如果得知死亡毫无疑问是件好事，我们的社会在情感与法律上会受到什么影响</li>
<li>Why do humans need to control each other, and want to feel in control of situations? 人类为什么喜欢控制他人，有想要一切尽在掌控中的欲望？</li>
<li>Will medical advances kill morality after there are no consequences for taboo behavior? 如果医学上的进步使本来的一些禁忌行为不再造成后果，会消除它们在道德上的限制吗？</li>
<li>What gives an item or thing value? 是什么赋予了一件事情或东西以价值？</li>
<li>Should ALL victimless crimes be legalized? 没有受害者的犯罪是不是都该合法化？</li>
<li>Should humanity strive for immortality? 人类应该追求永生吗？</li>
<li>Can we accurately judge our own attractiveness? 我们可以准确评估自己的吸引力么？</li>
<li>Could a person who understands a complex idea (be it scientific, philosophical, etc.) have come up with the idea themselves? 在某人有能力理解一个复杂概念（哲学或科学上）的情况下，他是否一定可以在还没有这个概念的时候自己将它发现出来呢？</li>
<li>Why do we feel awe? 人为什么会有敬畏之情？</li>
<li>Do the benefits or freedom outweigh the problems freedom enables? 自由带来的正面与负面效应孰轻孰重？</li>
<li>What rights do we have? 我们有什么权利？</li>
<li>In the far future - how will territorial boundaries be handled after significant movement of earth’s plates? 在遥远的未来，因为大陆版快漂移造成的剧变会怎样影响既有的国家领土划分</li>
<li>If you could sacrifice your most joyous memory in order to take away your worse. Would you? 如果牺牲你最快乐的那段记忆来消除最痛苦的那段，你愿意吗？</li>
<li>How can one recognize one’s true personality? 一个人怎样发现自己真正的本性？</li>
<li>Are people rather egoistic or altruistic? 人性是利己的还是利他的</li>
<li>What heartfelt principles did you once hold, but have since changed? And what changed them? 哪些原则是你曾坚持，而后改变乐的，是什么改变了它</li>
<li>Could fresh water be the cause for the next major war? 对清洁饮用水的争夺是否会成为下次大战的起因？</li>
<li>What are the true intentions of charity? 做慈善的真正目的是什么</li>
<li>Should we be always painfully honest? 我们应该绝对诚实吗？</li>
<li>How different would our world be if the average lifespan was only 25? 如果人的平均寿命只有 25 岁，这个世界会有什么不同？</li>
<li>If you could take a pill that would remove the need for sleep, but it means you will never dream again, would you take it? 如果有一颗药能让人不需要睡眠，也不再做梦，你会不会吃？</li>
<li>What are we so confident in our beliefs about things that we can’t possibly know? 为什么我们会对 不可知的事抱有坚定的信念？</li>
<li>How has modern life incapacitated our ability to grow and adapt to stress? 现代生活如何让我们失去了成长和适应压力的能力？</li>
<li>Is democracy really the best form of government? 民主真的是最好的政府形式吗？</li>
<li>What is the best way to combat religious extremism occurring throughout the world? 宗教极端分子在全世界制造灾难，打击他们最好的办法是什么</li>
<li>When is war justifiable? 什么情况下，战争可能被认为是合理的选择？</li>
<li>What has been some of the most valuable lessons you’ve learned in life? 你在生活中学到最有价值的东西是什么？</li>
</ul>
<h2 id="u52A0_u6DF1_u5F7C_u6B64_u8BA4_u8BC6_u7684_36__u4E2A_u95EE_u9898"><a href="#u52A0_u6DF1_u5F7C_u6B64_u8BA4_u8BC6_u7684_36__u4E2A_u95EE_u9898" class="headerlink" title="加深彼此认识的 36 个问题"></a>加深彼此认识的 36 个问题</h2><p>在生活大爆炸里 Sheldon 和 Penny 做过的一套题目</p>
<ol>
<li>如果可以跟世上任何人共进晚餐, 你会选择谁?</li>
<li>你会想出名吗? 以什么样方式出名呢?</li>
<li>在打一通电话之前, 你会先排演要在电话中说什么吗? 为什么?</li>
<li>你心中最完美的一天是做哪些事呢?</li>
<li>你上一次唱歌给自己听是什么时候? 上一次唱给别人听又是何时?</li>
<li>如果你可以活到90岁, 并能在30岁过后让体态或大脑一直保持30岁的状态到死, 你会选保持体态还是大脑呢?</li>
<li>你有曾经预感过自己会怎么死亡吗?</li>
<li>举出3个你与你对面这位的共同点.</li>
<li>你人生中你最感激什么?</li>
<li>如果你能改变你是怎么被抚育成人的, 你会想改变什么?</li>
<li>用四分钟跟你对面这位分享你的一生, 越详细越好.</li>
<li>如果你明早一觉醒来发现自己获得了某种能力, 你希望是什么能力?</li>
<li>如果一颗魔法水晶球能告诉你有关你自己, 你的人生, 你的未来, 或任何事情, 你会想知道什么?</li>
<li>你有已经梦想了很久, 想做的事情吗? 你为什么还没去做?</li>
<li>你人生中最大的成就是什么?</li>
<li>一段友情中你最珍视的是什么?</li>
<li>你最珍贵的一段回忆是什么?</li>
<li>你最糟糕的一段回忆是什么?</li>
<li>如果你知道你会在一年后突然死去, 你会想改变任何你现在的生活方式吗? 为什么?</li>
<li>友情对你来说代表什么?</li>
<li>爱与喜欢在你的人生中有着什么样的地位?</li>
<li>轮流分享你觉得你的恋人应该具有的五项好品质?</li>
<li>你的家庭亲密温暖吗? 你觉得你的童年有比别人幸福点吗?</li>
<li>你觉得你跟你的母亲的关系怎么样呢?</li>
<li>用”我们”做主语造三个肯定句, 比如”我们都在这个房间里”.</li>
<li>完成以下句子”我希望我有一个人能与ta分享…”</li>
<li>如果你会跟你对面的人变成亲密好友, 分享一下你觉得对方必需得知道的事情.</li>
<li>告诉你对面的人你喜欢ta什么: 老实回答, 说一些你通常不会告诉刚认识的人的答案.</li>
<li>与你对面的人分享人生中很尴尬的一刻.</li>
<li>你上一次在别人面前哭是什么时候? 上一次自己哭是什么时候?</li>
<li>告诉你对面的人你已经喜欢上ta的什么?</li>
<li>有什么人事物是太严重, 不能随便开玩笑的?</li>
<li>如果你将在今晚死去, 没有任何再与他人交流的机会, 你最后悔没有把什么事情跟别人说?</li>
<li>你的家着火了, 里面有你所拥有的一切事物. 在救出你爱的人, 你的宠物后, 你还有时间最后再冲回去一趟拯救最后一样任何东西, 你会救出什么? 为什么?</li>
<li>你家庭中的所有人里, 谁的死会让你最难受? 为什么?</li>
<li>分享一个你私人的问题, 并想你对面的人询问ta会怎么处理. 之后再请ta回答, 对于你选这个问题, ta有什么看法?</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>好的问题往往能引发人的思考，而思考的过程其实比答案更加重要。这里收集了各类我在网上看到的有趣问题。在这里跟大家分享一下，有空会更新。</p>]]>
    
    </summary>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="问题" scheme="http://wdxtub.com/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第九周 - 天空]]></title>
    <link href="http://wdxtub.com/2016/08/13/sky/"/>
    <id>http://wdxtub.com/2016/08/13/sky/</id>
    <published>2016-08-13T13:27:13.000Z</published>
    <updated>2016-08-13T23:40:15.000Z</updated>
    <content type="html"><![CDATA[<p>昨夜星辰昨夜风，那是无边浪漫暖春，花树下起阵阵雨，淅沥淅沥，朝露拥吻山桃花，院子里面热气新茶，风铃摇曳屋簷下，嘀哒嘀哒。</p>
<a id="more"></a>
<hr>
<p>万万没想到，一周居然可以发生这么多的事儿。搭好个人工作室可以是一天，项目调整部门变化可以是一天，业务对接东拉西扯可以是一天，从深圳回广州也可以是一天。有了大桌子和显示器效率提升不止百分之百；拥抱变化大概是程序员的自我修养；对接业务更多需要的是耐心；而回家则是为了放松，毕竟弦不能总绷着嘛。</p>
<p>正是在这样的变动下，往往才更能看清自己的方向和价值，诚然有些东西因为这样那样的原因需要妥协，不过人嘛，还是要有自己的底线，就像谈判一样，不然总有一天要退无可退跌落悬崖的。</p>
<p>最近最火的恐怕是奥运了，本来没啥感觉，真正一块一块奖牌出现之后，不由自主开始牵肠挂肚。和四年前相比，更让我开心的不是金牌的变化，而是运动员和网民的变化，这种变化真的让我觉得，新时代的大幕在缓缓揭开。从『我们』中慢慢看到『我』，个体的觉醒也许方向有所不同，但是总比千人一面要好嘛。</p>
<p>因为项目的需求，我需要跟公司各个产品线进行一定的业务对接，在各种跨部门合作中，逐渐也摸索出来了一套工作流程，简单来说就是『找对接人的领导比找对接人有用』。各种摸爬滚打也让我有些感悟：一直以来我习惯的模式是 hack 而不是 build，而在公司里最需要的是 build，这也是我最需要提高的能力。虽然各种人员变动让人觉得不那么靠谱，不过首先还是要做好自己，剩下的，就是历史的行程了。</p>
<p>几周没回家，在深圳的小房间里切实『闭关』了一把，也把剩下的计算机学科经典看得七七八八。虽然岁月着实让曾经的光芒有些褪色，但相比于其他稍纵即逝的流星，经典还是颇为持久且耀眼的。同事问我为什么看书快，有没有什么技巧。我说其实我看书不快，只是我一直在看，比方说六点起床，到晚上睡觉，除了吃早餐点外卖睡个午觉之外我只做一件事，十多个小时就是看书记笔记。哪有什么所谓的技巧，有技巧的话，就是心无旁骛吧。</p>
<p>老板亲自抓的项目，项目组成员大概是没有什么好日子的：凌晨三四点下班或者干脆通宵；各种需求却要多快好省尽快做完；下班后开会赶工；各种朋友圈发广告刷屏。用纯银的话说就是：</p>
<blockquote>
<p>创业者要求员工加班，应该心怀歉意，毕竟经常性加班说明管理无能……管理无能也就罢了，最恶心的是要求员工在社交网络谈论公事，侵入员工的私域，以此微小的宣传收益，弥补公司的推广无能，公关无能。老板要真有这心思就把自己微博经营好，别去骚扰员工。</p>
</blockquote>
<p>深以为然，这样的成语我可以说一串：竭泽而渔杀鸡取卵饮鸩止渴刻舟求剑。但楚王好细腰，下面的人又能怎么办呢？我赶紧又把明朝那些事儿放到 kindle 里，以史为鉴嘛。</p>
<p>这周跑步了四次，不过也难以扭转体重一直在增长的趋势，所以给自己定下一个目标！减掉 5 公斤！因此，执行如下：</p>
<ol>
<li>过午不食，早上吃好，中午吃沙拉</li>
<li>除了牛奶和豆奶，不吃任何零食区的东西</li>
<li>坚持跑步和每小时的俯卧撑练习</li>
<li>十一点前睡觉</li>
<li>买个秤，每天早上记录体重</li>
</ol>
<p>这八月的天空，大桥下，河堤旁，抚过柳叶的风；不如就，一起散散步。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨夜星辰昨夜风，那是无边浪漫暖春，花树下起阵阵雨，淅沥淅沥，朝露拥吻山桃花，院子里面热气新茶，风铃摇曳屋簷下，嘀哒嘀哒。</p>]]>
    
    </summary>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="生活" scheme="http://wdxtub.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rsyslog + Logstash 日志传输指南]]></title>
    <link href="http://wdxtub.com/2016/08/12/rsyslog-logstash-guide/"/>
    <id>http://wdxtub.com/2016/08/12/rsyslog-logstash-guide/</id>
    <published>2016-08-12T15:03:57.000Z</published>
    <updated>2016-08-15T11:37:30.000Z</updated>
    <content type="html"><![CDATA[<p>最近在把公司各个业务线的数据和日志接入到统一的 ELK 平台中，我主要在做 LK 和对接的工作，涉及服务器和网络拓扑相关内容比较多和杂，网上没有太多相关资料，这里跟大家分享一下我的一点经验。</p>
<a id="more"></a>
<hr>
<h2 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h2><p>因为部分历史遗留问题以及业务线的情况，不同后台业务涉及两个云服务提供商在三地的不同机房。出于安全考虑，不同项目组的服务器需要隔离（目前还没有用容器，所以是虚拟机隔离），但是日志需要统一进行收集、统计和展示。因为人员调动，我其实是临时接手这部分业务，所以只能在平稳接入各个业务之后，再考虑架构的演进。</p>
<p>之前的架构基本是『怎么快怎么方便怎么来』，颇有『刀耕火种』的感觉，不过大部分时间还是运转良好的，在新架构完成之前，只能先用这套不太完善的机制进行传输了。</p>
<p>为了描述方便，这里我们虚构两个服务，各自服务器部署配置如下</p>
<ul>
<li>服务 A：两个机房<ul>
<li>机房 1：杭州阿里云，机器 x 3，编号 A-HZ-ALI-01, A-HZ-ALI-02, A-HZ-ALI-03</li>
<li>机房 2：美国 AWS，机器 x 3，编号 A-US-AWS-01, A-US-AWS-02, A-US-AWS-03</li>
</ul>
</li>
<li>服务 B：两个机房<ul>
<li>机房 1：杭州阿里云，机器 x 3，编号 B-HZ-ALI-01, B-HZ-ALI-02, B-HZ-ALI-03</li>
<li>机房 2：美国阿里云，机器 x 3，编号 B-US-ALI-01, B-US-ALI-02, B-US-ALI-03</li>
</ul>
</li>
</ul>
<p>而 Elasticsearch 集群部署在美国 AWS，后面统称 ES。另外还有部分数据需要从 RDS 中获取，统称为 MySQL 任务。</p>
<h2 id="u7F51_u7EDC"><a href="#u7F51_u7EDC" class="headerlink" title="网络"></a>网络</h2><p>每台服务器都有自己的日志，使用 logrotate 工具按日进行切割，如果服务异常，之前的做法是登录到对应机器上进行日志查看。因为使用 Nginx 做负载均衡的缘故，很可能没办法快速找到对应的日志（现在机器比较少还好，再多就很麻烦了）。所以我们首先需要考虑的是想个办法把各个机器的日志收集到一起。</p>
<p>在具体部署的时候，我们考虑过两种方案，这里简单介绍一下：</p>
<p>第一种，简单粗暴，每台机器均直接把自己的日志发送给 ES。第二种，在每个机房选择一台服务器进行日志汇总，然后再统一发送给 ES。这两种方案各有优劣，我们来简单思考一下：</p>
<p>第一种方案的优劣</p>
<ul>
<li>劣势<ul>
<li>每台机器直接发给 ES 需要大量配置（当然这个可以用自动配置工具完成），一旦需求变动，所有的配置都需要修改</li>
<li>每台机器都需要外网权限，运维难度增加，安全风险增加</li>
<li>没办法利用内网通讯速度快的优势，给线上服务带来较高的带宽压力</li>
</ul>
</li>
<li>优势<ul>
<li>避免了单点的问题，即使一台服务器出问题，其他的日志还能正常发送数据</li>
</ul>
</li>
</ul>
<p>第二种方案的优劣   </p>
<ul>
<li>劣势<ul>
<li>汇总服务器是单点，一旦出问题，所有的日志都没有办法正常发送</li>
</ul>
</li>
<li>优势 <ul>
<li>只需要配置一台机器（其他机器可以通过系统自带的 rsyslog 进行日志传输），即使人工操作也不太麻烦</li>
<li>只有一台服务器强制需要外网权限</li>
<li>内部的日志传输通过内网，速度快</li>
</ul>
</li>
</ul>
<p>综合上述考虑，我们决定采用第二种解决方案，接下来会介绍如何进行配置。</p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>在开始配置之前一定要确定下面几个事情：</p>
<ul>
<li>服务器上的对应端口是否有配置好权限</li>
<li>服务器的内网 ip 以及内网互访的权限</li>
<li>Logstash 和 Rsyslog 的版本</li>
<li>服务器配置及负载情况</li>
</ul>
<h3 id="u8F6C_u53D1_u673A_u914D_u7F6E"><a href="#u8F6C_u53D1_u673A_u914D_u7F6E" class="headerlink" title="转发机配置"></a>转发机配置</h3><p>有了这些信息，我们就可以从每个机房挑选一台服务器作为日志汇总和转发机，这里我们选择：A-HZ-ALI-01, A-US-AWS-01, B-HZ-ALI-01, B-US-ALI-01 这四台机器分别接入（后面称为汇总机）。</p>
<p>这里我们使用 Logstash 进行日志汇总转发，各台机器上的 Logstash 配置可以是一样的，因为需要在后台启用该服务，所以需要修改/创建 <code>/etc/logstash/conf.d/logstash.conf</code> 文件，然后使用 <code>sudo service logstash restart</code> 重启服务（或者也可以使用 <code>&amp;</code> 创建后台任务，总之把应用开起来就行）</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="name">input</span> &#123;</span><br><span class="line"> tcp &#123;</span><br><span class="line">   port=&gt; <span class="number">16666</span></span><br><span class="line">   codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="name">filter</span> &#123;</span><br><span class="line">  geoip &#123;</span><br><span class="line">    source =&gt; <span class="string">"ip"</span></span><br><span class="line">    fields =&gt; [<span class="string">"location"</span>, <span class="string">"city_name"</span>, <span class="string">"country_name"</span>, <span class="string">"country_code2"</span>,<span class="string">"country_code3"</span>, <span class="string">"region_name"</span>, <span class="string">"continent_code"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="name">output</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [<span class="string">"es.wdxtub.com:80"</span>]</span><br><span class="line">        index =&gt; <span class="string">"ServiceA-log-%&#123;+YYYY-MM-dd&#125;"</span></span><br><span class="line">        user =&gt; <span class="string">"wdxtub"</span></span><br><span class="line">        password =&gt; <span class="string">"www.wdxtub.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置文件的意思是当程序启动时，监听 16666 端口传来的 json 行，根据 ip 地址获取地理信息之后，发送到 <code>es.wdxtub.com:80</code> 这个 ES 集群中，对应的索引是 <code>ServiceA-log-%{+YYYY-MM-dd}</code>，这里实际上做了按日分隔（在 Kibana 中只需使用 <code>ServiceA-log-*</code> 就可以汇总所有的 ServiceA 的日志）</p>
<h3 id="u65E5_u5FD7_u8F6C_u53D1"><a href="#u65E5_u5FD7_u8F6C_u53D1" class="headerlink" title="日志转发"></a>日志转发</h3><p>我们现在已经有了从汇总机到 ES 的通道，现在需要做的就是把各个机器的日志发送到汇总机了，甚至汇总机本机的日志也可以通过这种方式进行（这样就是一个统一的过程了，不因为机器的角色有特殊情况）。这里具体选择的方式是 rsyslog，同一个机房同一个服务的机器的配置文件是一样的，我们在 <code>/etc/rsyslog.d/</code> 中新建一个 <code>10-file.conf</code> 文件，内容为</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># 载入文件读取模块</span></span><br><span class="line"><span class="variable">$ModLoad</span> imfile</span><br><span class="line"><span class="variable">$template</span> myFileMonitorTemplate,<span class="string">"%msg%"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 日志文件</span></span><br><span class="line"><span class="variable">$InputFileName</span> /data/home/service/project/shared/<span class="built_in">log</span>/lograge_production.<span class="built_in">log</span></span><br><span class="line"><span class="preprocessor"># 打标签</span></span><br><span class="line"><span class="variable">$InputFileTag</span> service-<span class="built_in">log</span>:</span><br><span class="line"><span class="preprocessor"># 下面这行是用来保存文件状态的</span></span><br><span class="line"><span class="variable">$InputFileStateFile</span> stat1470781524</span><br><span class="line"><span class="variable">$InputFileSeverity</span> info</span><br><span class="line"><span class="variable">$InputFileFacility</span> local7</span><br><span class="line"><span class="preprocessor"># 拉取时间间隔，单位是秒</span></span><br><span class="line"><span class="variable">$InputFilePollInterval</span> <span class="number">1</span></span><br><span class="line"><span class="variable">$InputFilePersistStateInterval</span> <span class="number">1</span></span><br><span class="line"><span class="variable">$InputRunFileMonitor</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 两个 @@ 为 tcp 请求</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$syslogtag</span> contains <span class="string">'service-log'</span> <span class="literal">and</span> <span class="variable">$syslogfacility</span>-text == <span class="string">'local7'</span> <span class="keyword">then</span> @<span class="constant">@10</span><span class="number">.0</span><span class="number">.1</span><span class="number">.2</span>:<span class="number">16666</span><span class="comment">;myFileMonitorTemplate</span></span><br><span class="line">&amp; stop</span><br></pre></td></tr></table></figure>
<p>配置文件最后的地址就是对应转发机的内网 ip 地址，这样我们就建立了每个服务器到转发机的连接。然后可以通过 <code>sudo service rsyslog restart</code> 来重启并加载新的配置文件。因为使用 logrotate，所以还要考虑 rotate 时候的日志传输问题，解决办法是在 <code>/etc/logrotate.d/</code> 文件夹中新建一个 <code>_machine_name</code> 文件，内容为</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/data/</span>home<span class="regexp">/service/</span><span class="keyword">project</span><span class="regexp">/current/</span>log<span class="comment">/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    size 200M</span><br><span class="line">    missingok</span><br><span class="line">    rotate 52</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    notifempty</span><br><span class="line">    copytruncate</span><br><span class="line">postrotate</span><br><span class="line"> (sudo stop rsyslog &amp;&amp; sudo sed -i "s/InputFileStateFile.*/</span>InputFileStateFile stat$(date +<span class="string">'%s'</span>)<span class="regexp">/" /</span>etc<span class="regexp">/rsyslog.d/</span><span class="number">10</span>-<span class="keyword">file</span>.conf &amp;&amp; sudo start rsyslog <span class="number">2</span>&gt;&amp;<span class="number">1</span>) || <span class="keyword">true</span></span><br><span class="line">        endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的比较常规，主要是 <code>postrotate</code> 之后执行的脚本，大意就是在日志切分之后完成收尾工作，保证不因为 logrotate 导致日志重复发送或者丢失。</p>
<p>至此，我们就建立了服务器 - 转发机 - ES 的完整链路。</p>
<hr>
<p>更新 rsyslog 的方法，因为要发送到 kafka 需要 v8 的配合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:adiscon/v8-stable</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rsyslog</span><br></pre></td></tr></table></figure>
<p>更新之后就可以弄到 kafka 上了</p>
<h2 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h2><p>前面的配置看起来不复杂，但是其中任何一步没跑通，整个套路就玩不转。具体有没有什么办法能测试呢？当然要有了，不然真是连错都找不到。我们来看看一步一步如何进行测试。</p>
<h3 id="u8F6C_u53D1_u673A_u5230_ES"><a href="#u8F6C_u53D1_u673A_u5230_ES" class="headerlink" title="转发机到 ES"></a>转发机到 ES</h3><p>首先是测试配置文件，直接从 logstash 文件夹前台启动 logstash，并查看具体的信息，确定无误后，再放到后台执行。这里可能遇到的问题基本是跟 logstash 版本相关的，要么升级要么改成对应版本的配置语法即可。</p>
<p>常用的命令有 </p>
<ul>
<li><code>sudo lsof -i:16666</code> 查看对应端口的占用情况</li>
<li><code>ifconfig</code> 查看本机的网络信息</li>
<li><code>cat /proc/meminfo</code> 查看本机的内存信息</li>
<li><code>cat /proc/cpuinfo</code> 查看本机的 CPU 信息</li>
<li><code>ps aux | grep logstash</code> 查看 logstash 对应的进程号（可以用于强制关闭）</li>
</ul>
<h3 id="u670D_u52A1_u5668_u5230_u8F6C_u53D1_u673A"><a href="#u670D_u52A1_u5668_u5230_u8F6C_u53D1_u673A" class="headerlink" title="服务器到转发机"></a>服务器到转发机</h3><p>具体配置的时候，这一步是问题最多的，因为 rsyslog 的配置实在是令人抓狂。基本的测试套路是这样的</p>
<ul>
<li>用 telnet 看看转发机的对应端口开起来没有，如果开起来了，应该是能连通的，不能的话，检查权限与服务配置</li>
<li>可以利用 <code>nc</code> 工具尝试发送单条 log，比如 <code>head -n1 service.log | nc 10.0.1.2 16666</code>，如果卡住，那么说明链路建立有问题，如果能正常发送，就可以看看 ES 到底收到没有了</li>
</ul>
<p>基本上如果这两步都没问题，大概是可以看到链路建立的。如果还不行，考虑到我对运维这块也不是很熟，就只能自力更生或者抱大腿了。</p>
<h2 id="u6539_u8FDB_u65B9_u5411"><a href="#u6539_u8FDB_u65B9_u5411" class="headerlink" title="改进方向"></a>改进方向</h2><p>目前这套非常脆弱的处理流程，每天只能祈祷服务器不崩，崩了之后得自己手动重启（或者写一个守护进程，挂了之后重新启动起来）。这种收集的工作，使用业务服务器『推』的模型，不如统一由日志服务器『拉』，如果借由诸如 S3 这样的外部存储，其实是可以做到解耦的。</p>
<p>所以这就衍生出两个套路，以后可以考虑尝试</p>
<ol>
<li>使用 fluentd</li>
<li>改为『拉』模型</li>
</ol>
<p>具体的以后细写，现在的我，感觉身体被掏空。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>搭建数据平台的过程基本把公司的业务线都过了一遍，深深感受到数据收集处理分析的重要性，这样对产品和服务的改进才不是瞎拍脑袋，才能真正把好钢用到刀刃上（现在的云资源浪费还是很严重的）。</p>
<p>不过嘛，慢慢来，一步一个脚印，每天都在进步就好。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.rsyslog.com/" target="_blank" rel="external">RSYSLOG 官网</a></li>
<li><a href="https://mos.meituan.com/library/5/how-to-config-rsyslog/" target="_blank" rel="external">如何对rsyslog进行配置</a></li>
<li><a href="http://blog.clanzx.net/2013/12/31/rsyslog.html" target="_blank" rel="external">rsyslog 配置简介</a></li>
<li><a href="https://segmentfault.com/a/1190000003509909" target="_blank" rel="external">Linux环境下使用rsyslog管理日志</a></li>
<li><a href="http://www.rsyslog.com/rsyslog-configuration-builder/" target="_blank" rel="external">配置文件生成器</a></li>
<li><a href="http://www.rsyslog.com/using-the-text-file-input-module/" target="_blank" rel="external">Using the Text File Input Module</a></li>
<li><a href="http://www.rsyslog.com/discarding-unwanted-messages/" target="_blank" rel="external">Discarding unwanted messages</a></li>
<li><a href="http://www.rsyslog.com/connecting-with-logstash-via-apache-kafka/" target="_blank" rel="external">Connecting with Logstash via Apache Kafka</a></li>
<li><a href="http://www.rsyslog.com/ubuntu-repository/" target="_blank" rel="external">Ubuntu Repository</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在把公司各个业务线的数据和日志接入到统一的 ELK 平台中，我主要在做 LK 和对接的工作，涉及服务器和网络拓扑相关内容比较多和杂，网上没有太多相关资料，这里跟大家分享一下我的一点经验。</p>]]>
    
    </summary>
    
      <category term="ELK" scheme="http://wdxtub.com/tags/ELK/"/>
    
      <category term="日志" scheme="http://wdxtub.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="服务器" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
</feed>
