<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小土刀</title>
  <subtitle>Agony is my triumph</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wdxtub.com/"/>
  <updated>2016-11-04T16:28:03.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name>wdxtub</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第二十一周 - Stand Up</title>
    <link href="http://wdxtub.com/2016/11/04/stand-up/"/>
    <id>http://wdxtub.com/2016/11/04/stand-up/</id>
    <published>2016-11-04T15:19:02.000Z</published>
    <updated>2016-11-04T16:28:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Well, I know, you’ve been searching for a long, long time. You can’t find peace of mind. You’re waiting for answers.</p>
<a id="more"></a>
<hr>
<p>这是艰难的一周，但终究熬了过去，甚至可以说表现得不错。虽然夜深人静的时候仍然会想起病房里的场景，不过慢慢也就习惯了，我能做的就是带着爷爷的所有期待继续往前跑吧。很奇怪，往常写周记时总感觉自己滔滔不绝，这周却愣是敲不出几个字儿。既然如此，也就不勉强，随便说两句吧。</p>
<p>公司举办的篮球赛如期举行，不过相比于其他部门队员加拉拉队二三十人的庞大阵容，我们部门勉强凑出来的四分之三支球队自然是被打得落花流水。在场上我非常难受，很想做点什么，但是却什么都做不了，希望以后这样的时刻能少一点，我不喜欢这样的感觉。</p>
<p>昨天去看了电影『驴得水』，污污污了小半场之后剧情开始大起大落，演得好，看得心疼。虽然鸡汤里总说苦难是财富，但是绝望和仇恨真的可以摧毁一个人，影片中每一个人的变化都是如此残忍，让原本笑声不断的片场最终一片死寂，直到一声枪响宣告了最终的结局。</p>
<p>周五一如既往开会，这次和欧洲一个公司的 COO 简单聊了一下 GUTMA 的架构工作组的进度和未来计划。两个英语不是母语的人聊起天来都有些紧张，不过写了一个星期代码，有人聊聊天总是开心的。接下来应该会花多一点时间在 UTM 的相关项目上了，所以好消息大约是『聊聊无人机』系列可以继续写下去了。</p>
<p>仔细比较中国、美国和欧洲，就会发现这三个地方彼此有相似的地方，但与此同时又有非常明显的差异点。想要在世界范围内把工作做好，就离不开对不同文化的理解，很多时候不能简单的生搬硬套一刀切，更多是在利益的缝隙中斡旋，找到大家都能接受的方案。另外面对全新的事务，不同国情、不同组织架构都会对工作的展开带来极大的影响，好消息是能参与到规划未来的队伍中，不过能力越大责任越大，责任越大思考决策也需要更加审慎，还是要继续提高自己的硬实力。</p>
<p>二老板交代下来的临时任务估计再有一两周就可以收尾了，和领导沟通的确是一门艺术，我也在不断调整自己的工作方式，很多时候有些看起来『投其所好』的做法，目的其实是为了更快更好地做事情。术业有专攻，如果领导暂时不够理解自己在做的事情的难度和价值，就需要在沟通中努力去影响去展示，而不是躲在一边抱怨。既然事情交到我手上，那么当我交出去的那一天，一定是达到我自己的标准的一天，要做就做好，只有先证明自己是一个能做好事情的人，才有资格去选择自己要做的事情。</p>
<p>虽然任务不算特别难，但是在不到两周的时间完成系统构思设计与开发，对自己来说也是一个锻炼。可以照着设计师的稿子撸 CSS，可以自己设计前端的模板和接口，可以一口气完成逻辑层与数据层的设计、搭建与开发。且不论别人怎么看，对自己的信心是一个很大的提高，经过小半年的摸爬滚打，基本上把自己作为工程师的短板都补上了。从前学过的各种理论，在不同层次的实践中转换成了我的十八般武器。接下来的目标，一方面是成为团队内的『布道师』，另一方面就是努力去推动工程师文化。</p>
<p>部门合并之后，也慢慢了解了一些其他同事的工作，可能有些不客气，但是不少人做事情和思考的方法还是有很大提高的空间的。在开源运动蓬勃发展的今天，难点其实已经从如何开发变成了如何选择最合适的技术方案和架构。如果一直把自己局限在熟悉的技术和解决方案中，终究会被时代所淘汰（尤其是在快速更新换代的 IT 行业）。</p>
<p>程序员的理想国也许就是巴比伦的通天塔，虽然大概永远无法建成，但在一次又一次的尝试中留下来的精神和物质财富，才是最重要的。想起之前在非常小众的 Windows Phone 平台上做『英雄联盟百科』的日子，得到官方推荐当然高兴，但最让我开心的是玩家喜欢，我也因此交了许多朋友，他们会觉得会写代码很酷，甚至也最终投身其中，我觉得就是情怀。</p>
<p>When. Can’t keep his mind on nothing else. He’d trade the world for a good thing he’s found.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Well, I know, you’ve been searching for a long, long time. You can’t find peace of mind. You’re waiting for answers.&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【Go 之旅】II Go 编码风格指南</title>
    <link href="http://wdxtub.com/2016/11/02/go-style-guide/"/>
    <id>http://wdxtub.com/2016/11/02/go-style-guide/</id>
    <published>2016-11-02T14:09:10.000Z</published>
    <updated>2016-11-04T14:12:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文结合 Effective Go 与自己做项目的一些实践经验，来聊聊 Go 的编码风格指南。</p>
<a id="more"></a>
<hr>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p>Go 作为一门非常工程向的语言，虽然比较年轻，但是已经让我很开心了，我想，这应该是我最近会持续投入的一门语言。用这个系列跟大家分享我的学习之路。</p>
<ul>
<li><a href="http://wdxtub.com/2016/08/11/golang-first-step/">I Go 快速入门</a></li>
<li><a href="http://wdxtub.com/2016/11/02/go-style-guide/">II Go 编码风格指南</a></li>
<li><a href="http://wdxtub.com/2016/08/15/learn-go-the-hard-way/">III 我的笨办法学 Go</a></li>
<li><a href="http://wdxtub.com/2016/08/24/go-plane-1/">IV 项目实战：一起看飞机 - 项目介绍</a></li>
<li><a href="http://wdxtub.com/2016/08/24/go-plane-2/">V 项目实战：一起看飞机 - 后台</a></li>
<li><a href="http://wdxtub.com/2016/08/25/go-plane-3/">VI 项目实战：一起看飞机 - 客户端</a></li>
</ul>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><p>虽然 Go 自带的 <code>fmt</code> 工具已经解决了大部分排版的问题，但是在命名规范上仍旧有一些要求。另外，Go 的哲学与传统的面向对象的编程语言也有不一致的地方（如 Java），需要进行理解和适应。</p>
<p>之所以要强调编程规范，不仅仅是想要通过一个统一的约定减少代码的理解成本，更是通过引导来帮助大家接受 Go 的特性和风格，而不是简单用 Java 或者 C++ 的思路来写 Go（不然为什么不去写 Java/C++ 呢）</p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p><strong>包名应为小写单词</strong></p>
<p>不应有下划线或者混合大小写。正确示例 <code>controllers</code>, <code>models</code>, <code>routers</code>, <code>views</code></p>
<p><strong>全局变量即参数采用驼峰式命名</strong></p>
<ul>
<li>全局变量：驼峰式，首字母大写（如果不可导出，则首字母小写）</li>
<li>参数传递：驼峰式，首字母小写</li>
</ul>
<p><strong>局部变量采用下划线形式</strong></p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SettingsController)</span> <span class="title">Post</span><span class="params">()</span></span> &#123;</div><div class="line">	_ftype := c.GetString(<span class="string">"formtype"</span>)</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>采用全部大写或者全部小写来表示缩写单词</strong></p>
<p>比如对于url这个单词，不要使用</p>
<p>UrlPony<br>而要使用</p>
<p>urlPony 或者 URLPony  </p>
<p><strong>单个函数的接口名以 <code>er</code> 为后缀</strong></p>
<p>如 <code>Reader</code>, <code>Writer</code>，其具体的实现则去掉 <code>er</code>，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</div><div class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>两个函数的接口名综合两个函数名</strong>，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> WriteFlusher <span class="keyword">interface</span> &#123;</div><div class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</div><div class="line">    Flush() error</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>三个以上函数的接口名类似于结构体名</strong>，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Car <span class="keyword">interface</span> &#123;</div><div class="line">    Start([]<span class="keyword">byte</span>) </div><div class="line">    Stop() error</div><div class="line">    Recover()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>结构体方法参数名</strong></p>
<p>统一采用单字母 <code>p</code> 而不是 <code>this</code>, <code>me</code> 或者 <code>self</code>，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *T)</span><span class="title">Get</span><span class="params">()</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong><code>if</code> 接受初始化语句</strong></p>
<p>约定如下方式建立局部变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>for</code> 采用短声明建立局部变量</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">sum := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">    sum += i</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>range</code> 如果只需要第一项（key），就丢弃第二个</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</div><div class="line">    <span class="keyword">if</span> key.expired() &#123;</div><div class="line">        <span class="built_in">delete</span>(m, key)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>range</code> 如果只需要第二项，则把第一项置为下划线</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">sum := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</div><div class="line">    sum += value</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>一旦有错误发生，马上返回</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">f, err := os.Open(name)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> err</div><div class="line">&#125;</div><div class="line">d, err := f.Stat()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    f.Close()</div><div class="line">    <span class="keyword">return</span> err</div><div class="line">&#125;</div><div class="line">codeUsing(f, d)</div></pre></td></tr></table></figure>
<p><strong>不要滥用 <code>panic</code></strong></p>
<p>不要使用 <code>panic</code> 来做正常的错误处理，应当使用 <code>error</code> 和 多个返回值来进行。</p>
<p><strong>错误消息全小写</strong></p>
<p>错误处理中的字符串应该都是小写，这样在诸如 <code>log.Print(&quot;Reading %s: %v&quot;, filename, err)</code> 不会出现奇怪的大写。</p>
<p><strong>不要忽略错误</strong></p>
<p>如果一个函数的返回值包括 <code>err</code>，那么不要使用 <code>_</code> 来忽略它，而应该去检查函数是否执行成功，如果不成功则执行对应的错误处理并返回，只有在确实不希望出现的情况下才使用 <code>panic</code></p>
<p><strong>无论是参数列表还是返回值，最好加上名称，方便理解</strong>（尤其是在有同类型的多个参数的时候）</p>
<p>比如 <code>func (f *Foo) Location() (float64, float64, error)</code> 就不如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Location returns f's latitude and longitude.</span></div><div class="line"><span class="comment">// Negative values mean south and west, respectively.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span> <span class="title">Location</span><span class="params">()</span> <span class="params">(lat, long <span class="keyword">float64</span>, err error)</span></span></div></pre></td></tr></table></figure>
<p>来得清晰</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul>
<li>对于少量数据，不要传递指针</li>
<li>对于大量数据的struct可以考虑使用指针</li>
<li>传入参数是map，slice，chan不要传递指针<ul>
<li>因为map，slice，chan是引用类型，不需要传递指针的指针</li>
</ul>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><strong>每个包都应该有一个包注释，位于 package 之前。</strong>如果同一个包有多个文件，只需要在一个文件中编写即可，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Package models 包含应用所需的数据结构及对应的方法</span></div><div class="line"><span class="keyword">package</span> models</div></pre></td></tr></table></figure>
<p><strong>每个以大写字母开头（即可以导出）的方法应该有注释，且已该函数名开头。</strong>如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Get 会响应对应路由转发过来的 get 请求</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CrewController)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="常见技巧"><a href="#常见技巧" class="headerlink" title="常见技巧"></a>常见技巧</h2><h3 id="声明切片"><a href="#声明切片" class="headerlink" title="声明切片"></a>声明切片</h3><p>使用 <code>var t []string</code> 而不是 <code>t := []string{}</code> 来声明一个切片，这样如果切片从来没有使用的话，就不会对其分配内存</p>
<h3 id="延期执行"><a href="#延期执行" class="headerlink" title="延期执行"></a>延期执行</h3><p>Go的defer语句用来调度一个函数调用（被延期的函数），使其在执行defer的函数即将返回之前才被运行。这是一种不寻常但又很有效的方法，用于处理类似于不管函数通过哪个执行路径返回，资源都必须要被释放的情况。典型的例子是对一个互斥解锁，或者关闭一个文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Contents returns the file's contents as a string.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contents</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">    f, err := os.Open(filename)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">defer</span> f.Close()  <span class="comment">// f.Close will run when we're finished.</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> result []<span class="keyword">byte</span></div><div class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">        n, err := f.Read(buf[<span class="number">0</span>:])</div><div class="line">        result = <span class="built_in">append</span>(result, buf[<span class="number">0</span>:n]...) <span class="comment">// append is discussed later.</span></div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">if</span> err == io.EOF &#123;</div><div class="line">                <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>, err  <span class="comment">// f will be closed if we return here.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result), <span class="literal">nil</span> <span class="comment">// f will be closed if we return here.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对类似 <code>Close</code> 这样的函数调用进行延期，有两个好处。首先，其确保了你不会忘记关闭文件，如果你之后修改了函数增加一个新的返回路径，会很容易犯这样的错。其次，这意味着关闭操作紧挨着打开操作，这比将其放在函数结尾更加清晰。</p>
<p>被延期执行的函数，它的参数（包括接收者，如果函数是一个方法）是在 <code>defer</code> 执行的时候被求值的，而不是在调用执行的时候。这样除了不用担心变量随着函数的执行值会改变，这还意味着单个被延期执行的调用点可以延期多个函数执行。这里有一个简单的例子。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>被延期的函数按照 LIFO 的顺序执行，所以这段代码会导致在函数返回时打印出 <code>4 3 2 1 0</code>。</p>
<h2 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h2><ul>
<li><a href="http://www.kancloud.cn/kancloud/effective/72207" target="_blank" rel="external">数据 - new 与 make</a></li>
<li><a href="http://www.kancloud.cn/kancloud/effective/72210" target="_blank" rel="external">接口与方法</a></li>
<li><a href="http://www.kancloud.cn/kancloud/effective/72212" target="_blank" rel="external">内嵌 Embedding</a></li>
<li><a href="http://www.kancloud.cn/kancloud/effective/72213" target="_blank" rel="external">并发 - Goroutines 与 Channels</a></li>
<li><a href="http://www.kancloud.cn/kancloud/effective/72214" target="_blank" rel="external">错误处理</a></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.hellogcc.org/effective_go.html" target="_blank" rel="external">Effective Go 中文版</a></li>
<li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="external">Go Code Review Comments</a></li>
<li><a href="http://kiritor.github.io/2015/06/05/GolangPrjManager/" target="_blank" rel="external">Golang工程管理</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文结合 Effective Go 与自己做项目的一些实践经验，来聊聊 Go 的编码风格指南。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="编码" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>惜别</title>
    <link href="http://wdxtub.com/2016/10/30/reluctance-to-part/"/>
    <id>http://wdxtub.com/2016/10/30/reluctance-to-part/</id>
    <published>2016-10-30T01:50:01.000Z</published>
    <updated>2016-11-01T14:03:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在病房里最大的感受不是气味和声音，而是深入骨髓的无助。监视仪不断的报警声和爷爷颤抖的心电图像永不停息的敲击，直到发条走完，一切归于寂静。</p>
<a id="more"></a>
<hr>
<p>二零一六年十月三十日九时五十分许，爷爷的旅途在病床上走到了尽头，终究还是没有等到孙媳妇和四世同堂，甚至都没能认出我，意识清醒地跟我说句话。我不知道该做什么，看着监视器里没有了呼吸和心跳，感觉特别不真实。几个月前还跟我们一起吃饭喝酒的爷爷，忽然去了另外的地方。</p>
<p>我知道春夏秋冬和阴晴圆缺，也知道生老病死和轮回循环。但是站在病房中病床前，看着呼吸急促的爷爷，除了盯着监视器上闪烁着的数字，我的大脑一片空白。于我，再也无法给予；于他，再也无法接受。从高铁站赶往医院的路上，的士司机说原先的两座旧桥都被拆了，要年底才能复建完成。两座旧桥的名字也许会留下，但是它们已是不存在了，曾经的存在也不存在了。</p>
<p>奶奶信佛，今早我去敬菩萨时许下的愿望，可能还没来得及传达过去便已失去了意义。我看着爷爷曾经住过的房间，试图去寻找过往快乐与痛苦的痕迹，但现在看来都已不重要了。爷爷离开家住进医院的一个月时间，在病床上的努力和挣扎终于可以停歇了，毕竟面对死亡，每个人都只能独自上场。因为『生』的欲望，『死』往往变得艰难、痛苦与漫长。</p>
<p>最后的日子里，爷爷大约已无法说完整的话。情况好转时的喜悦与恶化时的痛苦，都只能通过眼神来传递了，直到有一天最后的一扇窗户也被关上，光越来越暗淡，接着，便被无尽的黑暗笼罩。我们再努力去呼喊，爷爷也只有条件反射的反应了。</p>
<p>爷爷心跳骤然加快我便有了不好的预感，随后各项生命指标便开始断崖式下跌，从心跳到血压再到呼吸。虽然在医生的抢救和药物的支持下从悬崖边爬了上来，但终究回天乏术。我出生时爷爷大约已开始了退休生活，虽然聚少离多，但他依然在以他的方式跟我同行。现在他停下来了，他喜爱的象棋与麻将，他晒着太阳摘过的豆芽和豆角，他抽的烟戒的烟与喝的酒，都在那一瞬间消散了。</p>
<blockquote>
<p>当我们不知道终点何在时，我们就不能真正了解和理解过程是什么；但等到达终点，这过程又已经结束了。也许只有先知才能预先站在终点说话。 – 止庵《惜别》</p>
</blockquote>
<p>正因为不知道终点在哪里，所以总会觉得黑暗过去之后便是光明，但令人绝望的是，这仅有的光明，也只是让黑暗更黑一些罢了。爷爷最后走得安详，也许是意识到自己已无力挣扎，便不再挣扎了。我倒是希望爷爷真的解脱了，毕竟就我看来，最后的日子里，剩下的只有煎熬折磨了。</p>
<p>医院报『病危』之后，前些天爷爷的眼睛竟恢复了神采，像小孩子般滴溜溜转，似乎在好奇地打量着这个世界，也许是『回光返照』吧。我不忍心看，我总觉得不去看，火焰便不会熄灭。爸爸说，爷爷之前迷迷糊糊提起要回家、下雨了收衣服和见到了他的爸爸妈妈，虽说是封建迷信，但怕是已经在经历常说的临终前『过电影』的阶段了。</p>
<p>不知道爷爷看到了什么，又想到了什么。我看到越发驼背的奶奶、穿上白衣服的父亲和一直坚强却忍不住留下泪水的姑妈，对生活和生命本身有了更真切的认识。</p>
<p>生命只有一次，很多时候一旦错过，便再无相逢之时。有什么想做的事儿就去做，有什么喜欢的人就去爱，有什么未完成的梦想就去追逐。但归根结底，健康最重要，牙缝里省不出钱，睡眠也不是无息贷款。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在病房里最大的感受不是气味和声音，而是深入骨髓的无助。监视仪不断的报警声和爷爷颤抖的心电图像永不停息的敲击，直到发条走完，一切归于寂静。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="告别" scheme="http://wdxtub.com/tags/%E5%91%8A%E5%88%AB/"/>
    
      <category term="亲情" scheme="http://wdxtub.com/tags/%E4%BA%B2%E6%83%85/"/>
    
      <category term="病房" scheme="http://wdxtub.com/tags/%E7%97%85%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>第二十周 - 像梦一样自由</title>
    <link href="http://wdxtub.com/2016/10/28/free-as-dream/"/>
    <id>http://wdxtub.com/2016/10/28/free-as-dream/</id>
    <published>2016-10-28T15:58:16.000Z</published>
    <updated>2016-10-28T23:12:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>我要像梦一样自由，像天空一样坚强。在这曲折蜿蜒的路上，体验生命的意义。</p>
<a id="more"></a>
<hr>
<p>这周特别漫长，一是因为被调到了陌生的楼层有些不适应，二是因为在研发老大的眼皮底下做项目一点都不敢懈怠。虽说这周更换了带头像的新工牌人逢喜事精神爽，但是工作和生活忽然都有了如此大的变动，很开心，却也明白更艰难的挑战要一个接一个来临了。</p>
<p>从前天真地觉得，怎么会无法平衡工作和生活呢？当自己真正开始为项目们负责之后才意识到，做需求改 bug 其实是最最简单的工作了。跨团队跨部门跨国沟通各级汇报资源整合协调努力推动项目才是最难的，也确确实实需要时间来磨练。</p>
<p>我现在能做的，恐怕就是把经手的每一件事情做到最好。遇到同一个问题，看看自己的思维方式和老司机相比有什么差距，并以此为方向去努力提高自己。就我目前的观察来看，我从研发老大身上看到的是一种骨气和自豪，能自己做就不依赖别人，遇到问题可以一针见血找到关键所在，不会被其他事情所干扰。</p>
<p>暂且抛开经验不说，这种『舍我其谁』的气势是任何一个优秀的工程师都应该具备的，既然决定了要做这件事儿，就要利用一切能利用的资源去推动，做什么没有困难呢，兵来将挡水来土掩嘛。</p>
<p>现在回头看看，这周其实颇为高产。花了一个星期把之前放了快一年的内部项目做了大概，因为之前做数据平台的时候已经积累的足够的经验，这次开新项目从架构到数据结构再到整体的思路基本胸有成竹，除了前端界面略微『复古』外，基本对自己是满意的（有机会的话会专门来写写如何一个人做项目）。周五开了个『大』会，一大早回公司订会议室准备材料，虽然比较辛苦，但是只要做的努力有价值，这都可以忽略不计。</p>
<p>从中学到了很多东西，除了再一次深刻认识到了中国、欧洲、美国做事情方式和考虑问题角度不同外，了解了更多信息之后也对商业竞争这事儿有了全新的认识。很多时候其实大家都知道彼此下一步要做什么，嘴炮可能一时有用，但是归根到底比的就是硬实力。</p>
<p>硬实力落实到技术上，其实就是研发能力和工程能力。研发有的时候可能需要灵感乍现，但是工程方面其实基本都有比较好的最佳实践。至于哪门语言是最优秀的编程语言，大团队内是否需要进行语言和框架层面的统一，可能在上古时代影响比较大。在现在这个面向 google/github/stackoverflow 编程的时代，反而是根据团队现状以及具体的工程需求来决定到底要用什么样的技术。如果硬要夹带点私货的话，我依然坚持动态语言不适合大项目这个看法。凡事都有个度，过犹不及呀。</p>
<p>另外一个有意思的事情是我加入了 GUTMA(如下图所示)下属的 UTM 架构工作组，大约是加入其中的第二个中国人。自己都难以想象，居然在几个月的时间内从一个无知懵懂的学生成为操心大家头顶上这片天空的工作人员。真是『一个人的命运当然要靠个人奋斗，也要考虑历史的行程』。</p>
<p><img src="/images/14776720002950.jpg" alt=""></p>
<p>说没有压力是骗人的，每天上下班的走路和跑步就是我最好的解压方式了。有的时候绕一点路看起来是更远了，其实是更近了。</p>
<p>不由得想起网友的问题：回国还是留美？于我，回国，为了更精彩的人生。</p>
<p>我要像梦一样自由，像大地一样宽容。在这艰辛放逐的路上，点亮生命的光芒。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我要像梦一样自由，像天空一样坚强。在这曲折蜿蜒的路上，体验生命的意义。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>异化的一千零二十四</title>
    <link href="http://wdxtub.com/2016/10/24/unhuman-1024/"/>
    <id>http://wdxtub.com/2016/10/24/unhuman-1024/</id>
    <published>2016-10-24T15:11:40.000Z</published>
    <updated>2016-10-24T23:51:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>编程其实是一个『异化』的过程，但是程序员绝不应以此为由活在梦中，而应该像『喜剧之王』中周星驰的一句话：其实，我是一名工程师。</p>
<a id="more"></a>
<hr>
<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>计算机最初的原型几乎都是手摇式计算器，它们能做的基本上只是四则运算。但是无论是从帕斯卡到莱布尼兹再到巴贝奇，他们的心都很大，想着的是利用机器模仿人类的思维。</p>
<p>近年来，因为计算能力得到巨大提升而成为耀眼领域的深度学习，其实从某种意义上来说，打了人类自己的脸。这宣告着我们试图把人类思维公式化的尝试式微，或者说，思维本身在人类目前的技术水平下，根本无法找到一条类似质能方程 $E=MC^2$ 这样的公式。从计算机视觉到人工智能，深度学习都快速达到了原本的方法难以企及的高度。</p>
<p>不觉得很奇妙吗？人类思维这个黑盒，想要通过制造白盒来了解和模仿自己的黑盒，最终却造出来了另一个黑盒。就拿人脸识别来说，用深度学习可以做到极低的错误率，但问题是我们还是不能精确知道人是如何认出他人的。</p>
<h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><p>现代计算机因为硬件的设计是建立在二进制这个地基之上的，归根结底 0 与 1 就是一切。因为二进制，另一套思维方式被建立了起来，生活中我们提到『凑个整』，一定是凑成诸如 $10,10^2,10^3,10^4$ 这样的『整』，但是对于程序来说，凑个整就是 $2^8(256),2^{10}(1024)$，这也正是 10 月 24 被当做『程序员节』的来历（之一）。</p>
<p>这就是『异化』的开始，想成为各种高手，一定是需要能以计算机的方式去思考问题的，而这种思考角度本身也潜移默化影响着每一个程序员。借用 Robin 在<a href="http://mp.weixin.qq.com/s?src=3&amp;timestamp=1477351573&amp;ver=1&amp;signature=CqVs5kozdnyTKNNDgdUIoIiqLLDaTqeY8pEZPIEvt7KvBodz0RsUa-MW9KBtuHQ5TpdNgghnmVmUnwqVn1xHFPO8*tJRum99YNWEUeLsnAFyIoAg46S-mFtAQYdBbHorfEpqPBi0WnhT2gmr*AYhLQJ7bke9mAFHIe8cJT7djJU=" target="_blank" rel="external">从我做起 - 抵制1024程序员节</a>一文中的描述：</p>
<blockquote>
<p>主流的程序员往往是这样的「性格单纯、待人以诚；高智商，对技术有追求，孜孜不倦的学习；工作认真负责，任劳任怨，拙于表现自己；生活简单，对家庭负责。」</p>
</blockquote>
<p>但是当一次又一次听到别人跟我说『没想到你居然是程序员』的时候，我意识到了问题的严重性 —— 大家眼中『程序员』的形象并不怎么样。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>在学校这个相对封闭的环境中，因为总有机会让大家互相了解，所以因为『贴标签』带来的刻板印象相对来说会好一些。但是在工作和生活中，可能一次『装疯卖傻』就会让一部分人认为你是『真疯真傻』，可能一次疏漏就会给人感觉你是一个不太靠得住的人。</p>
<p>所以像程序员这样孜孜不倦自黑的群体不多见了，圈子内自黑是趣味，但是慢慢传到圈外，就不是『自黑』，是『真黑』了。从中关村（海淀黄庄）地铁站的光头率到各类和程序员相亲的帖子，程序员在自嘲的同时，也把自己的『异化』给放大了。</p>
<p>试想，公司请 AV 女性来『鼓励』程序员，员工们吃瓜群众乐在其中，但是在外人看来，少不了『噢，程序员好这口』的感觉。一听到程序员，就想到『猥琐、好色、古板、死宅』的绝不是少数，至于『钱多话少死的早』，其实都算是比较客气的说法了。</p>
<p>但问题是我们并不是这样的。</p>
<h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>如果可以的话，我想甩掉程序员的名号。我是一名工程师，我的工作是发现问题、勇于尝试、解决问题。工程师不想一辈子卖糖水呢，而是要一起去改变世界。</p>
<p>工程师可以靠谱敢担当，可以顽强有梦想，可以有一身腱子肉、可以大方得体、可以有礼貌风度。最近的热门电视剧中的『计算机学霸』帅气小鲜肉，总算是给我们扳回了一局，工程师同样也可以成为偶像。</p>
<p>最好的工程师一定不是不吃人间烟火的，而是从群众中来，到群众中去的。</p>
<p>毕竟，我是一名工程师啊！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编程其实是一个『异化』的过程，但是程序员绝不应以此为由活在梦中，而应该像『喜剧之王』中周星驰的一句话：其实，我是一名工程师。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="工程师" scheme="http://wdxtub.com/tags/%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="1024" scheme="http://wdxtub.com/tags/1024/"/>
    
  </entry>
  
  <entry>
    <title>第十九周 - We Can Be Heroes</title>
    <link href="http://wdxtub.com/2016/10/22/we-can-be-heroes/"/>
    <id>http://wdxtub.com/2016/10/22/we-can-be-heroes/</id>
    <published>2016-10-22T02:31:20.000Z</published>
    <updated>2016-10-22T04:44:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>I remember, when the days are tough and I heard distant thunders. I was so afraid that I could not see what’s right.</p>
<a id="more"></a>
<hr>
<p>每次去看《湄公河行动》都会被片尾曲深深打动，终于在票房破十亿的时候在官方微博发布了『We Can Be Heroes』这首歌，于是就成了日常单曲循环的曲目。之所以喜欢，唱得好是一方面，但最重要的是歌词。不像大部分主旋律一路高歌猛进，歌词描述的是在迷茫和恐惧中慢慢找到方向，或者说正是因为迷茫，所以才更显得坚定。</p>
<p>临近周末又来了台风，不过这次是从惠州登陆的，所以翘首以盼的红色警报最终并没有出现，好在风雨并不算太大。钢筋混凝土把人与自然隔离，人们却要用落地玻璃窗营造一种贴近自然的假象。外面风雨再大，传进来的大约也只有声音，午休时躺在行军床上看着窗外雨水交织，莫名有种冲动，架个滑翔伞在大雨中穿梭，真正彻底冲刷一次自己。</p>
<p>台风来的前一天，出人意料的是好天气，便抓紧机会跑了一次步。大工地一般的南山区是断然没有『空山新雨后』的感觉的，硬要说有，那只能是『天气晚来秋』了。台风走的晚上，雨停了风小了，穿着拖鞋看着满地树叶，心想着要是能有个地方看星星多好。</p>
<p>比天气变化更快的是工作的变化，我决定仿写一段话来表达我的感觉：</p>
<blockquote>
<p>人呐就都不知道，自己就不可以预料。一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程，我绝对不知道，初出茅庐怎么把我选去面圣了，所以领导同志跟我讲话，说『中央都决定啦，你停下手上的工作，来做这个紧急任务』。实在也不是谦虚，我连另请高明都还没来得及说，所以后来我就在心底念了两句诗，叫『苟利国家生死以，岂因祸福避趋之』。</p>
</blockquote>
<p>于是我就从原来的楼层往上搬了七层，开始了字面上和实际上『面圣』的日子。实话说，感觉很奇怪，原先和其他开发在一起打打闹闹敲代码，忽然把我放到一堆分管各个业务的老大中间，看着她们业务繁忙人来人往一会接一个会，恐怕我还需要适应个几天。</p>
<p>同事帮我总结了一下，来公司之后几乎都是在一个人负责整个项目，一个好处是少了很多沟通成本，另一个好处（也可能是坏处）是所有的责任都只有自己承担，丝毫没有甩锅的机会。当然，成长也是很快的，必须去思考如何把事情做得更好，如何跟各个部门合作，如何让项目顺利走下去。</p>
<p>现在有这么一个极好的机会可以近距离前辈和老司机们是如何工作和思考的，甚至还有近水楼台的优势可以方便请教。虽然肯定是要比之前工作强度大，但仔细想想，这是很好的展示自己能力的机会，要好好利用每一次机会，用实际行动证明自己是值得信任且能把事情做到超出预期的。当然不是说要去可以表现什么的，而是真正要走心，哪怕别人感受不到，至少自己交出去的工作是对得起自己的，足矣。</p>
<p>最后，不由得想起了一本名字不太正经但是内容无比纯真的小说<a href="http://wdxtub.com/2014/09/11/with-ran-jing-clip/">《和空姐同居的日子》</a>的作者在后记里写的这么一段话：</p>
<blockquote>
<p>每个人都有发表自己观点的权力，同样我也有。三年之后的我依旧很“愚蠢”地继续相信现实中的某个角落会存在美好的事物，用这样的心态继续写这个故事。 希望这个故事可以继续感动和我一样“愚蠢”的朋友，并且让更多的人“愚蠢”起来。</p>
</blockquote>
<p>从高中起一直翻来覆去看这本书的我，怕是很长一段时间会这样『愚蠢』下去吧，也挺好的。</p>
<p>A fighter fights his fight. A dreamer dreams his dream. Cause we can be heroes, Sometimes.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I remember, when the days are tough and I heard distant thunders. I was so afraid that I could not see what’s right.&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="变化" scheme="http://wdxtub.com/tags/%E5%8F%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>W.I.S.E. 计划</title>
    <link href="http://wdxtub.com/2016/10/17/wise-plan/"/>
    <id>http://wdxtub.com/2016/10/17/wise-plan/</id>
    <published>2016-10-17T13:09:10.000Z</published>
    <updated>2016-10-17T15:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>W.I.S.E. 的全称是 Wdxtub’s InSight Engine，是一个我做了快五年的梦，现在，我终于准备好了。</p>
<a id="more"></a>
<hr>
<p>W.I.S.E. 是一个引擎，通过收集互联网中的相关信息和我个人的各种行为，帮助我高效完成『信息筛选 -&gt; 知识提取 -&gt; 洞悉洞察』这一整套流程，辅助我把自己的思维强度和学习能力提高到更高层次。</p>
<p>正如名字所暗示的那样，这是一个非常个性化的应用，对使用者有比较高的要求。在基本的功能完成之后，我会邀请一些小伙伴参与内测，看看这套流程是否真正有效。具体的开发过程我也会以系列文章的形式分享给大家，可以从中以下知识：</p>
<ul>
<li>极简主义的思想及行为指南</li>
<li>Linux / Unix 的基本概念和常用命令</li>
<li>自然语言处理、推荐系统、爬虫、知识图谱、数据可视化</li>
<li>Web 服务、关系型与非关系型数据库、缓存、安全、网络模型</li>
<li>接口设计、客户端开发、SDK 接入、界面与交互设计</li>
</ul>
<p>让我们先跑一下题，看看为什么我会想要做 W.I.S.E. 这个项目</p>
<h2 id="W-I-S-E-前世"><a href="#W-I-S-E-前世" class="headerlink" title="W.I.S.E. 前世"></a>W.I.S.E. 前世</h2><p>无论是本科还是研究生，一到要决定毕业设计的时候，我那颗不务正业的心就开始沸腾。虽然一直以来都在做图形图像相关的研究，但说来奇怪，学生生涯中唯二的毕业论文都跟图形图像没有半点关系。本科的时候做的是自动问答引擎，比方说我输入『中国的首都是哪里』，那么引擎给出的答案应该是『北京』。研究生的时候做的是一个叫 WKK 的东西，全称是 Wdx’s Knowledge Kit，当时我沉醉于构建自己的知识图谱，满脑子想着是如何形成『信息/知识闭环』。</p>
<p>当然，这两次尝试都不能算成功，堪堪做到可 demo 的程度，便被毕业的假期勾走了魂儿。现在想想，如果说本科的尝试带我走入了知识表示的大门，那么研究生的尝试则是一次结合极简主义的化学反应。</p>
<p>WKK 是一个很有野心的项目（感兴趣的朋友应该从附录就能看得出来），试图通过一系列智能化处理把一整套极简主义的行为方式融入到日常的生活学习中，尤其是希望在我很在意的几个方面（笔记、写作、读书）上形成『闭环』。因为毕业设计的时间比原先计划的少了半年，很多工作仅仅做到了『能用』，离『好用』还有一大段距离。本想着找时间完善，无奈直到今天都没有鼓起勇气重新开始。</p>
<p>WKK 留给我的『遗产』很多，主要有三部分：</p>
<p>第一是 JARVIS 这个组件（就是钢铁侠里的智能助理的名字），包括中英文的自然语言处理、笔记和书籍的推荐以及互联网信息抓取三大功能。自己做过一次，现在对于自然语言处理、推荐系统和爬虫都有了一定认识。</p>
<p>第二是笔记系统，也就是结合文件/文件夹，基于 Markdown 和 GTD 的一套体系。虽然这个系统随着时间的推移基本上已经完全变了模样，但是一切的开始还是要源于 WKK 这个项目。Github 中从 WDXPeak 到 Note 1.0/2.0/3.0，都可以看做是这套系统的延伸。</p>
<p>第三是各种功能模块，比方说 Kindle/Evernote/Web 相关的各种脚本以及基本的推送服务。尤其是 Kindle 相关脚本，我现在依然在使用。</p>
<p>虽然 WKK 早已停止开发，但是对于更高效的信息处理、知识获取和能力转化的追求从未停止。最近一直在做数据平台相关的工作，今天上班路上思考<a href="http://wdxtub.com/2016/10/13/data-scientist-engineer-guide/">《数据科学工程师指南》</a>一文中提到的『自我数据管理平台』的时候忽然想起 WKK。</p>
<p>于是，W.I.S.E. 这个新项目就此诞生。</p>
<h2 id="W-I-S-E-今生"><a href="#W-I-S-E-今生" class="headerlink" title="W.I.S.E. 今生"></a>W.I.S.E. 今生</h2><p>起名字是软件工程中最难的问题，推敲许久，终于确定了使用 W.I.S.E. 作为项目的名称，一来是自带『聪明』的意思，二来其全称 Wdxtub’s InSight Engine 恰好特别符合项目的主题。InSight 可以看作是 Knowledge 的下一形态，意味着是 WKK 的继承者和超越者，Engine 则说明这是一个引擎（对，又回到了本科毕业设计的思路），给各种应用提供强劲动力。</p>
<p>预计的技术栈为：</p>
<ul>
<li>Vue.js</li>
<li>Go, Beego</li>
<li>Elasticsearch, MySQL, Redis</li>
<li>Nginx</li>
<li>Web/Mac/iOS/Android/Windows<ul>
<li>预计很长一段时间都只会有 Web 版本，后面的平台看心情</li>
</ul>
</li>
</ul>
<p>核心功能有：</p>
<ul>
<li>信息聚合：博客、微博、豆瓣、知乎、Kindle</li>
<li>内容分析：笔记、日志、书籍</li>
<li>推荐系统：音乐、电影、书籍</li>
<li>生活相关：饮食、习惯、运动、重要事件/节点追踪</li>
</ul>
<p>看起来内容很多，其实这都是『闭环』中的一部分，现在没有了时间限制，就一点一点慢慢做吧。更多详情会同步更新到博客和 Github 中，今天就算是正式启动了！</p>
<h2 id="附录-阐述-WKK-思想的文档"><a href="#附录-阐述-WKK-思想的文档" class="headerlink" title="附录: 阐述 WKK 思想的文档"></a>附录: 阐述 WKK 思想的文档</h2><h3 id="Wdxtub’s-Knowledge-Kit"><a href="#Wdxtub’s-Knowledge-Kit" class="headerlink" title="Wdxtub’s Knowledge Kit"></a>Wdxtub’s Knowledge Kit</h3><p>This is a local machine tool that help me collect valuable information from the specific web sources, manage all my notes and turn them into knowledge.</p>
<h4 id="Background-Why-I-make-WKK"><a href="#Background-Why-I-make-WKK" class="headerlink" title="Background - Why I make WKK"></a>Background - Why I make WKK</h4><p>The quick development of computer and Internet bring us a brand new life style. After several years of “smart” life, I feel frustrated to find out that I’m trapped in a digital castle which has lots of beautiful rooms. The rooms are so beautiful that most of the time I don’t want to leave. But if one day I lose my smart phone or my computer breaks down, the great castle disappears and life becomes really tough.</p>
<p>On one hand, my castle is my home that makes me feel comfortable. But on the other hand, the castle is my prison which keeps me inside. The longer I have lived there, the harder I can get rid of it.</p>
<p>In my opinion, instead of becoming a beautiful castle that lock me down, those smart devices should be the tools that help me lead a life with more choices and opportunities. As it is, I make this tool to give myself more freedom to be who I am. It is the tool that learns to suit me, not I learn to use the tool.</p>
<p>With the help of WKK, I want to connect all my digital devices with ease and find the relations between all my notes as well as ebooks. It is a magic box that mix books, news, websites and notes together and organize them in a natural way so that I can search and unify them easily. This is the process of building my framework of knowledge.</p>
<h4 id="Philosophy-What-is-the-main-focus-of-WKK"><a href="#Philosophy-What-is-the-main-focus-of-WKK" class="headerlink" title="Philosophy - What is the main focus of WKK"></a>Philosophy - What is the main focus of WKK</h4><p>The main focus of WKK is Minimalism. It is a different life style from what I lead now.</p>
<p>Minimalism is a tool that can assist you in finding freedom. Freedom from fear. Freedom from worry. Freedom from overwhelm. Freedom from guilt. Freedom from depression. Freedom from the trappings of the consumer culture we’ve built our lives around. Real freedom.</p>
<p>So I want to make WKK as simple and elegant as possible, the less dependency the better. In that case, I can put more energy to those things that really matters.</p>
<p>Besides minimalism. There are another six keywords for WKK:</p>
<p>Personal, Smart, Automatic, Efficient, Sharing, Creating</p>
<p>Minimalism has helped us:</p>
<ul>
<li>Eliminate our discontent</li>
<li>Reclaim our time</li>
<li>Live in the moment</li>
<li>Pursue our passions</li>
<li>Discover our missions</li>
<li>Experience real freedom</li>
<li>Create more, consume less</li>
<li>Focus on our health</li>
<li>Grow as individuals</li>
<li>Contribute beyond ourselves</li>
<li>Rid ourselves of excess stuff</li>
<li>Discover purpose in our lives</li>
</ul>
<h4 id="Reason-Why-WKK-is-good"><a href="#Reason-Why-WKK-is-good" class="headerlink" title="Reason - Why WKK is good"></a>Reason - Why WKK is good</h4><ol>
<li>Offline. My knowledge base doesn’t rely on the Internet. The core of WKK works even without Internet. So I don’t have to worry about the environments. Battery is the limit.</li>
<li>Lightweight. The minimal requirements is just a text editor. I don’t need specific software to use WKK. Python is the only requirement for running most of the features of WKK. Less dependencies, Longer battery time.</li>
<li>Elegant. With the help of markdown and pandoc, I can generate beautiful documents with markup plain text. Still no need to use other applications, just a text editor. With a better note mechanism, I can take note with more efficiency and transfer to knowledge more easily.</li>
<li>Automatic. Most of the dirty work will be done automatically. WKK is the tool that make me feel better.</li>
<li>Portable. No private format or strange arrangement. WKK uses directories and files to manage everything. So it’s highly portable.</li>
<li>Smart. WKK will learn my habits and find useful information related to specific topics. I don’t have to waste so much time on filtering informations everyday.</li>
</ol>
<h4 id="Technique-What-is-the-Core-of-WKK"><a href="#Technique-What-is-the-Core-of-WKK" class="headerlink" title="Technique - What is the Core of WKK"></a>Technique - What is the Core of WKK</h4><p>As WKK need to handle Chinese and English at the same time. A robust method is what I need. The core of WKK is a high speed web crawler, a directory-based local server and a analyzing/recommending system. Most of the codes are written in python which means I can enable/disable them easily. Here is some of the package I use for WKK:</p>
<ul>
<li>Scrapy: The web crawler</li>
<li>Flask: The web framework</li>
<li>Jieba: Chinese words segmentation</li>
<li>NLTK: Language toolkit from Stanford</li>
<li>word2vec</li>
<li>Pattern</li>
<li>Gensim</li>
<li>Scikit-learn</li>
<li>PyBrain</li>
<li>NumPy, SciPy, Matplotlib</li>
</ul>
<p>And several other packages</p>
<h4 id="Feature-What-can-I-do-with-WKK"><a href="#Feature-What-can-I-do-with-WKK" class="headerlink" title="Feature - What can I do with WKK"></a>Feature - What can I do with WKK</h4><p>Here are the features that WKK support:</p>
<ul>
<li>Procedure<ul>
<li>Collect: Notes, RSS, Wiki, News, Social Network</li>
<li>Improve: Detect Categories, Extract Keywords, Generate Label</li>
<li>Arrange: Topic Analysis, Note Linking</li>
<li>Connect: Build Knowledge Base, Find Connections</li>
</ul>
</li>
<li>Markdown<ul>
<li>Generate Catalog</li>
<li>Convert to mobi/epub/pdf/html</li>
<li>Customized CSS</li>
<li>Support Latex math expressions</li>
<li>(TODO)other markup language support</li>
</ul>
</li>
<li>Note System<ul>
<li>HTML to Markdown(from the Internet)</li>
<li>Link to different notes</li>
<li>Theme note, consist of several notes and form a key idea</li>
<li>Topic Crawler, update related topics from rss/blog/weibo everyday</li>
<li>Auto Tag</li>
<li>Auto Keywords</li>
<li>Similar Note</li>
<li>GTD style arrangement(Inbox Folder, Knowledge Folder)</li>
<li>Note Rating</li>
<li>Import/Export to different application(e.g. evernote)</li>
<li>Recommend related books according to the content of the notes</li>
<li>Generate Knowledge Graph</li>
<li>Find keywords for ebooks</li>
</ul>
</li>
</ul>
<h4 id="Resource-Something-that-make-WKK-even-better"><a href="#Resource-Something-that-make-WKK-even-better" class="headerlink" title="Resource - Something that make WKK even better"></a>Resource - Something that make WKK even better</h4><p>Here is the list that support WKK:</p>
<ul>
<li>NLTK</li>
<li>Flask</li>
<li>Machine Translation</li>
<li>Note cluster</li>
<li>Multi-document generic text summarization</li>
</ul>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>WKK is the main digital tool for minimalism life. I used to use the following applications to take notes record my ideas and arrange my ebooks:</p>
<ul>
<li>Evernote: Collect notes from Internet and wechat</li>
<li>Wunderlist: GTD tool</li>
<li>Calibre: ebook management</li>
</ul>
<p>But these days I has so many digital devices:</p>
<ul>
<li>Android Phone</li>
<li>iPhone</li>
<li>Windows Phone</li>
<li>iPad</li>
<li>Kindle</li>
<li>Windows Notebook</li>
<li>Macbook</li>
</ul>
<p>It is so difficult to find a tool that can connect those different platforms together with user-friendly applications. A more common situation is that some of them work well on some platform but different platforms have their own logics which make things complex.</p>
<p>What’s more, with the mentioned applications, different kinds of data are separate. They are not connected! If notes are not connected, how can I extract the relations between them. If there’s no relations, how can I turn them into knowledge?</p>
<p>So what do I need?</p>
<ul>
<li>A directory-based markdown(plain text) note system<ul>
<li>I can take notes, write blogs, etc</li>
<li>Don’t need to install anything to use the basic function. A portable disk can be my whole knowledge base</li>
</ul>
</li>
<li>All platforms covered import and export toolkit<ul>
<li>I can easily continue my work in different devices and situations</li>
<li>Easily integrated with cloud service such as Github and Dropbox</li>
</ul>
</li>
<li>Automatic Information Crawler<ul>
<li>Given specific topic, find related books and news</li>
<li>Concept definition from wiki</li>
</ul>
</li>
<li>Relation Finder<ul>
<li>Find similar notes or web information</li>
<li>Extract Keywords</li>
<li>Logic Combiner among different topics</li>
</ul>
</li>
</ul>
<p>This is why I make WKK.</p>
<h3 id="Philosophy"><a href="#Philosophy" class="headerlink" title="Philosophy"></a>Philosophy</h3><p>Minimalism is a tool used to rid yourself of life’s excess in favor of focusing on what’s important so you can find happiness, fulfillment, and freedom.</p>
<p>When I know minimalism, it seems that what I have been pursuing for such a long time finally got an answer. So I want to make WKK in a minimalism way.</p>
<ul>
<li><strong>Personal</strong>: Except for the common language database from the internet, all the training data is my notes, my reading as well as my notes. As it is, WKK will be a very personal toolkit that knows your language pattern and favorite topics.</li>
<li><strong>Smart</strong>: The best part of WKK is that the longer I use it, the better it understands me. With the help of researches on big data, it can give me useful recommendations related to the topics and themes I’m interested in.</li>
<li><strong>Automatic</strong>: Tools are the helper that do most of the dirty work for human. So is WKK. Most of the features can work automatically as if it doesn’t exist. I can just use it in a natural way. The only thing I need to do is focusing on learning and thinking. The rest will be handled by WKK automatically.</li>
<li><strong>Efficient</strong>: There are so much information every moment everyday: Mail, News, Twitter, Facebook, Weibo, Wechat, etc. WKK helps me to gather all the information together and gives me a daily report so that I don’t need to waste so much time on filtering information. WKK did it for me.</li>
<li><strong>Sharing</strong>: It’s so easy to share my notes or knowledge with others with the help of WKK. Here is the supported formats: html, epub, mobi, azw3, pdf, jpg, email, etc.</li>
<li><strong>Creating</strong>: With the knowledge graph generated by WKK. I can find related topics and themes easily. With new connections, new thoughts and ideas can always be available in my brain.</li>
</ul>
<p>Here is the philosophy of WKK, also the philosophy of minimalism in my mind.</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://github.com/wdxtub/wise-api" target="_blank" rel="external">wdxtub/wise-api</a></li>
<li><a href="https://github.com/wdxtub/wkk" target="_blank" rel="external">wdxtub/wkk - wdx’s knowledge kit</a></li>
<li><a href="https://github.com/wdxtub/wkk/wiki" target="_blank" rel="external">wkk wiki</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;W.I.S.E. 的全称是 Wdxtub’s InSight Engine，是一个我做了快五年的梦，现在，我终于准备好了。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="开源" scheme="http://wdxtub.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="个人" scheme="http://wdxtub.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>我与匹兹堡</title>
    <link href="http://wdxtub.com/2016/10/16/me-and-pittsburgh/"/>
    <id>http://wdxtub.com/2016/10/16/me-and-pittsburgh/</id>
    <published>2016-10-16T08:28:30.000Z</published>
    <updated>2016-10-16T16:53:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>今晚的月亮特别圆特别亮，不知怎么的，忽然想起在匹兹堡的日子，作此文以念。</p>
<a id="more"></a>
<hr>
<p>一座城市是否宜居，只有真正住过一段时间才知道。匹兹堡很慢，修水管要一个多月；匹兹堡很快，一场大雨就可以入冬。匹兹堡很坚硬，依稀留有钢铁之城的印记；匹兹堡很柔软，像一头扎进雪堆。匹兹堡很悠闲，花儿自在绽放；匹兹堡很紧张，学生们行色匆匆。</p>
<p>关于匹兹堡，回忆很多。也许是因为异国他乡，也许是因为小半年的冬天，也许怀念的是那时候的自己，那时候的心情。</p>
<p>我记得每周去超市的路，有下雨后的泥泞，有大太阳的坚硬，有雪化又冻结的冰。路上的小学校与校车，路上的小公园与秋千，路上的棒球场与亭子。贪心地买太多东西，一路吭哧吭哧扛回家，往冰箱里放的时候却比谁都开心。看着各种各样的零食哪个都想试一试，最后还是觉得辣芒果最有意思。</p>
<p>我记得春夏秋冬，走过跑过太多次，看着绿叶变成红叶，看着红叶铺满地，然后便是寒冬。半年肃杀后迸发的春天特别美好，不怕人自顾自找东西吃的小鸟，呆头呆脑爬上树的松鼠，小山坡上闲散找东西吃的鹿，草坪中争相抬头的小黄花，夹杂着毛绒绒随风飘摇的蒲公英，落花似雪，雪化了，春天才真的开始了。能清楚回想起看得见摸得着的生机盎然，真想就这么在路边坐一下午。</p>
<p>我记得 Fifth 6224，我记得不好开门的钥匙，每次要闭着眼睛用心感受才能开开门；我记得四个炉子，下面两个好用，右上角的常常打不着；我记得帐篷里的日日夜夜；我记得用纸箱子堆成的桌子和电视架。</p>
<p>我记得要做 71D 和 71B 回学校；我记得学院楼的天台和负零点五层的休息室，大家聚在一起学习打闹，一言不合就去草坪上飞飞盘。我记得像迷宫一样在各个楼之间穿梭的路线；我记得在教授家的晚餐；我记得中国超市每个货架的位置；我记得各种在努力的朋友。</p>
<p>我记得华盛顿山的夜景和日出；我记得沿着河走的微风；我记得一个人在大巴上饿着的肚子；我记得大雪后堆起的雪人；我记得隔一两个月就换一次的发型，尝试了光头和莫西干头。</p>
<p>认识了很多人，走过了很多地方，发现很多想看的景色，千辛万苦真的只是为了看一眼，去呼吸一下，就足够了，对吧。</p>
<p>不得不说，真是有些想大家了，尤其是我两个可爱的室友，找时间再给你们做一顿饭吧。</p>
<p>附 weirang 的看图写话节选。</p>
<p><img src="/images/weirang2.jpeg" alt="weirang2"></p>
<p><img src="/images/weirang3.jpeg" alt="weirang3"></p>
<p>今天看看，仿佛又回到了那个搭着帐篷的客厅，摊在懒人沙发上，想让时间停下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚的月亮特别圆特别亮，不知怎么的，忽然想起在匹兹堡的日子，作此文以念。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="生活" scheme="http://wdxtub.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="匹兹堡" scheme="http://wdxtub.com/tags/%E5%8C%B9%E5%85%B9%E5%A0%A1/"/>
    
      <category term="回忆" scheme="http://wdxtub.com/tags/%E5%9B%9E%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>第十八周 - 和自己赛跑的人</title>
    <link href="http://wdxtub.com/2016/10/15/compete-with-myself/"/>
    <id>http://wdxtub.com/2016/10/15/compete-with-myself/</id>
    <published>2016-10-14T16:07:10.000Z</published>
    <updated>2016-10-14T17:05:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>人有时候需要一点点刺激，人有时候需要一点点打击，在那时候我们身边都有一卡车的难题，不知道成功的意义就在超越自已。</p>
<a id="more"></a>
<hr>
<p>七天到底有多长！国庆的七天像纳米，国庆后的七天像光年。翻看自己的朋友圈和微博，发现这周的生活已经退化到只剩下跑步和写文章，于是拉着同事去日式甜品屋喝清酒，可惜略淡，不够消愁。</p>
<p>天气变凉，跑步上班终于成为了可能。穿着小背心，不跑那么快，也不会出太多汗，到公司换件衣服就行。到下班肌肉刚好恢复，再跑步下班，轻松愉快。工作间歇做俯卧撑计划也继续坚持着，今天终于突破了 300 大关。新作息适应了大半周，算是找到了比较好的节奏。</p>
<p>目前暂定是：周一周五走路上班，周二三四跑步上下班，配上每天 300 个俯卧撑，其他可以灵活安排。十点半左右睡觉，五点半左右起床，七点半左右动身去公司。具体效果怎么样，坚持个六周看看。</p>
<p>今天因为负责的系统集中爆发了几个大问题，折腾到十点多才下班。这周除了忙里偷闲完善和重构了另一个项目的 Go 代码外，基本都在还之前的技术债了。痛定思痛大约是</p>
<ul>
<li>第三方服务是不靠谱的，动不动改个字段什么的，让人欲哭无泪</li>
<li>系统设计好是非常干净的，增加新功能和维护旧功能应该都不需要太多改动</li>
<li>重构系统一定要从底层数据开始，大部分系统的根源问题就是数据结构设计太过随意</li>
<li>塞翁失马，借此机会把系统的性能和稳定性以及文档和流程的规范性都提高了几个档次。正所谓好地基才能盖高楼</li>
<li>常用的动态语言我都撸了个遍，写代码的时候特别分裂，蛇形驼峰傻傻分不清楚。但是十八般武艺即使稀松，也比不会好哇，至少能解决问题</li>
<li>又要当测试又要当运维又要当产品经理还要被知识产权部门借去干活，感觉身体被掏空，这里有很多东西值得学习，我得慢慢消化消化</li>
<li>摸爬滚打中依稀看到了发展方向，在这个青黄不接的阶段，只能一个人当五个人用了</li>
<li>多看经典计算机类书籍真的是能少走太多太多弯路，很多糟糕设计不是因为没经验，就是因为书读得太少，思考得太少</li>
<li>低水平的争论毫无意义，无非是在很糟糕和一般糟糕中选择。正确的方式是不管他们，直接拿出一个优秀的设计。这么说，很多人的能力和态度还不足以认识到优秀和槽糕之间的差距</li>
<li>重复造轮子是颇为吃力不讨好的事情，但是如果真的觉得自己能造出更好的轮子，那么果断不要妥协</li>
</ul>
<p>最后说说写书的进度吧，初稿的网站基本搭建完成，在慢慢更新中。不过光第一章就重写了三次了，果然到第三个版本自己才比较满意了，虽然这几乎占据了我所有的业余时间，不过能有机会真正去做好一件事情，还是很令人激动的。重写的过程也是重新思考的过程，我终于找到了一条和绝大多数课本不一样的路，希望能带来一点新意。</p>
<p>我们都是和自己赛跑的人，为了更好的未来拼命努力，争取一种意义非凡的胜利；为了更好的明天拼命努力，前方没有终点，奋斗永不停息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人有时候需要一点点刺激，人有时候需要一点点打击，在那时候我们身边都有一卡车的难题，不知道成功的意义就在超越自已。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="七天" scheme="http://wdxtub.com/tags/%E4%B8%83%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>数据科学工程师指南</title>
    <link href="http://wdxtub.com/2016/10/13/data-scientist-engineer-guide/"/>
    <id>http://wdxtub.com/2016/10/13/data-scientist-engineer-guide/</id>
    <published>2016-10-13T12:50:32.000Z</published>
    <updated>2016-10-13T12:51:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司的数据部门通常有三种角色：数据科学家、数据工程师和架构工程师，但许多事实证明这样的分类方法既不科学也不高效。结合工作中的经验，我认为『数据科学工程师』这一角色才是发展方向。这里我们来聊聊什么是，以及如何成为一个优秀的数据科学工程师。</p>
<a id="more"></a>
<hr>
<h2 id="为什么需要数据科学工程师"><a href="#为什么需要数据科学工程师" class="headerlink" title="为什么需要数据科学工程师"></a>为什么需要数据科学工程师</h2><p>关于数据科学部门的现状，<a href="https://mp.weixin.qq.com/s?__biz=MzA4OTk5OTQzMg==&amp;mid=2449231402&amp;idx=1&amp;sn=8de7356f8ccfa65ebfd0ae50b37a98f8" target="_blank" rel="external">《工程师要不要写ETL？——教你构建高效的算法/数据科学部门》</a>一文已经把最大的痛点写了出来，</p>
<p>总结归纳一下这部分，简单来说就是『数据科学家』没有工程思维，『数据工程师』没有统计思维，『架构工程师』成了运维人员。大家的目标都不一致，整个部门运作起来摩擦力当然是巨大的。</p>
<p>如何解决这个看似无解的问题呢？上文中提出的方案是工程师制造积木，数据科学家拼积木，但是这对数据科学家和工程师本身都提出了极高的要求，对于小团队来说，也很难找出一条分界线来划分科学家与工程师。</p>
<h2 id="什么是数据科学工程师"><a href="#什么是数据科学工程师" class="headerlink" title="什么是数据科学工程师"></a>什么是数据科学工程师</h2><p>我决定换一个思路，与其划分边界，不如模糊边界。于是，数据科学工程师这个角色就成了自然而然的选择。那么数据科学工程师的基本要求是什么呢？至少应该满足下面的要求，并在某一方面有深入思考与实践：</p>
<ul>
<li>对业务逻辑和过程的理解和参与</li>
<li>对平台、服务和框架工作机制的基本理解</li>
<li>能够在已有系统的条件制约下，针对具体问题，利用数据给出解决方案</li>
<li>有足够的工程思维，在设计解决方案的时候考虑到性能、抽象、泛化以及复用</li>
<li>如果是偏工程的，那么在开发过程中需要考虑到数据上可能的需求</li>
<li>如果是偏数据科学的，那么在数据的整个生命流程能够重复利用平台和服务</li>
<li>数据全栈，从 ETL 到最终的数据分析每一步都要参与都能参与</li>
</ul>
<p>这样一来，每个人都能互相理解和认同彼此的工作，即使人数不多，也足以成为一支极具战斗力的团队。依照个人在不同领域的优势进行扬长避短，而不是利用固定的角色来限制发展。</p>
<p><strong>但是，这个角色的门槛非常高，需要在学术界和工业界都有一定经验，更需要有一定的商业嗅觉，最重要的是一颗开放且不断学习的心。</strong></p>
<h2 id="如何成为优秀的数据科学工程师"><a href="#如何成为优秀的数据科学工程师" class="headerlink" title="如何成为优秀的数据科学工程师"></a>如何成为优秀的数据科学工程师</h2><p>首先要强调的是，全知全能的人大约是不存在的，放到数据科学工程师这里同样如此，本文中的数据科学工程师，更倾向于把数据和分析结果真正应用到产品中这个方向（另一个方向是提供商业分析支持，这需要对市场、商业、金融和运营有比较深入的理解，我不太了解，暂时不涉及）。简单来说就是原来『数据科学家』和『数据工程师』两者的结合。</p>
<p>至于『如何成为』这类的问题，大约是有标准答案的，坚持刻意练习与思考总结，理论结合实践，向优秀前辈学习。不过这种漂亮话说出来没啥用，听起来也没啥用。</p>
<p>我这里倒有一个简单易行的办法：做一个自我数据管理平台。通过实际『做』来真正『学』，在不知不觉中『成为』数据科学工程师。</p>
<p>为什么这个主意不错呢？有以下几个原因：</p>
<ul>
<li>自己是开发者，借助现有工具一点一点搭建平台，能够接触开发各个环节的各个方面</li>
<li>自己是产品经理，如何设计系统的功能和配套界面，如何在开发资源有限的条件下进行取舍，能够学会判断需求的优先级与排期</li>
<li>自己是数据经理，需要收集什么数据，收集回来的数据怎么用，能够从自身角度出发去思考数据对于产品和用户的意义</li>
<li>自己是用户，需要在日常使用中发现不足，给出可行的意见和建议</li>
</ul>
<p>在我看来，没有什么比全程参与更能学到东西了，虽然每一环节都是『输入-&gt;处理-&gt;输出』，但是知道每个环节是如何处理的，更能协调好各个部分的效率和功能，让一加一大于三。</p>
<p>具体来说，能做要做的东西太多了，比如：</p>
<ul>
<li>真正把产品用起来，热爱产品<ul>
<li>每天关注数据，思考规模、趋势与关系</li>
</ul>
</li>
<li>保持好奇心与想象力，深入思考，找到那些不太明显但是非常重要的需求<ul>
<li>学会转换视角，从不同角度去解读数据</li>
</ul>
</li>
<li>接入自己在不同社交网站上的数据，对我来说就是微博、知乎、豆瓣和博客了<ul>
<li>根据这些数据分析和挖掘自己的行为，优化自己的时间安排</li>
<li>监测自己每天的工作和学习情况</li>
<li>根据自己的信息收集情况做一些推荐和信息筛选</li>
</ul>
</li>
<li>搭建系统时设计架构，开发功能时梳理流程</li>
<li>结合数据挖掘、机器学习等相关技术建立预测与跟踪体系</li>
<li>如何解释结果是一个大问题（即让数据成为证据）</li>
<li>数据可视化与跨界思考能力</li>
</ul>
<p>上面所说的内容，也就对应于下面的技能集。</p>
<h2 id="数据科学工程师技能集"><a href="#数据科学工程师技能集" class="headerlink" title="数据科学工程师技能集"></a>数据科学工程师技能集</h2><p>参考 Swami Chandrasekaran 制作的数据科学家地铁图，根据自己的理解进行了重新分类和总结（注：知识点不是百分百全）</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>线性代数基础（主要是矩阵及相关知识）</li>
<li>基本数据结构（哈希、二叉树、图）</li>
<li>关系代数、关系型数据库与非关系型数据库（内积、外积、叉乘、NoSQL）</li>
<li>CAP 理论</li>
<li>分布式基础（分片、集群）</li>
<li>信息论与熵</li>
<li>基本的报告、商业智能及分析</li>
<li>JSON 和 XML 格式</li>
<li>正则表达式</li>
<li>计算机系统运行机制</li>
<li>基础计算机学科：操作系统、计算机网络</li>
<li>Linux 的基本使用</li>
</ul>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><ul>
<li>了解各类数据集与获取方式</li>
<li>基本统计信息（均值、中位数、范围、标准差、方差、直方图）</li>
<li>概率论、贝叶斯理论、随机变量、概率密度函数、累积分布函数、连续分布（正态、泊松、高斯）</li>
<li>数据倾斜、方差分析、中心极限定理、蒙特卡洛方法、假设检验、最小二乘法</li>
<li>最大似然估计、核密度估计、回归分析、协方差、皮尔逊相关、各类距离度量（欧拉距离）</li>
</ul>
<h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><ul>
<li>面向对象</li>
<li>接口设计</li>
<li>Python / Go / Java / Shell</li>
<li>基本算法</li>
<li>读取各类数据</li>
<li>使用软件包</li>
</ul>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ul>
<li>机器学习基础知识</li>
<li>监督学习、非监督学习、半监督学习、强化学习</li>
<li>训练集与测试集</li>
<li>分类器、预测器、过拟合、偏差</li>
<li>分类：决策树、Boosting、朴素贝叶斯、K 近邻</li>
<li>回归：Logistic 回归、线性回归、感知机</li>
<li>聚类：K-Means</li>
<li>神经网络、SVM</li>
<li>情感分析、协同过滤、实体识别</li>
</ul>
<h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><ul>
<li>ETL 过程</li>
<li>MapReduce 基本理解</li>
<li>Hadoop 生态(Zookeeper, HDFS)</li>
<li>Spark 生态</li>
<li>NoSQL 数据库(MongoDB, Cassandra)</li>
<li>云服务的使用</li>
<li>各类配套工具：Flume, Scrapy 等等</li>
<li>数据可视化</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>真正动手去做一个像样的产品，并且真正用起来才是最锻炼人的。不要限制自己，其实没有条条框框，想做，就去试试。</p>
<p>唯一要注意的就是，累了的时候，想想那时意气风发豪情万丈的自己，别停下。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.zhihu.com/question/20625467" target="_blank" rel="external">什么是好的数据科学家</a></li>
<li><a href="https://www.zhihu.com/question/21592677" target="_blank" rel="external">如何成为一名数据科学家</a></li>
<li><a href="https://www.zhihu.com/question/26894983" target="_blank" rel="external">数据科学家/统计学家应该养成哪些好习惯</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA4OTk5OTQzMg==&amp;mid=2449231402&amp;idx=1&amp;sn=8de7356f8ccfa65ebfd0ae50b37a98f8" target="_blank" rel="external">工程师要不要写ETL？——教你构建高效的算法/数据科学部门</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司的数据部门通常有三种角色：数据科学家、数据工程师和架构工程师，但许多事实证明这样的分类方法既不科学也不高效。结合工作中的经验，我认为『数据科学工程师』这一角色才是发展方向。这里我们来聊聊什么是，以及如何成为一个优秀的数据科学工程师。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="工程" scheme="http://wdxtub.com/tags/%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="理论" scheme="http://wdxtub.com/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Python 编码风格指南</title>
    <link href="http://wdxtub.com/2016/10/13/python-style-guide/"/>
    <id>http://wdxtub.com/2016/10/13/python-style-guide/</id>
    <published>2016-10-12T22:38:52.000Z</published>
    <updated>2016-10-14T15:31:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个统一的编程风格不但能够增强代码可读性，也可以避免许多低级问题。本文转载自 <a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/" target="_blank" rel="external">zh-google-styleguide</a>这个项目，方便自己查阅，如果有更新也会提 PR 做出自己的贡献。</p>
<a id="more"></a>
<hr>
<h2 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h2><h3 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h3><blockquote>
<p>Tip 对你的代码运行 pylint</p>
</blockquote>
<p><strong>定义</strong></p>
<p>pylint 是一个在 Python 源代码中查找 bug 的工具. 对于 C 和 C++ 这样的不那么动态的(译者注: 原文是less dynamic)语言, 这些 bug 通常由编译器来捕获. 由于 Python 的动态特性, 有些警告可能不对. 不过伪告警应该很少.</p>
<p><strong>优点</strong></p>
<p>可以捕获容易忽视的错误, 例如输入错误, 使用未赋值的变量等.</p>
<p><strong>缺点</strong></p>
<p>pylint不完美. 要利用其优势, 我们有时侯需要: </p>
<ol>
<li>围绕着它来写代码</li>
<li>抑制其告警 </li>
<li>改进它</li>
<li>忽略它.</li>
</ol>
<p><strong>结论</strong></p>
<p>确保对你的代码运行 pylint.抑制不准确的警告,以便能够将其他警告暴露出来。</p>
<p>你可以通过设置一个行注释来抑制告警. 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">dict = <span class="string">'something awful'</span>  <span class="comment"># Bad Idea... pylint: disable=redefined-builtin</span></div></pre></td></tr></table></figure>
<p>pylint 警告是以一个数字编号(如 <code>C0112</code> )和一个符号名(如 <code>empty-docstring</code> )来标识的. 在编写新代码或更新已有代码时对告警进行医治, 推荐使用符号名来标识.</p>
<p>如果警告的符号名不够见名知意，那么请对其增加一个详细解释。</p>
<p>采用这种抑制方式的好处是我们可以轻松查找抑制并回顾它们.</p>
<p>你可以使用命令 <code>pylint --list-msgs</code> 来获取 pylint 告警列表. 你可以使用命令 <code>pylint --help-msg=C6409</code>, 以获取关于特定消息的更多信息.</p>
<p>相比较于之前使用的 <code>pylint: disable-msg</code>, 本文推荐使用 <code>pylint: disable</code>.</p>
<p>要抑制”参数未使用”告警, 你可以用”<em>”作为参数标识符, 或者在参数名前加”unused</em>”. 遇到不能改变参数名的情况, 你可以通过在函数开头”提到”它们来消除告警. 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, unused_b, unused_c, d=None, e=None)</span>:</span></div><div class="line">    _ = d, e</div><div class="line">    <span class="keyword">return</span> a</div></pre></td></tr></table></figure>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><blockquote>
<p>Tip 仅对包和模块使用导入</p>
</blockquote>
<p><strong>定义</strong></p>
<p>模块间共享代码的重用机制.</p>
<p><strong>优点</strong></p>
<p>命名空间管理约定十分简单. 每个标识符的源都用一种一致的方式指示. <code>x.Obj</code> 表示 Obj 对象定义在模块 x 中.</p>
<p><strong>缺点</strong></p>
<p>模块名仍可能冲突. 有些模块名太长, 不太方便.</p>
<p><strong>结论</strong></p>
<p>使用 <code>import x</code> 来导入包和模块.</p>
<p>使用 <code>from x import y</code> , 其中 x 是包前缀, y 是不带前缀的模块名.</p>
<p>使用 <code>from x import y as z</code>, 如果两个要导入的模块都叫做 z 或者 y 太长了.</p>
<p>例如, 模块 <code>sound.effects.echo</code> 可以用如下方式导入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</div><div class="line">...</div><div class="line">echo.EchoFilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>导入时不要使用相对名称. 即使模块在同一个包中, 也要使用完整包名. 这能帮助你避免无意间导入一个包两次.</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><blockquote>
<p>Tip 使用模块的全路径名来导入每个模块</p>
</blockquote>
<p><strong>优点</strong></p>
<p>避免模块名冲突. 查找包更容易.</p>
<p><strong>缺点</strong></p>
<p>部署代码变难, 因为你必须复制包层次.</p>
<p><strong>结论</strong></p>
<p>所有的新代码都应该用完整包名来导入每个模块.</p>
<p>应该像下面这样导入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Reference in code with complete name.</span></div><div class="line"><span class="keyword">import</span> sound.effects.echo</div><div class="line"></div><div class="line"><span class="comment"># Reference in code with just module name (preferred).</span></div><div class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</div></pre></td></tr></table></figure>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><blockquote>
<p>Tip 允许使用异常, 但必须小心</p>
</blockquote>
<p><strong>定义</strong></p>
<p>异常是一种跳出代码块的正常控制流来处理错误或者其它异常条件的方式.</p>
<p><strong>优点</strong></p>
<p>正常操作代码的控制流不会和错误处理代码混在一起. 当某种条件发生时, 它也允许控制流跳过多个框架. 例如, 一步跳出N个嵌套的函数, 而不必继续执行错误的代码.</p>
<p><strong>缺点</strong></p>
<p>可能会导致让人困惑的控制流. 调用库时容易错过错误情况.</p>
<p><strong>结论</strong></p>
<p>异常必须遵守特定条件:</p>
<ul>
<li>像这样触发异常: <code>raise MyException(&quot;Error message&quot;)</code> 或者 <code>raise MyException</code>. 不要使用两个参数的形式( <code>raise MyException, &quot;Error message&quot;</code>)或者过时的字符串异常( <code>raise &quot;Error message&quot;</code> ).</li>
<li>模块或包应该定义自己的特定域的异常基类, 这个基类应该从内建的 Exception 类继承. 模块的异常基类应该叫做”Error”.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span><span class="params">(Exception)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<ul>
<li>永远不要使用 <code>except:</code> 语句来捕获所有异常, 也不要捕获 <code>Exception</code> 或者 <code>StandardError</code> , 除非你打算重新触发该异常, 或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面, Python 非常宽容, <code>except:</code> 真的会捕获包括 Python 语法错误在内的任何错误. 使用 <code>except:</code> 很容易隐藏真正的bug.</li>
<li>尽量减少 <code>try/except</code> 块中的代码量. try 块的体积越大, 期望之外的异常就越容易被触发. 这种情况下, try/except 块将隐藏真正的错误.</li>
<li>使用 finally 子句来执行那些无论 try 块中有没有异常都应该被执行的代码. 这对于清理资源常常很有用, 例如关闭文件.</li>
<li>当捕获异常时, 使用 as 而不要用逗号. 例如</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">raise</span> Error</div><div class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> error:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><blockquote>
<p>Tip 避免全局变量</p>
</blockquote>
<p><strong>定义</strong></p>
<p>定义在模块级的变量.</p>
<p><strong>优点</strong></p>
<p>偶尔有用.</p>
<p><strong>缺点</strong></p>
<p>导入时可能改变模块行为, 因为导入模块时会对模块级变量赋值.</p>
<p><strong>结论</strong></p>
<p>避免使用全局变量, 用类变量来代替. 但也有一些例外:</p>
<ol>
<li>脚本的默认选项.</li>
<li>模块级常量. 例如:　PI = 3.14159. 常量应该全大写, 用下划线连接.</li>
<li>有时候用全局变量来缓存值或者作为函数返回值很有用.</li>
<li>如果需要, 全局变量应该仅在模块内部可用, 并通过模块级的公共函数来访问.</li>
</ol>
<h3 id="嵌套-局部-内部类或函数"><a href="#嵌套-局部-内部类或函数" class="headerlink" title="嵌套/局部/内部类或函数"></a>嵌套/局部/内部类或函数</h3><blockquote>
<p>Tip 鼓励使用嵌套/本地/内部类或函数</p>
</blockquote>
<p><strong>定义</strong></p>
<p>类可以定义在方法, 函数或者类中. 函数可以定义在方法或函数中. 封闭区间中定义的变量对嵌套函数是只读的.</p>
<p><strong>优点</strong></p>
<p>允许定义仅用于有效范围的工具类和函数.</p>
<p><strong>缺点</strong></p>
<p>嵌套类或局部类的实例不能序列化(pickled).</p>
<p><strong>结论</strong></p>
<p>推荐使用.</p>
<h3 id="列表推导-List-Comprehensions"><a href="#列表推导-List-Comprehensions" class="headerlink" title="列表推导(List Comprehensions)"></a>列表推导(List Comprehensions)</h3><blockquote>
<p>Tip 可以在简单情况下使用</p>
</blockquote>
<p><strong>定义</strong></p>
<p>列表推导(list comprehensions)与生成器表达式(generator expression)提供了一种简洁高效的方式来创建列表和迭代器, 而不必借助 map(), filter(), 或者 lambda.</p>
<p><strong>优点</strong></p>
<p>简单的列表推导可以比其它的列表创建方法更加清晰简单. 生成器表达式可以十分高效, 因为它们避免了创建整个列表.</p>
<p><strong>缺点</strong></p>
<p>复杂的列表推导或者生成器表达式可能难以阅读.</p>
<p><strong>结论</strong></p>
<p>适用于简单情况. 每个部分应该单独置于一行: 映射表达式, for 语句, 过滤器表达式. 禁止多重 for 语句或过滤器表达式. 复杂情况下还是使用循环.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes:</div><div class="line">  result = []</div><div class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">      <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">          <span class="keyword">if</span> x * y &gt; <span class="number">10</span>:</div><div class="line">              result.append((x, y))</div><div class="line"></div><div class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">5</span>):</div><div class="line">      <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5</span>):</div><div class="line">          <span class="keyword">if</span> x != y:</div><div class="line">              <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">5</span>):</div><div class="line">                  <span class="keyword">if</span> y != z:</div><div class="line">                      <span class="keyword">yield</span> (x, y, z)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> ((x, complicated_transform(x))</div><div class="line">          <span class="keyword">for</span> x <span class="keyword">in</span> long_generator_function(parameter)</div><div class="line">          <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>)</div><div class="line"></div><div class="line">  squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</div><div class="line"></div><div class="line">  eat(jelly_bean <span class="keyword">for</span> jelly_bean <span class="keyword">in</span> jelly_beans</div><div class="line">      <span class="keyword">if</span> jelly_bean.color == <span class="string">'black'</span>)</div><div class="line">No:</div><div class="line">  result = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> x * y &gt; <span class="number">10</span>]</div><div class="line"></div><div class="line">  <span class="keyword">return</span> ((x, y, z)</div><div class="line">          <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">5</span>)</div><div class="line">          <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5</span>)</div><div class="line">          <span class="keyword">if</span> x != y</div><div class="line">          <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">5</span>)</div><div class="line">          <span class="keyword">if</span> y != z)</div></pre></td></tr></table></figure>
<h3 id="默认迭代器和操作符"><a href="#默认迭代器和操作符" class="headerlink" title="默认迭代器和操作符"></a>默认迭代器和操作符</h3><blockquote>
<p>Tip 如果类型支持, 就使用默认迭代器和操作符. 比如列表, 字典及文件等.</p>
</blockquote>
<p><strong>定义</strong></p>
<p>容器类型, 像字典和列表, 定义了默认的迭代器和关系测试操作符(in 和 not in)</p>
<p><strong>优点</strong></p>
<p>默认操作符和迭代器简单高效, 它们直接表达了操作, 没有额外的方法调用. 使用默认操作符的函数是通用的. 它可以用于支持该操作的任何类型.</p>
<p><strong>缺点</strong></p>
<p>你没法通过阅读方法名来区分对象的类型(例如, <code>has_key()</code>意味着字典). 不过这也是优点.</p>
<p><strong>结论</strong></p>
<p>如果类型支持, 就使用默认迭代器和操作符, 例如列表, 字典和文件. 内建类型也定义了迭代器方法. 优先考虑这些方法, 而不是那些返回列表的方法. 当然，这样遍历容器时，你将不能修改容器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes:  <span class="keyword">for</span> key <span class="keyword">in</span> adict: ...</div><div class="line">      <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> adict: ...</div><div class="line">      <span class="keyword">if</span> obj <span class="keyword">in</span> alist: ...</div><div class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> afile: ...</div><div class="line">      <span class="keyword">for</span> k, v <span class="keyword">in</span> dict.iteritems(): ...</div><div class="line">No:   <span class="keyword">for</span> key <span class="keyword">in</span> adict.keys(): ...</div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> adict.has_key(key): ...</div><div class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> afile.readlines(): ...</div></pre></td></tr></table></figure>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><blockquote>
<p>Tip 按需使用生成器.</p>
</blockquote>
<p><strong>定义</strong></p>
<p>所谓生成器函数, 就是每当它执行一次生成(yield)语句, 它就返回一个迭代器, 这个迭代器生成一个值. 生成值后, 生成器函数的运行状态将被挂起, 直到下一次生成.</p>
<p><strong>优点</strong></p>
<p>简化代码, 因为每次调用时, 局部变量和控制流的状态都会被保存. 比起一次创建一系列值的函数, 生成器使用的内存更少.</p>
<p><strong>缺点</strong></p>
<p>没有.</p>
<p><strong>结论</strong></p>
<p>鼓励使用. 注意在生成器函数的文档字符串中使用”Yields:”而不是”Returns:”.</p>
<p>(译者注: 参看 注释 部分)</p>
<h3 id="Lambda函数"><a href="#Lambda函数" class="headerlink" title="Lambda函数"></a>Lambda函数</h3><blockquote>
<p>Tip 适用于单行函数</p>
</blockquote>
<p><strong>定义</strong></p>
<p>与语句相反, lambda在一个表达式中定义匿名函数. 常用于为 <code>map()</code> 和 <code>filter()</code> 之类的高阶函数定义回调函数或者操作符.</p>
<p><strong>优点</strong></p>
<p>方便.</p>
<p><strong>缺点</strong></p>
<p>比本地函数更难阅读和调试. 没有函数名意味着堆栈跟踪更难理解. 由于 lambda 函数通常只包含一个表达式, 因此其表达能力有限.</p>
<p><strong>结论</strong></p>
<p>适用于单行函数. 如果代码超过 60-80 个字符, 最好还是定义成常规(嵌套)函数.</p>
<p>对于常见的操作符，例如乘法操作符，使用 <code>operator</code> 模块中的函数以代替 lambda 函数. 例如, 推荐使用 <code>operator.mul</code> , 而不是 <code>lambda x, y: x * y</code> .</p>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><blockquote>
<p>Tip 适用于单行函数</p>
</blockquote>
<p><strong>定义</strong></p>
<p>条件表达式是对于 if 语句的一种更为简短的句法规则. 例如: <code>x = 1 if cond else 2</code> .</p>
<p><strong>优点</strong></p>
<p>比if语句更加简短和方便.</p>
<p><strong>缺点</strong></p>
<p>比if语句难于阅读. 如果表达式很长， 难于定位条件.</p>
<p><strong>结论</strong></p>
<p>适用于单行函数. 在其他情况下，推荐使用完整的 if 语句.</p>
<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><blockquote>
<p>Tip 适用于大部分情况.</p>
</blockquote>
<p><strong>定义</strong></p>
<p>你可以在函数参数列表的最后指定变量的值, 例如, <code>def foo(a, b = 0):</code> . 如果调用foo 时只带一个参数, 则 b 被设为 0. 如果带两个参数, 则 b 的值等于第二个参数.</p>
<p><strong>优点</strong></p>
<p>你经常会碰到一些使用大量默认值的函数, 但偶尔(比较少见)你想要覆盖这些默认值. 默认参数值提供了一种简单的方法来完成这件事, 你不需要为这些罕见的例外定义大量函数. 同时, Python 也不支持重载方法和函数, 默认参数是一种”仿造”重载行为的简单方式.</p>
<p><strong>缺点</strong></p>
<p>默认参数只在模块加载时求值一次. 如果参数是列表或字典之类的可变类型, 这可能会导致问题. 如果函数修改了对象(例如向列表追加项), 默认值就被修改了.</p>
<p><strong>结论</strong></p>
<p>鼓励使用, 不过有如下注意事项:</p>
<p>不要在函数或方法定义中使用可变对象作为默认值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=None)</span>:</span></div><div class="line">         <span class="keyword">if</span> b <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">             b = []</div><div class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=[])</span>:</span></div><div class="line">         ...</div><div class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=time.time<span class="params">()</span>)</span>:</span>  <span class="comment"># The time the module was loaded???</span></div><div class="line">         ...</div><div class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=FLAGS.my_thing)</span>:</span>  <span class="comment"># sys.argv has not yet been parsed...</span></div><div class="line">         ...</div></pre></td></tr></table></figure>
<h3 id="属性-properties"><a href="#属性-properties" class="headerlink" title="属性(properties)"></a>属性(properties)</h3><blockquote>
<p>Tip 访问和设置数据成员时, 你通常会使用简单, 轻量级的访问和设置函数. 建议用属性（properties）来代替它们.</p>
</blockquote>
<p><strong>定义</strong></p>
<p>一种用于包装方法调用的方式. 当运算量不大, 它是获取和设置属性(attribute)的标准方式.</p>
<p><strong>优点</strong></p>
<p>通过消除简单的属性(attribute)访问时显式的 get 和 set 方法调用, 可读性提高了. 允许懒惰的计算. 用 Pythonic 的方式来维护类的接口. 就性能而言, 当直接访问变量是合理的, 添加访问方法就显得琐碎而无意义. 使用属性(properties)可以绕过这个问题. 将来也可以在不破坏接口的情况下将访问方法加上.</p>
<p><strong>缺点</strong></p>
<p>属性(properties)是在 get 和 set 方法声明后指定, 这需要使用者在接下来的代码中注意: set 和 get 是用于属性(properties)的(除了用 @property 装饰器创建的只读属性). 必须继承自 object 类. 可能隐藏比如操作符重载之类的副作用. 继承时可能会让人困惑.</p>
<p><strong>结论</strong></p>
<p>你通常习惯于使用访问或设置方法来访问或设置数据, 它们简单而轻量. 不过我们建议你在新的代码中使用属性. 只读属性应该用 <code>@property</code> 装饰器 来创建.</p>
<p>如果子类没有覆盖属性, 那么属性的继承可能看上去不明显. 因此使用者必须确保访问方法间接被调用, 以保证子类中的重载方法被属性调用(使用模板方法设计模式).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: <span class="keyword">import</span> math</div><div class="line"></div><div class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(object)</span>:</span></div><div class="line">         <span class="string">"""A square with two properties: a writable area and a read-only perimeter.</span></div><div class="line"></div><div class="line">         To use:</div><div class="line">         &gt;&gt;&gt; sq = Square(3)</div><div class="line">         &gt;&gt;&gt; sq.area</div><div class="line">         9</div><div class="line">         &gt;&gt;&gt; sq.perimeter</div><div class="line">         12</div><div class="line">         &gt;&gt;&gt; sq.area = 16</div><div class="line">         &gt;&gt;&gt; sq.side</div><div class="line">         4</div><div class="line">         &gt;&gt;&gt; sq.perimeter</div><div class="line">         16</div><div class="line">         """</div><div class="line"></div><div class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, side)</span>:</span></div><div class="line">             self.side = side</div><div class="line"></div><div class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__get_area</span><span class="params">(self)</span>:</span></div><div class="line">             <span class="string">"""Calculates the 'area' property."""</span></div><div class="line">             <span class="keyword">return</span> self.side ** <span class="number">2</span></div><div class="line"></div><div class="line">         <span class="function"><span class="keyword">def</span> <span class="title">___get_area</span><span class="params">(self)</span>:</span></div><div class="line">             <span class="string">"""Indirect accessor for 'area' property."""</span></div><div class="line">             <span class="keyword">return</span> self.__get_area()</div><div class="line"></div><div class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__set_area</span><span class="params">(self, area)</span>:</span></div><div class="line">             <span class="string">"""Sets the 'area' property."""</span></div><div class="line">             self.side = math.sqrt(area)</div><div class="line"></div><div class="line">         <span class="function"><span class="keyword">def</span> <span class="title">___set_area</span><span class="params">(self, area)</span>:</span></div><div class="line">             <span class="string">"""Indirect setter for 'area' property."""</span></div><div class="line">             self._SetArea(area)</div><div class="line"></div><div class="line">         area = property(___get_area, ___set_area,</div><div class="line">                         doc=<span class="string">"""Gets or sets the area of the square."""</span>)</div><div class="line"></div><div class="line"><span class="meta">         @property</span></div><div class="line">         <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span><span class="params">(self)</span>:</span></div><div class="line">             <span class="keyword">return</span> self.side * <span class="number">4</span></div></pre></td></tr></table></figure>
<p>(译者注: 老实说, 我觉得这段示例代码很不恰当, 有必要这么蛋疼吗?)</p>
<h3 id="True-False的求值"><a href="#True-False的求值" class="headerlink" title="True/False的求值"></a>True/False的求值</h3><blockquote>
<p>Tip 尽可能使用隐式 false</p>
</blockquote>
<p><strong>定义</strong></p>
<p>Python在布尔上下文中会将某些值求值为false. 按简单的直觉来讲, 就是所有的”空”值都被认为是 false. 因此 <code>0</code>， <code>None</code>, <code>[]</code>, <code>{}</code>, <code>“”</code> 都被认为是false.</p>
<p><strong>优点</strong></p>
<p>使用Python布尔值的条件语句更易读也更不易犯错. 大部分情况下, 也更快.</p>
<p><strong>缺点</strong></p>
<p>对C/C++开发人员来说, 可能看起来有点怪.</p>
<p><strong>结论</strong></p>
<p>尽可能使用隐式的false, 例如: 使用 <code>if foo:</code> 而不是 <code>if foo != []:</code> . 不过还是有一些注意事项需要你铭记在心:</p>
<ul>
<li>永远不要用 <code>==</code> 或者 <code>!=</code> 来比较单件, 比如 <code>None</code>. 使用 <code>is</code> 或者 <code>is not</code>.</li>
<li>注意: 当你写下 <code>if x:</code> 时, 你其实表示的是 <code>if x is not None</code> . 例如: 当你要测试一个默认值是 None 的变量或参数是否被设为其它值. 这个值在布尔语义下可能是false!</li>
<li>永远不要用 <code>==</code> 将一个布尔量与 false 相比较. 使用 <code>if not x:</code> 代替. 如果你需要区分 false 和 None, 你应该用像 <code>if not x and x is not None:</code> 这样的语句.</li>
<li>对于序列(字符串, 列表, 元组), 要注意空序列是 false. 因此 <code>if not seq:</code> 或者 <code>if seq:</code> 比 <code>if len(seq):</code> 或 <code>if not len(seq):</code> 要更好.</li>
<li>处理整数时, 使用隐式 false 可能会得不偿失(即不小心将 None 当做 0 来处理). 你可以将一个已知是整型(且不是 <code>len()</code> 的返回结果)的值与 0 比较.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: <span class="keyword">if</span> <span class="keyword">not</span> users:</div><div class="line">         <span class="keyword">print</span> <span class="string">'no users'</span></div><div class="line"></div><div class="line">     <span class="keyword">if</span> foo == <span class="number">0</span>:</div><div class="line">         self.handle_zero()</div><div class="line"></div><div class="line">     <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</div><div class="line">         self.handle_multiple_of_ten()</div><div class="line">No:  <span class="keyword">if</span> len(users) == <span class="number">0</span>:</div><div class="line">         <span class="keyword">print</span> <span class="string">'no users'</span></div><div class="line"></div><div class="line">     <span class="keyword">if</span> foo <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> foo:</div><div class="line">         self.handle_zero()</div><div class="line"></div><div class="line">     <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">10</span>:</div><div class="line">         self.handle_multiple_of_ten()</div></pre></td></tr></table></figure>
<ul>
<li>注意‘0’(字符串)会被当做 true.</li>
</ul>
<h3 id="过时的语言特性"><a href="#过时的语言特性" class="headerlink" title="过时的语言特性"></a>过时的语言特性</h3><blockquote>
<p>Tip 尽可能使用字符串方法取代字符串模块. 使用函数调用语法取代apply(). 使用列表推导, for 循环取代 filter(), map() 以及 reduce().</p>
</blockquote>
<p><strong>定义</strong></p>
<p>当前版本的 Python 提供了大家通常更喜欢的替代品.</p>
<p><strong>结论</strong></p>
<p>我们不使用不支持这些特性的 Python 版本, 所以没理由不用新的方式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: words = foo.split(<span class="string">':'</span>)</div><div class="line"></div><div class="line">     [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> my_list <span class="keyword">if</span> x[<span class="number">2</span>] == <span class="number">5</span>]</div><div class="line"></div><div class="line">     map(math.sqrt, data)    <span class="comment"># Ok. No inlined lambda expression.</span></div><div class="line"></div><div class="line">     fn(*args, **kwargs)</div><div class="line">No:  words = string.split(foo, <span class="string">':'</span>)</div><div class="line"></div><div class="line">     map(<span class="keyword">lambda</span> x: x[<span class="number">1</span>], filter(<span class="keyword">lambda</span> x: x[<span class="number">2</span>] == <span class="number">5</span>, my_list))</div><div class="line"></div><div class="line">     apply(fn, args, kwargs)</div></pre></td></tr></table></figure>
<h3 id="词法作用域-Lexical-Scoping"><a href="#词法作用域-Lexical-Scoping" class="headerlink" title="词法作用域(Lexical Scoping)"></a>词法作用域(Lexical Scoping)</h3><blockquote>
<p>Tip 推荐使用</p>
</blockquote>
<p><strong>定义</strong></p>
<p>嵌套的 Pytho n函数可以引用外层函数中定义的变量, 但是不能够对它们赋值. 变量绑定的解析是使用词法作用域, 也就是基于静态的程序文本. 对一个块中的某个名称的任何赋值都会导致 Python 将对该名称的全部引用当做局部变量, 甚至是赋值前的处理. 如果碰到 global 声明, 该名称就会被视作全局变量.</p>
<p>一个使用这个特性的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_adder</span><span class="params">(summand1)</span>:</span></div><div class="line">    <span class="string">"""Returns a function that adds numbers to a given number."""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adder</span><span class="params">(summand2)</span>:</span></div><div class="line">        <span class="keyword">return</span> summand1 + summand2</div><div class="line"></div><div class="line">    <span class="keyword">return</span> adder</div></pre></td></tr></table></figure>
<p>(译者注: 这个例子有点诡异, 你应该这样使用这个函数: <code>sum = get_adder(summand1)(summand2)</code> )</p>
<p><strong>优点</strong></p>
<p>通常可以带来更加清晰, 优雅的代码. 尤其会让有经验的 Lisp 和 Scheme(还有 Haskell, ML 等)程序员感到欣慰.</p>
<p><strong>缺点</strong></p>
<p>可能导致让人迷惑的bug. 例如下面这个依据 PEP-0227 的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">i = <span class="number">4</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">print</span> i,</div><div class="line">    <span class="comment"># ...</span></div><div class="line">    <span class="comment"># A bunch of code here</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:  <span class="comment"># Ah, i *is* local to Foo, so this is what Bar sees</span></div><div class="line">        <span class="keyword">print</span> i,</div><div class="line">    bar()</div></pre></td></tr></table></figure>
<p>因此 <code>foo([1, 2, 3])</code> 会打印 <code>1 2 3 3</code> , 不是 <code>1 2 3 4</code> .</p>
<p>(译者注: x 是一个列表, for 循环其实是将 x 中的值依次赋给 i.这样对 i 的赋值就隐式的发生了, 整个 foo 函数体中的 i 都会被当做局部变量, 包括 bar()中的那个. 这一点与 C++ 之类的静态语言还是有很大差别的.)</p>
<p><strong>结论</strong></p>
<p>鼓励使用.</p>
<h3 id="函数与方法装饰器"><a href="#函数与方法装饰器" class="headerlink" title="函数与方法装饰器"></a>函数与方法装饰器</h3><blockquote>
<p>Tip 如果好处很显然, 就明智而谨慎的使用装饰器</p>
</blockquote>
<p><strong>定义</strong></p>
<p>用于函数及方法的装饰器 (也就是@标记). 最常见的装饰器是 <code>@classmethod</code> 和<code>@staticmethod</code>, 用于将常规函数转换成类方法或静态方法. 不过, 装饰器语法也允许用户自定义装饰器. 特别地, 对于某个函数 <code>my_decorator</code> , 下面的两段代码是等效的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">   @my_decorator</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="comment"># method body ...</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># method body ...</span></div><div class="line">    method = my_decorator(method)</div></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>优雅的在函数上指定一些转换. 该转换可能减少一些重复代码, 保持已有函数不变(enforce invariants), 等.</p>
<p><strong>缺点</strong></p>
<p>装饰器可以在函数的参数或返回值上执行任何操作, 这可能导致让人惊异的隐藏行为. 而且, 装饰器在导入时执行. 从装饰器代码的失败中恢复更加不可能.</p>
<p><strong>结论</strong></p>
<p>如果好处很显然, 就明智而谨慎的使用装饰器. 装饰器应该遵守和函数一样的导入和命名规则. 装饰器的python文档应该清晰的说明该函数是一个装饰器. 请为装饰器编写单元测试.</p>
<p>避免装饰器自身对外界的依赖(即不要依赖于文件, socket, 数据库连接等), 因为装饰器运行时这些资源可能不可用(由 <code>pydoc</code> 或其它工具导入). 应该保证一个用有效参数调用的装饰器在所有情况下都是成功的.</p>
<p>装饰器是一种特殊形式的”顶级代码”. 参考后面关于 Main 的话题.</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote>
<p>Tip 不要依赖内建类型的原子性.</p>
</blockquote>
<p>虽然 Python 的内建类型例如字典看上去拥有原子操作, 但是在某些情形下它们仍然不是原子的(即: 如果 <code>__hash__</code> 或 <code>__eq__</code> 被实现为 Python 方法)且它们的原子性是靠不住的. 你也不能指望原子变量赋值(因为这个反过来依赖字典).</p>
<p>优先使用 Queue 模块的 <code>Queue</code> 数据类型作为线程间的数据通信方式. 另外, 使用threading 模块及其锁原语(locking primitives). 了解条件变量的合适使用方式, 这样你就可以使用 <code>threading.Condition</code> 来取代低级别的锁了.</p>
<h3 id="威力过大的特性"><a href="#威力过大的特性" class="headerlink" title="威力过大的特性"></a>威力过大的特性</h3><blockquote>
<p>Tip 避免使用这些特性</p>
</blockquote>
<p><strong>定义</strong></p>
<p>Python是一种异常灵活的语言, 它为你提供了很多花哨的特性, 诸如元类(metaclasses), 字节码访问, 任意编译(on-the-fly compilation), 动态继承, 对象父类重定义(object reparenting), 导入黑客(import hacks), 反射, 系统内修改(modification of system internals), 等等.</p>
<p><strong>优点</strong></p>
<p>强大的语言特性, 能让你的代码更紧凑.</p>
<p><strong>缺点</strong></p>
<p>使用这些很”酷”的特性十分诱人, 但不是绝对必要. 使用奇技淫巧的代码将更加难以阅读和调试. 开始可能还好(对原作者而言), 但当你回顾代码, 它们可能会比那些稍长一点但是很直接的代码更加难以理解.</p>
<p><strong>结论</strong></p>
<p>在你的代码中避免这些特性.</p>
<h2 id="风格规范"><a href="#风格规范" class="headerlink" title="风格规范"></a>风格规范</h2><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><blockquote>
<p>Tip 不要在行尾加分号, 也不要用分号将两条命令放在同一行.</p>
</blockquote>
<h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><blockquote>
<p>Tip 每行不超过80个字符</p>
</blockquote>
<p>例外:</p>
<ul>
<li>长的导入模块语句</li>
<li>注释里的URL</li>
</ul>
<p>不要使用反斜杠连接行.</p>
<p>Python会将<a href="http://docs.python.org/2/reference/lexical_analysis.html#implicit-line-joining" target="_blank" rel="external">圆括号, 中括号和花括号中的行隐式的连接起来</a>, 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: foo_bar(self, width, height, color=<span class="string">'black'</span>, design=<span class="keyword">None</span>, x=<span class="string">'foo'</span>,</div><div class="line">             emphasis=<span class="keyword">None</span>, highlight=<span class="number">0</span>)</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></div><div class="line">         color == <span class="string">'red'</span> <span class="keyword">and</span> emphasis == <span class="string">'strong'</span>):</div></pre></td></tr></table></figure>
<p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">x = (<span class="string">'This will build a very long long '</span></div><div class="line">     <span class="string">'long long long long long long string'</span>)</div></pre></td></tr></table></figure>
<p>在注释中，如果必要，将长的URL放在一行上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes:  <span class="comment"># See details at</span></div><div class="line">      <span class="comment"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span></div><div class="line">No:  <span class="comment"># See details at</span></div><div class="line">     <span class="comment"># http://www.example.com/us/developer/documentation/api/content/\</span></div><div class="line">     <span class="comment"># v2.0/csv_file_name_extension_full_specification.html</span></div></pre></td></tr></table></figure>
<p>注意上面例子中的元素缩进; 你可以在本文的 缩进 部分找到解释.</p>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><blockquote>
<p>Tip 宁缺毋滥的使用括号</p>
</blockquote>
<p>除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: <span class="keyword">if</span> foo:</div><div class="line">         bar()</div><div class="line">     <span class="keyword">while</span> x:</div><div class="line">         x = bar()</div><div class="line">     <span class="keyword">if</span> x <span class="keyword">and</span> y:</div><div class="line">         bar()</div><div class="line">     <span class="keyword">if</span> <span class="keyword">not</span> x:</div><div class="line">         bar()</div><div class="line">     <span class="keyword">return</span> foo</div><div class="line">     <span class="keyword">for</span> (x, y) <span class="keyword">in</span> dict.items(): ...</div><div class="line">No:  <span class="keyword">if</span> (x):</div><div class="line">         bar()</div><div class="line">     <span class="keyword">if</span> <span class="keyword">not</span>(x):</div><div class="line">         bar()</div><div class="line">     <span class="keyword">return</span> (foo)</div></pre></td></tr></table></figure>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><blockquote>
<p>Tip 用4个空格来缩进代码</p>
</blockquote>
<p>绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素(见 行长度 部分的示例), 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes:   <span class="comment"># Aligned with opening delimiter</span></div><div class="line">       foo = long_function_name(var_one, var_two,</div><div class="line">                                var_three, var_four)</div><div class="line"></div><div class="line">       <span class="comment"># Aligned with opening delimiter in a dictionary</span></div><div class="line">       foo = &#123;</div><div class="line">           long_dictionary_key: value1 +</div><div class="line">                                value2,</div><div class="line">           ...</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment"># 4-space hanging indent; nothing on first line</span></div><div class="line">       foo = long_function_name(</div><div class="line">           var_one, var_two, var_three,</div><div class="line">           var_four)</div><div class="line"></div><div class="line">       <span class="comment"># 4-space hanging indent in a dictionary</span></div><div class="line">       foo = &#123;</div><div class="line">           long_dictionary_key:</div><div class="line">               long_dictionary_value,</div><div class="line">           ...</div><div class="line">       &#125;</div><div class="line">No:    <span class="comment"># Stuff on first line forbidden</span></div><div class="line">      foo = long_function_name(var_one, var_two,</div><div class="line">          var_three, var_four)</div><div class="line"></div><div class="line">      <span class="comment"># 2-space hanging indent forbidden</span></div><div class="line">      foo = long_function_name(</div><div class="line">        var_one, var_two, var_three,</div><div class="line">        var_four)</div><div class="line"></div><div class="line">      <span class="comment"># No hanging indent in a dictionary</span></div><div class="line">      foo = &#123;</div><div class="line">          long_dictionary_key:</div><div class="line">              long_dictionary_value,</div><div class="line">              ...</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><blockquote>
<p>Tip 顶级定义之间空两行, 方法定义之间空一行</p>
</blockquote>
<p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><blockquote>
<p>Tip 按照标准的排版规范来使用标点两边的空格</p>
</blockquote>
<p>括号内不要有空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;, [])</div><div class="line">No:  spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125;, [ ] )</div></pre></td></tr></table></figure>
<p>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: <span class="keyword">if</span> x == <span class="number">4</span>:</div><div class="line">         <span class="keyword">print</span> x, y</div><div class="line">     x, y = y, x</div><div class="line">No:  <span class="keyword">if</span> x == <span class="number">4</span> :</div><div class="line">         <span class="keyword">print</span> x , y</div><div class="line">     x , y = y , x</div></pre></td></tr></table></figure>
<p>参数列表, 索引或切片的左括号前不应加空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: spam(<span class="number">1</span>)</div><div class="line">no: spam (<span class="number">1</span>)</div><div class="line">Yes: dict[<span class="string">'key'</span>] = list[index]</div><div class="line">No:  dict [<span class="string">'key'</span>] = list [index]</div></pre></td></tr></table></figure>
<p>在二元操作符两边都加上一个空格, 比如赋值(<code>=</code>), 比较(<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>in</code>, <code>not in</code>, <code>is</code>, <code>is not</code>), 布尔(<code>and</code>, <code>or</code>, <code>not</code>). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: x == <span class="number">1</span></div><div class="line">No:  x&lt;<span class="number">1</span></div></pre></td></tr></table></figure>
<p>当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Yes: def complex(real, imag=0.0): return magic(r=real, i=imag)</div><div class="line">No:  def complex(real, imag = 0.0): return magic(r = real, i = imag)</div></pre></td></tr></table></figure>
<p>不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于<code>:</code>, <code>#</code>, <code>=</code>等):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes:</div><div class="line">     foo = <span class="number">1000</span>  <span class="comment"># comment</span></div><div class="line">     long_name = <span class="number">2</span>  <span class="comment"># comment that should not be aligned</span></div><div class="line"></div><div class="line">     dictionary = &#123;</div><div class="line">         <span class="string">"foo"</span>: <span class="number">1</span>,</div><div class="line">         <span class="string">"long_name"</span>: <span class="number">2</span>,</div><div class="line">         &#125;</div><div class="line">No:</div><div class="line">     foo       = <span class="number">1000</span>  <span class="comment"># comment</span></div><div class="line">     long_name = <span class="number">2</span>     <span class="comment"># comment that should not be aligned</span></div><div class="line"></div><div class="line">     dictionary = &#123;</div><div class="line">         <span class="string">"foo"</span>      : <span class="number">1</span>,</div><div class="line">         <span class="string">"long_name"</span>: <span class="number">2</span>,</div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<h3 id="Shebang"><a href="#Shebang" class="headerlink" title="Shebang"></a>Shebang</h3><blockquote>
<p>Tip 大部分 <code>.py</code>文件不必以 <code>#!</code> 作为文件的开始. 根据 <a href="http://www.python.org/dev/peps/pep-0394/" target="_blank" rel="external">PEP-394</a> , 程序的main文件应该以 <code>#!/usr/bin/python2</code> 或者 <code>#!/usr/bin/python3</code>开始.</p>
</blockquote>
<p>(译者注: 在计算机科学中, Shebang (也称为Hashbang)是一个由井号和叹号构成的字符串行(#!), 其出现在文本文件的第一行的前两个字符. 在文件中存在 Shebang 的情况下, 类Unix操作系统的程序载入器会分析Shebang后的内容, 将这些内容作为解释器指令, 并调用该指令, 并将载有Shebang的文件路径作为该解释器的参数. 例如, 以指令 <code>#!/bin/sh</code> 开头的文件在执行时会实际调用 <code>/bin/sh</code> 程序.)</p>
<p><code>#!</code> 先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略. 因此只有被直接执行的文件中才有必要加入 <code>#!</code>.</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote>
<p>Tip 确保对模块, 函数, 方法和行内注释使用正确的风格</p>
</blockquote>
<p><strong>文档字符串</strong></p>
<p>Python 有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的 <code>__doc__</code> 成员被自动提取, 并且被<code>pydoc</code> 所用. (你可以在你的模块上运行 <code>pydoc</code> 试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号<code>”“”</code>(<a href="http://www.python.org/dev/peps/pep-0257/" target="_blank" rel="external">PEP-257</a>). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范.</p>
<p><strong>模块</strong></p>
<p>每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.</p>
<p><strong>函数和方法</strong></p>
<p>下文所指的函数,包括函数, 方法, 以及生成器.</p>
<p>一个函数必须要有文档字符串, 除非它满足以下条件:</p>
<ol>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ol>
<p>文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述”怎么做”, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义.</p>
<p>关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格.</p>
<p><strong>Args:</strong></p>
<p>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受<code>*foo(可变长度参数列表)</code>或者 <code>**bar (任意关键字参数)</code>, 应该详细列出 <code>*foo</code> 和 <code>**bar</code>.</p>
<p><strong>Returns: (或者 Yields: 用于生成器)</strong></p>
<p>描述返回值的类型和语义. 如果函数返回 None, 这一部分可以省略.</p>
<p><strong>Raises:</strong></p>
<p>列出与接口有关的所有异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span><span class="params">(big_table, keys, other_silly_variable=None)</span>:</span></div><div class="line">    <span class="string">"""Fetches rows from a Bigtable.</span></div><div class="line"></div><div class="line">    Retrieves rows pertaining to the given keys from the Table instance</div><div class="line">    represented by big_table.  Silly things may happen if</div><div class="line">    other_silly_variable is not None.</div><div class="line"></div><div class="line">    Args:</div><div class="line">        big_table: An open Bigtable Table instance.</div><div class="line">        keys: A sequence of strings representing the key of each table row</div><div class="line">            to fetch.</div><div class="line">        other_silly_variable: Another optional variable, that has a much</div><div class="line">            longer name than the other args, and which does nothing.</div><div class="line"></div><div class="line">    Returns:</div><div class="line">        A dict mapping keys to the corresponding table row data</div><div class="line">        fetched. Each row is represented as a tuple of strings. For</div><div class="line">        example:</div><div class="line"></div><div class="line">        &#123;'Serak': ('Rigel VII', 'Preparer'),</div><div class="line">         'Zim': ('Irk', 'Invader'),</div><div class="line">         'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</div><div class="line"></div><div class="line">        If a key from the keys argument is missing from the dictionary,</div><div class="line">        then that row was not found in the table.</div><div class="line"></div><div class="line">    Raises:</div><div class="line">        IOError: An error occurred accessing the bigtable.Table object.</div><div class="line">    """</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""Summary of class here.</span></div><div class="line"></div><div class="line">    Longer class information....</div><div class="line">    Longer class information....</div><div class="line"></div><div class="line">    Attributes:</div><div class="line">        likes_spam: A boolean indicating if we like SPAM or not.</div><div class="line">        eggs: An integer count of the eggs we have laid.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, likes_spam=False)</span>:</span></div><div class="line">        <span class="string">"""Inits SampleClass with blah."""</span></div><div class="line">        self.likes_spam = likes_spam</div><div class="line">        self.eggs = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Performs operation blah."""</span></div></pre></td></tr></table></figure>
<h3 id="块注释和行注释"><a href="#块注释和行注释" class="headerlink" title="块注释和行注释"></a>块注释和行注释</h3><p>最需要写注释的是代码中那些技巧性的部分. 如果你在下次 代码审查 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># We use a weighted dictionary search to find out where i is in</span></div><div class="line"><span class="comment"># the array.  We extrapolate position based on the largest num</span></div><div class="line"><span class="comment"># in the array and the array size and then do binary search to</span></div><div class="line"><span class="comment"># get the exact number.</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> i &amp; (i<span class="number">-1</span>) == <span class="number">0</span>:        <span class="comment"># true if i is a power of 2</span></div></pre></td></tr></table></figure>
<p>为了提高可读性, 注释应该至少离开代码2个空格.</p>
<p>另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span></div><div class="line"><span class="comment"># the next element is i+1</span></div></pre></td></tr></table></figure>
<h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><blockquote>
<p>Tip 如果一个类不继承自其它类, 就显式的从 object 继承. 嵌套类也一样.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></div><div class="line">         <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line">     <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">         <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span><span class="params">(object)</span>:</span></div><div class="line">             <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line">     <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span><span class="params">(ParentClass)</span>:</span></div><div class="line">         <span class="string">"""Explicitly inherits from another class already."""</span></div><div class="line">No: <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span>:</span></div><div class="line"></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span>:</span></div><div class="line">            <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>继承自 <code>object</code> 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受<a href="http://www.python.org/dev/peps/pep-3000/" target="_blank" rel="external">PEP-3000</a>的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 <code>__new__</code>, <code>__init__</code>, <code>__delattr__</code>, <code>__getattribute__</code>, <code>__setattr__</code>, <code>__hash__</code>, <code>__repr__</code>, 和 <code>__str__</code> .</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote>
<p>Tip 即使参数都是字符串, 使用 <code>%</code> 操作符或者格式化方法格式化字符串. 不过也不能一概而论, 你需要在 <code>+</code> 和 <code>%</code> 之间好好判定.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: x = a + b</div><div class="line">     x = <span class="string">'%s, %s!'</span> % (imperative, expletive)</div><div class="line">     x = <span class="string">'&#123;&#125;, &#123;&#125;!'</span>.format(imperative, expletive)</div><div class="line">     x = <span class="string">'name: %s; score: %d'</span> % (name, n)</div><div class="line">     x = <span class="string">'name: &#123;&#125;; score: &#123;&#125;'</span>.format(name, n)</div><div class="line">No: x = <span class="string">'%s%s'</span> % (a, b)  <span class="comment"># use + in this case</span></div><div class="line">    x = <span class="string">'&#123;&#125;&#123;&#125;'</span>.format(a, b)  <span class="comment"># use + in this case</span></div><div class="line">    x = imperative + <span class="string">', '</span> + expletive + <span class="string">'!'</span></div><div class="line">    x = <span class="string">'name: '</span> + name + <span class="string">'; score: '</span> + str(n)</div></pre></td></tr></table></figure>
<p>避免在循环中用 <code>+</code> 和 <code>+=</code> 操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 <code>.join</code> 连接列表. (也可以将每个子串写入一个 <code>cStringIO.StringIO</code> 缓存中.)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: items = [<span class="string">'&lt;table&gt;'</span>]</div><div class="line">     <span class="keyword">for</span> last_name, first_name <span class="keyword">in</span> employee_list:</div><div class="line">         items.append(<span class="string">'&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;'</span> % (last_name, first_name))</div><div class="line">     items.append(<span class="string">'&lt;/table&gt;'</span>)</div><div class="line">     employee_table = <span class="string">''</span>.join(items)</div><div class="line">No: employee_table = <span class="string">'&lt;table&gt;'</span></div><div class="line">    <span class="keyword">for</span> last_name, first_name <span class="keyword">in</span> employee_list:</div><div class="line">        employee_table += <span class="string">'&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;'</span> % (last_name, first_name)</div><div class="line">    employee_table += <span class="string">'&lt;/table&gt;'</span></div></pre></td></tr></table></figure>
<p>在同一个文件中, 保持使用字符串引号的一致性. 使用单引号’或者双引号”之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. PyLint已经加入了这一检查.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes:</div><div class="line">     Python(<span class="string">'Why are you hiding your eyes?'</span>)</div><div class="line">     Gollum(<span class="string">"I'm scared of lint errors."</span>)</div><div class="line">     Narrator(<span class="string">'"Good!" thought a happy Python reviewer.'</span>)</div><div class="line">No:</div><div class="line">     Python(<span class="string">"Why are you hiding your eyes?"</span>)</div><div class="line">     Gollum(<span class="string">'The lint. It burns. It burns us.'</span>)</div><div class="line">     Gollum(<span class="string">"Always the great lint. Watching. Watching."</span>)</div></pre></td></tr></table></figure>
<p>为多行字符串使用三重双引号<code>”“”</code>而非三重单引号<code>’‘’</code>. 当且仅当项目中使用单引号 <code>’</code> 来引用字符串时, 才可能会使用三重 <code>’‘’</code> 为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号 <code>”“”</code>. 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes:</div><div class="line">    <span class="keyword">print</span> (<span class="string">"This is much nicer.\n"</span></div><div class="line">           <span class="string">"Do it this way.\n"</span>)</div><div class="line">No:</div><div class="line">      <span class="keyword">print</span> <span class="string">"""This is pretty ugly.</span></div><div class="line">  Don't do this.</div><div class="line">  """</div></pre></td></tr></table></figure>
<h3 id="文件和sockets"><a href="#文件和sockets" class="headerlink" title="文件和sockets"></a>文件和sockets</h3><blockquote>
<p>Tip 在文件和 <code>sockets</code> 结束时, 显式的关闭它.</p>
</blockquote>
<p>除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如:</p>
<ol>
<li>它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽.</li>
<li>持有文件将会阻止对于文件的其他诸如移动、删除之类的操作.</li>
<li>仅仅是从逻辑上关闭文件和 sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会跑出异常, 并使得问题快速显现出来.</li>
</ol>
<p>而且, 幻想当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因:</p>
<ol>
<li>没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的 Python 实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长.</li>
<li>对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等).</li>
</ol>
<p>推荐使用 “with”语句 以管理文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">"hello.txt"</span>) <span class="keyword">as</span> hello_file:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> hello_file:</div><div class="line">        <span class="keyword">print</span> line</div></pre></td></tr></table></figure>
<p>对于不支持使用 <code>with</code> 语句的类似文件的对象,使用 <code>contextlib.closing():</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> contextlib</div><div class="line"></div><div class="line"><span class="keyword">with</span> contextlib.closing(urllib.urlopen(<span class="string">"http://www.python.org/"</span>)) <span class="keyword">as</span> front_page:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> front_page:</div><div class="line">        <span class="keyword">print</span> line</div></pre></td></tr></table></figure>
<p>Legacy AppEngine 中 Python 2.5 的代码如使用 <code>with</code> 语句, 需要添加 <code>from __future__ import with_statement</code>.</p>
<h3 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h3><blockquote>
<p>Tip 为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p>
</blockquote>
<p>TODO 注释应该在所有开头处包含”TODO”字符串, 紧跟着是用括号括起来的你的名字, email 地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的 TODO 格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了 TODO 注释并不保证写的人会亲自解决问题. 当你写了一个 TODO, 请注上你的名字.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># TODO(kl@gmail.com): Use a "*" here for string repetition.</span></div><div class="line"><span class="comment"># TODO(Zeke) Change this to use relations.</span></div></pre></td></tr></table></figure>
<p>如果你的TODO是”将来做某事”的形式, 那么请确保你包含了一个指定的日期(“2009年11月解决”)或者一个特定的事件(“等到所有的客户都可以处理XML请求就移除这些代码”).</p>
<h3 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h3><blockquote>
<p>Tip 每个导入应该独占一行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes: <span class="keyword">import</span> os</div><div class="line">     <span class="keyword">import</span> sys</div><div class="line">No:  <span class="keyword">import</span> os, sys</div></pre></td></tr></table></figure>
<p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:</p>
<ol>
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序指定导入</li>
</ol>
<p>每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> foo</div><div class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</div><div class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> baz</div><div class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> Quux</div><div class="line"><span class="keyword">from</span> Foob <span class="keyword">import</span> ar</div></pre></td></tr></table></figure>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><blockquote>
<p>Tip 通常每个语句应该独占一行</p>
</blockquote>
<p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 <code>try/except</code> 这样做, 因为 <code>try</code> 和 <code>except</code> 不能放在同一行.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Yes:</div><div class="line"></div><div class="line">  <span class="keyword">if</span> foo: bar(foo)</div><div class="line">No:</div><div class="line"></div><div class="line">  <span class="keyword">if</span> foo: bar(foo)</div><div class="line">  <span class="keyword">else</span>:   baz(foo)</div><div class="line"></div><div class="line">  <span class="keyword">try</span>:               bar(foo)</div><div class="line">  <span class="keyword">except</span> ValueError: baz(foo)</div><div class="line"></div><div class="line">  <span class="keyword">try</span>:</div><div class="line">      bar(foo)</div><div class="line">  <span class="keyword">except</span> ValueError: baz(foo)</div></pre></td></tr></table></figure>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><blockquote>
<p>Tip 在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.</p>
</blockquote>
<p>(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)<br>另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 <code>get_foo()</code> 和 <code>set_foo()</code> 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.</p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><blockquote>
<p>Tip <code>module_name</code>, <code>package_name</code>, <code>ClassName</code>, <code>method_name</code>, <code>ExceptionName</code>, <code>function_name</code>, <code>GLOBAL_VAR_NAME</code>, <code>instance_var_name</code>, <code>function_parameter_name</code>, <code>local_var_name</code>.</p>
</blockquote>
<p><strong>应该避免的名称</strong></p>
<ul>
<li>单字符名称, 除了计数器和迭代器.</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称(Python保留, 例如<strong>init</strong>)</li>
</ul>
<p><strong>命名约定</strong></p>
<ol>
<li>所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.</li>
<li>用单下划线(<code>_</code>)开头表示模块变量或函数是protected的(使用 <code>import * from</code> 时不会包含).</li>
<li>用双下划线(<code>__</code>)开头的实例变量或方法表示类内私有.</li>
<li>将相关的类和顶级函数放在同一个模块里. 不像 Java, 没必要限制一个类一个模块.</li>
<li>对类名使用大写字母开头的单词(如 CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如 <code>lower_with_under.py</code> ). 尽管已经有很多现存的模块使用类似于 <code>CapWords.py</code> 这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</li>
</ol>
<p><strong>Python 之父 Guido 推荐的规范</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Public</th>
<th style="text-align:left">Internal</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Modules</td>
<td style="text-align:left"><code>lower_with_under</code></td>
<td style="text-align:left"><code>_lower_with_under</code></td>
</tr>
<tr>
<td style="text-align:left">Packages</td>
<td style="text-align:left"><code>lower_with_under</code></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">Classes</td>
<td style="text-align:left"><code>CapWords</code></td>
<td style="text-align:left"><code>_CapWords</code></td>
</tr>
<tr>
<td style="text-align:left">Exceptions</td>
<td style="text-align:left"><code>CapWords</code></td>
<td style="text-align:left">x </td>
</tr>
<tr>
<td style="text-align:left">Functions</td>
<td style="text-align:left"><code>lower_with_under()</code></td>
<td style="text-align:left"><code>_lower_with_under()</code></td>
</tr>
<tr>
<td style="text-align:left">Global/Class Constants</td>
<td style="text-align:left"><code>CAPS_WITH_UNDER</code></td>
<td style="text-align:left"><code>_CAPS_WITH_UNDER</code></td>
</tr>
<tr>
<td style="text-align:left">Global/Class Variables</td>
<td style="text-align:left"><code>lower_with_under</code></td>
<td style="text-align:left"><code>_lower_with_under</code></td>
</tr>
<tr>
<td style="text-align:left">Instance Variables</td>
<td style="text-align:left"><code>lower_with_under</code></td>
<td style="text-align:left"><code>_lower_with_under(protected)</code> or <code>__lower_with_under (private)</code></td>
</tr>
<tr>
<td style="text-align:left">Method Names</td>
<td style="text-align:left"><code>lower_with_under()</code></td>
<td style="text-align:left"><code>_lower_with_under() (protected)</code> or <code>__lower_with_under() (private)</code></td>
</tr>
<tr>
<td style="text-align:left">Function/Method Parameters</td>
<td style="text-align:left"><code>lower_with_under</code></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">Local Variables</td>
<td style="text-align:left"><code>lower_with_under</code></td>
<td style="text-align:left">x     </td>
</tr>
</tbody>
</table>
<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><blockquote>
<p>Tip 即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.</p>
</blockquote>
<p>在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查 <code>if __name__ == &#39;__main__&#39;</code> , 这样当模块被导入时主程序就不会被执行.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">      ...</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用 pydoc 时执行的操作.</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_language_rules/" target="_blank" rel="external">Python语言规范</a></li>
<li><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/" target="_blank" rel="external">Python风格规范</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个统一的编程风格不但能够增强代码可读性，也可以避免许多低级问题。本文转载自 &lt;a href=&quot;http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/&quot;&gt;zh-google-styleguide&lt;/a&gt;这个项目，方便自己查阅，如果有更新也会提 PR 做出自己的贡献。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="转载" scheme="http://wdxtub.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="风格" scheme="http://wdxtub.com/tags/%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="Python" scheme="http://wdxtub.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java 编码风格指南</title>
    <link href="http://wdxtub.com/2016/10/13/java-style-guide/"/>
    <id>http://wdxtub.com/2016/10/13/java-style-guide/</id>
    <published>2016-10-12T22:38:42.000Z</published>
    <updated>2016-10-12T23:16:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个统一的编程风格不但能够增强代码可读性，也可以避免许多低级问题。本文转载自 Hawstein 的<a href="http://hawstein.com/posts/google-java-style.html" target="_blank" rel="external">博客</a>，我做了一些格式调整方便自己查阅。如果有更新也会在这里维护下去。</p>
<a id="more"></a>
<hr>
<p>这份文档是 Google Java 编程风格规范的完整定义。当且仅当一个 Java 源文件符合此文档中的规则， 我们才认为它符合 Google 的 Java 编程风格。</p>
<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。</p>
<p><strong>1.1 术语说明</strong></p>
<p>在本文档中，除非另有说明：</p>
<ol>
<li>术语 class 可表示一个普通类，枚举类，接口或是 annotation 类型(<code>@interface</code>)</li>
<li>术语 comment 只用来指代实现的注释(implementation comments)，我们不使用 documentation comments 一词，而是用 Javadoc。</li>
</ol>
<p>其他的术语说明会偶尔在后面的文档出现。</p>
<p><strong>1.2 指南说明</strong></p>
<p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循 Google 编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>
<h2 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为 <code>.java</code>。</p>
<h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式为 UTF-8。</p>
<h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><p><strong>2.3.1 空白字符</strong></p>
<p>除了行结束符序列，ASCII 水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>
<ol>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ol>
<p><strong>2.3.2 特殊转义序列</strong></p>
<p>对于具有特殊转义序列的任何字符(<code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\f</code>, <code>\r</code>, <code>&quot;</code>, <code>&#39;</code> 及 <code>\</code>)，我们使用它的转义序列，而不是相应的八进制(比如 <code>\012</code>)或 Unicode(比如 <code>\u000a</code>)转义。</p>
<p><strong>2.3.3 非ASCII字符</strong></p>
<p>对于剩余的非 ASCII 字符，是使用实际的 Unicode 字符(比如 ∞)，还是使用等价的 Unicode 转义符(比如 <code>\u221e</code>)，取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>Tip: 在使用 Unicode 转义符或是一些实际的 Unicode 字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String unitAbbrev = <span class="string">"μs"</span>;                                 | 赞，即使没有注释也非常清晰</div><div class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>; <span class="comment">// "μs"                    | 允许，但没有理由要这样做</span></div><div class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>; <span class="comment">// Greek letter mu, "s"    | 允许，但这样做显得笨拙还容易出错</span></div><div class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>;                            | 很糟，读者根本看不出这是什么</div><div class="line"><span class="keyword">return</span> <span class="string">'\ufeff'</span> + content; <span class="comment">// byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Tip: 大胆去用非ASCII字符，如果真的有需要的话</p>
</blockquote>
<h2 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h2><p>一个源文件包含(按顺序地)：</p>
<ol>
<li>许可证或版权信息(如有需要)</li>
<li>package语句</li>
<li>import语句</li>
<li>一个顶级类(只有一个)</li>
</ol>
<p>以上每个部分之间用一个空行隔开。</p>
<h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p>package 语句不换行，列限制(4.4节)并不适用于 package 语句。(即 package 语句写在一行里)</p>
<h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><p><strong>3.3.1 import 不要使用通配符</strong></p>
<p>即，不要出现类似这样的import语句：<code>import java.util.*;</code></p>
<p><strong>3.3.2 不要换行</strong></p>
<p>import 语句不换行，列限制(4.4节)并不适用于 import 语句。(每个 import 语句独立成行)</p>
<p><strong>3.3.3 顺序和间距</strong></p>
<p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>
<ol>
<li>所有的静态导入独立成组</li>
<li><code>com.google</code> imports(仅当这个源文件是在 <code>com.google</code> 包下)</li>
<li>第三方的包。每个顶级包为一组，字典序。例如：<code>android</code>, <code>com</code>, <code>junit</code>, <code>org</code>, <code>sun</code></li>
<li><code>java imports</code></li>
<li><code>javax imports</code></li>
</ol>
<p>组内不空行，按字典序排列。</p>
<h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><p><strong>3.4.1 只有一个顶级类声明</strong></p>
<p>每个顶级类都在一个与它同名的源文件中(当然，还包含 <code>.java</code> 后缀)。</p>
<p>例外：<code>package-info.java</code>，该文件中可没有 <code>package-info</code> 类。</p>
<p><strong>3.4.2 类成员顺序</strong></p>
<p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<p><em>3.4.2.1 重载：永不分离</em></p>
<p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>
<h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><p><strong>4.1.1 使用大括号(即使是可选的)</strong></p>
<p>大括号与 <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code> 语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<p><strong>4.1.2 非空块：K &amp; R 风格</strong></p>
<p>对于非空块和块状结构，大括号遵循 Kernighan 和 Ritchie 风格 (Egyptian brackets):</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (condition()) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        something();</div><div class="line">      &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</div><div class="line">        recover();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>4.8.1 节给出了enum类的一些例外。</p>
<p><strong>4.1.3 空块：可以用简洁版本</strong></p>
<p>一个空的块状结构里什么也不包含，大括号可以简洁地写成 <code>{}</code>，不需要换行。例外：如果它是一个多块语句的一部分(<code>if/else</code> 或 <code>try/catch/finally</code>) ，即使大括号内没内容，右大括号也要换行。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h3><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>
<h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每个语句后要换行。</p>
<h3 id="4-4-列限制：80-或-100"><a href="#4-4-列限制：80-或-100" class="headerlink" title="4.4 列限制：80 或 100"></a>4.4 列限制：80 或 100</h3><p>一个项目可以选择一行 80 个字符或 100 个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<ol>
<li>不可能满足列限制的行(例如，Javadoc 中的一个长 URL，或是一个长的 JSNI 方法参考)。</li>
<li>package 和 import 语句(见3.2节和3.3节)。</li>
<li>注释中那些可能被剪切并粘贴到 shell 中的命令行。</li>
</ol>
<h3 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h3><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80 或 100 个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<blockquote>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
</blockquote>
<p><strong>4.5.1 从哪里断开</strong></p>
<p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ol>
<li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如 <code>+</code>，它将位于下一行)。注意：这一点与 Google 其它语言的编程风格不同(如 C++ 和 JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(<code>.</code>)，类型界限中的 <code>&amp;</code>（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch 块中的管道符号(<code>catch (FooException | BarException e</code>)</li>
<li>如果在<code>赋值运算符</code>处断开，通常的做法是在该符号后断开(比如 <code>=</code>，它与前面的内容留在同一行)。这条规则也适用于 foreach 语句中的分号。</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
</ol>
<p><strong>4.5.2 自动换行时缩进至少+4个空格</strong></p>
<p>自动换行时，第一行后的每一行至少比第一行多缩进 4 个空格(注意：制表符不用于缩进。见 2.3.1节)。</p>
<p>当存在连续自动换行时，缩进可能会多缩进不只 4 个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<p>第 4.6.3 水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p>
<h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><p><strong>4.6.1 垂直空白</strong></p>
<p>以下情况需要使用一个空行：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul>
<li>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
</ul>
</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import 语句)</li>
<li>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li>
</ol>
<p><strong>4.6.2 水平空白</strong></p>
<p>除了语言需求和其它规则，并且除了文字，注释和 Javadoc 用到单个空格，单个 ASCII 空格也出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如 <code>if</code>, <code>for</code>, <code>catch</code> 等)。</li>
<li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如 <code>else</code>, <code>catch</code>)。</li>
<li>在任何左大括号前(<code>{</code>)，两个例外：<ul>
<li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li>
<li><code>String[][] x = foo</code>;(括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的 <code>&amp;</code>(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li>
<li>catch 块中的管道符号(<code>catch (FooException | BarException e</code>)。</li>
<li><code>foreach</code> 语句中的分号。</li>
</ul>
</li>
<li>在<code>,</code>, <code>:</code>, <code>;</code> 及右括号(<code>)</code>)后</li>
<li>如果在一条语句后做注释，则双斜杠(<code>//</code>)两边都要空格。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：<code>List list</code>。</li>
<li>数组初始化中，大括号内的空格是可选的，即 <code>new int[] {5, 6}</code> 和 <code>new int[] { 5, 6 }</code> 都是可以的。</li>
</ol>
<blockquote>
<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<p><strong>4.6.3 水平对齐：不做要求</strong></p>
<p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// this is fine</span></div><div class="line"><span class="keyword">private</span> Color color; <span class="comment">// this too</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>   x;      <span class="comment">// permitted, but future edits</span></div><div class="line"><span class="keyword">private</span> Color color;  <span class="comment">// may leave it unaligned</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h3 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h3><p>除非作者和 reviewer 都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个 Java 运算符优先级表。</p>
<h3 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h3><p><strong>4.8.1 枚举类</strong></p>
<p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</div></pre></td></tr></table></figure>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<p><strong>4.8.2 变量声明</strong></p>
<p><em>4.8.2.1 每次只声明一个变量</em></p>
<p>不要使用组合声明，比如 <code>int a, b;</code>。</p>
<p><em>4.8.2.2 需要时才声明，并尽快进行初始化</em></p>
<p>不要在一个代码块的开头把局部变量一次性都声明了(这是 c 语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<p><strong>4.8.3 数组</strong></p>
<p><em>4.8.3.1 数组初始化：可写成块状结构</em></p>
<p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">  <span class="number">0</span>,</div><div class="line">  <span class="number">1</span>,</div><div class="line">  <span class="number">2</span>,</div><div class="line">  <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">  <span class="number">0</span>, <span class="number">1</span>,</div><div class="line">  <span class="number">2</span>, <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p><em>4.8.3.2 非C风格的数组声明</em></p>
<p>中括号是类型的一部分：<code>String[] args</code>， 而非 <code>String args[]</code>。</p>
<p><strong>4.8.4 switch 语句</strong></p>
<p>术语说明：switch 块的大括号内是一个或多个语句组。每个语句组包含一个或多个 switch 标签(<code>case FOO:</code> 或 <code>default:</code>)，后面跟着一条或多条语句。</p>
<p><em>4.8.4.1 缩进</em></p>
<p>与其它块状结构一致，switch 块中的内容缩进为 2 个空格。</p>
<p>每个 switch 标签后新起一行，再缩进 2 个空格，写下一条或多条语句。</p>
<p><em>4.8.4.2 Fall-through：注释</em></p>
<p>在一个 switch 块内，每个语句组要么通过 <code>break</code>, <code>continue</code>, <code>return</code> 或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是 OK 的(典型的是用 <code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是 default)中出现。示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> (input) &#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">  <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">    prepareOneOrTwo();</div><div class="line">    <span class="comment">// fall through</span></div><div class="line">  <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">    handleOneTwoOrThree();</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    handleLargeNumber(input);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>4.8.4.3 default的情况要写出来</em></p>
<p>每个 switch 语句都包含一个 default 语句组，即使它什么代码也不包含。</p>
<p><strong>4.8.5 注解(Annotations)</strong></p>
<p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</div></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<p><strong>4.8.6 注释</strong></p>
<p><em>4.8.6.1 块注释风格</em></p>
<p>块注释与其周围的代码在同一缩进级别。它们可以是 <code>/* ... */</code> 风格，也可以是 <code>// ...</code> 风格。对于多行的 <code>/* ... */</code> 注释，后续行必须从 <code>*</code> 开始， 并且与前一行的 <code>*</code> 对齐。以下示例注释都是 OK 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * This is          // And so           /* Or you can</div><div class="line"> * okay.            // is this.          * even do this. */</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<blockquote>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 <code>/* ... */</code>。</p>
</blockquote>
<p><strong>4.8.7 Modifiers</strong></p>
<p>类和成员的 modifiers 如果存在，则按 Java 语言规范中推荐的顺序出现。</p>
<p><code>public protected private abstract static final transient volatile synchronized native strictfp</code></p>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用 ASCII 字母和数字，因此每个有效的标识符名称都能匹配正则表达式 <code>\w+</code>。</p>
<p>在 Google 其它编程语言风格中使用的特殊前缀或后缀，如 <code>name_</code>, <code>mName</code>, <code>s_name</code> 和 <code>kName</code>，在 Java 编程风格中都不再使用。</p>
<h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><p><strong>5.2.1 包名</strong></p>
<p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>
<p><strong>5.2.2 类名</strong></p>
<p>类名都以 UpperCamelCase 风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以 Test 结束。例如，<code>HashTest</code>或 <code>HashIntegrationTest</code>。</p>
<p><strong>5.2.3 方法名</strong></p>
<p>方法名都以 lowerCamelCase 风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<p>下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如 <code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p>
<p><strong>5.2.4 常量名</strong></p>
<p>常量名命名模式为 <code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态 final 字段，但不是所有静态 final 字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Constants</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>);  <span class="comment">// because Joiner is immutable</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</div><div class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</div><div class="line"></div><div class="line"><span class="comment">// Not constants</span></div><div class="line"><span class="keyword">static</span> String nonFinal = <span class="string">"non-final"</span>;</div><div class="line"><span class="keyword">final</span> String nonStatic = <span class="string">"non-static"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</div></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<p><strong>5.2.5 非常量字段名</strong></p>
<p>非常量字段名以 lowerCamelCase 风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<p><strong>5.2.6 参数名</strong></p>
<p>参数名以 lowerCamelCase 风格编写。</p>
<p>参数应该避免用单个字符命名。</p>
<p><strong>5.2.7 局部变量名</strong></p>
<p>局部变量名以 lowerCamelCase 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<p><strong>5.2.8 类型变量名</strong></p>
<p>类型变量可用以下两种风格之一进行命名：</p>
<ul>
<li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
<li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ul>
<h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p>驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如 IPv6 或 iOS)。Google 指定了以下的转换方案。</p>
<p>名字从<code>散文形式</code>(prose form)开始:</p>
<ol>
<li>把短语转换为纯 ASCII 码，并且移除任何单引号。例如：<code>Müller’s algorithm</code> 将变成 <code>Muellers algorithm</code>。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如<code>AdWords</code> 将分割成 <code>ad words</code>)。 需要注意的是 iOS 并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ul>
</li>
<li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Prose form                Correct               Incorrect</div><div class="line">------------------------------------------------------------------</div><div class="line"><span class="string">"XML HTTP request"</span>        XmlHttpRequest        XMLHTTPRequest</div><div class="line"><span class="string">"new customer ID"</span>         newCustomerId         newCustomerID</div><div class="line"><span class="string">"inner stopwatch"</span>         innerStopwatch        innerStopWatch</div><div class="line"><span class="string">"supports IPv6 on iOS?"</span>   supportsIpv6OnIos     supportsIPv6OnIOS</div><div class="line"><span class="string">"YouTube importer"</span>        YouTubeImporter</div><div class="line">                          YoutubeImporter*</div></pre></td></tr></table></figure>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：nonempty 和 non-empty 都是正确的，因此方法名 checkNonempty 和 checkNonEmpty 也都是正确的。</p>
</blockquote>
<h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h2><h3 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h3><p>只要是合法的，就把 <code>@Override</code> 注解给用上。</p>
<h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 AssertionError 重新抛出。)</p>
<p>如果它确实是不需要在 catch 块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">int</span> i = Integer.parseInt(response);</div><div class="line">  <span class="keyword">return</span> handleNumericResponse(i);</div><div class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</div><div class="line">  <span class="comment">// it's not numeric; that's fine, just continue</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> handleTextResponse(response);</div></pre></td></tr></table></figure>
<p>例外：在测试中，如果一个捕获的异常被命名为 expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  emptyStack.pop();</div><div class="line">  fail();</div><div class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h3><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Foo aFoo = ...;</div><div class="line">Foo.aStaticMethod(); <span class="comment">// good</span></div><div class="line">aFoo.aStaticMethod(); <span class="comment">// bad</span></div><div class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// very bad</span></div></pre></td></tr></table></figure>
<h3 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h3><p>极少会去重写 <code>Object.finalize</code>。</p>
<blockquote>
<p>Tip：不要使用 finalize。如果你非要使用它，请先仔细阅读和理解 Effective Java 第 7 条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h2 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><p><strong>7.1.1 一般形式</strong></p>
<p>Javadoc 块的基本格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Multiple lines of Javadoc text are written here,</div><div class="line"> * wrapped normally...</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></div></pre></td></tr></table></figure>
<p>基本格式总是 OK 的。当整个 Javadoc 块能容纳于一行时(且没有 Javadoc 标记 @XXX)，可以使用单行形式。</p>
<p><strong>7.1.2 段落</strong></p>
<p>空行(即，只包含最左侧星号的行)会出现在段落之间和 Javadoc 标记(@XXX)之前(如果有的话)。除了第一个段落，每个段落第一个单词前都有标签 <code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p>
<p><strong>7.1.3 Javadoc 标记</strong></p>
<p>标准的 Javadoc 标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这 4 种标记如果出现，描述都不能为空。当描述无法在一行中容纳，连续行需要至少再缩进 4 个空格。</p>
<h3 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h3><p>每个类或成员的 Javadoc 以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以 <code>A {@code Foo} is a...</code> 或 <code>This method returns...</code> 开头, 它也不会是一个完整的祈使句，如 <code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的 Javadoc 写成 <code>/** @return the customer ID */</code>，这是不正确的。它应该写成 <code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h3 id="7-3-哪里需要使用-Javadoc"><a href="#7-3-哪里需要使用-Javadoc" class="headerlink" title="7.3 哪里需要使用 Javadoc"></a>7.3 哪里需要使用 Javadoc</h3><p>至少在每个 public 类及它的每个 public 和 protected 成员处使用 Javadoc，以下是一些例外：</p>
<p><strong>7.3.1 例外：不言自明的方法</strong></p>
<p>对于简单明显的方法如 getFoo，Javadoc 是可选的(即，是可以不写的)。这种情况下除了写 “Returns the foo”，确实也没有什么值得写了。</p>
<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名 getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语 canonical name 指的是什么。</p>
</blockquote>
<p><strong>7.3.2 例外：重写</strong></p>
<p>如果一个方法重写了超类中的方法，那么 Javadoc 并非必需的。</p>
<p><strong>7.3.3 可选的 Javadoc</strong></p>
<p>对于包外不可见的类和方法，如有需要，也是要使用 Javadoc 的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成 Javadoc，这样更统一更友好。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="external">Google Java Style 原文</a></li>
<li>译者 @Hawstein</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个统一的编程风格不但能够增强代码可读性，也可以避免许多低级问题。本文转载自 Hawstein 的&lt;a href=&quot;http://hawstein.com/posts/google-java-style.html&quot;&gt;博客&lt;/a&gt;，我做了一些格式调整方便自己查阅。如果有更新也会在这里维护下去。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="Java" scheme="http://wdxtub.com/tags/Java/"/>
    
      <category term="转载" scheme="http://wdxtub.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="风格" scheme="http://wdxtub.com/tags/%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>技术文档写作指南</title>
    <link href="http://wdxtub.com/2016/10/10/tech-doc-guide/"/>
    <id>http://wdxtub.com/2016/10/10/tech-doc-guide/</id>
    <published>2016-10-09T23:29:13.000Z</published>
    <updated>2016-10-10T14:44:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个成功且可持续的项目，除了良好的架构设计和高质量的代码外，清晰且易于理解的技术文档也是必不可少的一部分。本文结合自己工作中文档写作的一些经验，来说说如何把文档写好。</p>
<a id="more"></a>
<hr>
<p>可能是因为长期写博客的缘故，在写作这个事儿上，我还是有比较严苛的要求的。技术文档和技术博客在很多方面有相似之处，比方说都是写给技术人员（爱好者）看的。在我看来，很多现在网上的技术博客基本上连技术文档的要求都达不到，或者说文档和博客各占一点，半桶水瞎晃荡。简单来说，博客重在原理与引起读者的兴趣与思考，文档重在细节与方便技术人员解决问题，那这个标准去套，应该就能看出问题所在了。</p>
<h2 id="为什么要写文档"><a href="#为什么要写文档" class="headerlink" title="为什么要写文档"></a>为什么要写文档</h2><p>前面说文档和博客的相似，最主要是在技术层面上的相似，甚至眼光放广一点，跟写代码也非常相似，都需要好的设计与架构。而为什么要写文档呢？大约有以下原因：</p>
<ul>
<li>项目合作需要：比方说前后端分离之后，利用接口进行连接，那么需要接口文档。</li>
<li>项目维护需要：总体项目开发完成后，维护人员和后期开发人员需要相关文档来照看工作。</li>
<li>思路整理需要：通过撰写技术文档，可以梳理好整个系统技术相关思路，更加负责的开发人员会在这个过程中进行优化，使系统更好</li>
<li>技术积累需要：通过抽取一些与业务无关的部分，能够在之后的开发中进行复用，就需要文档支持</li>
</ul>
<p>简单来说，就是 <strong>总结 -&gt; 积累 -&gt; 提高 -&gt; 复用</strong> 的过程。</p>
<h2 id="怎么写好文档"><a href="#怎么写好文档" class="headerlink" title="怎么写好文档"></a>怎么写好文档</h2><p>我们都希望接手的工作有优秀的文档，但是写文档的时候却常常过于随便。所以我们不妨从『好』文档的标准说起：</p>
<ul>
<li>准确：不会给人模棱两可的感觉</li>
<li>清晰：不会给人写了很多但不知道写了啥的感觉</li>
<li>完整：不会给人话说到一半戛然而止的感觉</li>
<li>简洁：不会给人没话找话说的感觉</li>
<li>有组织：不会给人不知道要去哪里看什么内容的感觉</li>
<li>可读性好：不会给人每个字都认识但就是看不懂的感觉</li>
<li>任务导向：不会给人跑题不说重点的感觉。</li>
</ul>
<p>总结一下，其实就是信息架构的能力，是不是发现和代码架构很像？再延伸一些，是不是想到了各种框架？什么 MVC 什么 MVVM 其实不就是某种意义上的层次模块分明吗？</p>
<p>其实凡是需要进行组织的事物，都需要架构能力。好的架构师一定是善于观察善于思考善于提炼的，这些能力在写代码中可以训练，在写文档写博客中同样可以训练。而阅读各种经典，其实就是在向各类牛人们学习，为什么别人这么写我看得爽，我能不能也这么写。一旦有了这个思路，就不怕不知道怎么提高了。</p>
<p>从这个角度出发，来具体给出一些建议吧，因为基于自己的经验，不会特别全面，如果需要全面学习的话，可以去看看技术写作的相关书籍。</p>
<ol>
<li>总分总：这个从小时候就常用的方式可以说是最符合人类思维习惯的结构。如果要用比较时髦的词就是『金字塔原理』，无论是正金字塔还是倒金字塔，可以根据需要进行选择。</li>
<li>一图胜千言：涉及到诸多概念及其相关联系时，不要过多解释，画一个清晰的图，比什么效果都好。不需要太复杂，简单的 UML 已经足够。</li>
<li>看人下菜：针对不同的群体要有不同的写作侧重点。如果是给运维人员看的，那么重点是要说清楚各个操作以及相关逻辑；如果是给非技术人员看的，一定要尽量『看图说话』，联系他们能够理解的概念来跨越不同职业的鸿沟；如果是给交接的技术同事看的，重点是架构设计以及代码原理。</li>
<li>少即是多：文档太长，自己更新起来累，别人看起来也累，维护起来更累。所以去掉各类套话，说重点，并保证及时更新。</li>
<li>理论结合实际：涉及需要操作或者修改的部分，一定要配上简单的例子，否则别人连如何去开始第一步都不知道。</li>
<li>我用 Markdown：简单、够用，这就是唯一的理由。</li>
</ol>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>很多时候我们在面对各种做不完的需求时，最先牺牲的就是文档质量，而整个项目的腐化就是从一点一滴开始的。努力安排好时间，不要降低对自己对项目的要求，需求仔细评估排期，一旦做了，就一次做好。否则如果是长期项目，就是坑自己；如果是临时交接，就是坑别人。为什么不可以直接把事情做好，非要后面辛辛苦苦擦屁股搞得好像很努力很负责一样呢？</p>
<p>要我说，一开始没做好，就是最大的不负责。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个成功且可持续的项目，除了良好的架构设计和高质量的代码外，清晰且易于理解的技术文档也是必不可少的一部分。本文结合自己工作中文档写作的一些经验，来说说如何把文档写好。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="技术" scheme="http://wdxtub.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="文档" scheme="http://wdxtub.com/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>第十七周 - 勇敢的心</title>
    <link href="http://wdxtub.com/2016/10/07/brave-heart/"/>
    <id>http://wdxtub.com/2016/10/07/brave-heart/</id>
    <published>2016-10-07T14:39:48.000Z</published>
    <updated>2016-10-07T15:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>我不是一块石头，也不是一滴眼泪，我只是一只小鸟，在寻找家的方向。我不是一粒沙子，也不是一声轻叹，我只是一个孩子，在寻找爱的怀抱。</p>
<a id="more"></a>
<hr>
<p>盼星星盼月亮终于盼来了一年中唯二的七天长假，一想到这个我就特别伤感。没有出去旅游，简单和同学聚了聚，窝在家里试图『找回生活』，这就是我的国庆假期。</p>
<p>记得刚上大学那会儿，有一次去听讲座，演讲者说十年没有休息，每天都是工作日，当时觉得特别震撼。虽然不明白工作的怎么回事儿，但是也从此开始了早起。转眼七年过去了，早起倒是一直坚持了下来，不过同样意识到的是『十年没有休息』完全可能是演讲效果需要。</p>
<p>之前一直想要追求工作与生活的平衡，在家的几天意识到，其实哪有什么平衡，有的只是取舍。能和老同学一起打打球吃吃火锅，已经是很幸福的事情。尤其是沿着老城区弯弯曲曲的路一直走，更意识到直截了当是工作与规划，顺势而为随遇而安才是生活与洒脱。</p>
<p>跑久了，停下来思考，也别有一番滋味。</p>
<p>爷爷身体最近不太好，加上假期中的各类互联网大佬健康出状况的新闻，着实令人担忧，希望老人家早日康复。自己也要好好锻炼，保重身体。</p>
<p>天天在家，也没啥特别好说的，只能说想清楚了很多事情，之后会走得更加坚定吧。</p>
<p>凭着一颗永不哭泣勇敢的心，在撒满星星的天空迎着风飞舞，在布满力量的大地带着痛狂奔。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不是一块石头，也不是一滴眼泪，我只是一只小鸟，在寻找家的方向。我不是一粒沙子，也不是一声轻叹，我只是一个孩子，在寻找爱的怀抱。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="国庆" scheme="http://wdxtub.com/tags/%E5%9B%BD%E5%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>【湄公河行动】血性报国</title>
    <link href="http://wdxtub.com/2016/10/05/operation-mekong-film/"/>
    <id>http://wdxtub.com/2016/10/05/operation-mekong-film/</id>
    <published>2016-10-05T12:09:12.000Z</published>
    <updated>2016-10-06T00:30:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>张涵予：你说『歌功颂德』没意思，但是有些人，你不歌颂，这世界上就没人知道他们的存在，没人知道他们为了保卫我们的国民安全做出了怎样的牺牲。</p>
<a id="more"></a>
<hr>
<p>2011 年，湄公河，两条船，92 万粒冰毒，13 名中国船员全部死亡。糯康，劫持中国商船，放上毒品，被泰国军方『查获』，一出栽赃陷害的利益交互戏码。境外执法，四次抓捕，老挝收网，最终还中国船员清白。</p>
<p>这是真正的『湄公河行动』，也是本片的真实事件来源。详细的来源经过在参考链接中，这里便不再赘述，主要还是聊聊电影，和看完之后的一些想法。</p>
<p>国产电影死气沉沉烂片当道的 2016 终于因为这么一部主旋律电影多了点生机。白百合已然成为了烂片风向标，我已经无法用脑残粉来说服自己去看她的作品了。王珞丹稍微好一些，但也没有到让人眼前一亮的程度。其他一票靠脸吃饭演技负数的，客气一点说就是『妈的智障』。</p>
<p>在这样的背景下，爱惜羽毛的演员就显得弥足珍贵。张涵予不必说，彭于晏的转变着实让我惊喜，除了有些略微出戏的台湾普通话，基本没有什么值得吐槽的点了，小伙子好好加油，在这个小鲜肉比蠢比烂比脑残比娘炮的时代，正常发挥就足够鹤立鸡群了。</p>
<p><strong>!!剧透预警!!</strong></p>
<p>简单来说，本片和从前的主旋律电影相比有了巨大的突破，无论是尺度还是形式，算得上是新时代的『样板戏』，反毒品和爱国教育不再流于表面文字，真正开始走心了，我相信有认真看电影和脑子正常的人，大约能感受到影片想要传达的东西。</p>
<p>最后直升机飞出来的场景，加上恢宏的配乐，真的有点感动，等了这么久，终于有了一部实打实的中国大片。片中展现出来我们缉毒警过硬的专业素质和各种高科技装备，真的很让人激动，原来我们也可以这样！</p>
<p>毒品这个事儿，把人性的丑恶都释放了出来。娃娃兵俄罗斯轮盘赌钱的场景看得我不寒而栗，谁想让自己的孩子以这样的方式长大？</p>
<p><strong>剧透结束</strong></p>
<p>这是一个值得肯定的进步，一个突破口可能小，但是有了第一个，后面的就不用等太久。要我说，『外国月亮特别圆』的时代迟早要过去，那些跪习惯的人，是不是也该感受下新时代的脉搏了？对自己国家的价值观嗤之以鼻，却跪舔着所谓普世价值，不多说，我要去建设四个现代化了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.zhihu.com/question/48224721" target="_blank" rel="external">如何评价电影《湄公河行动》？</a></li>
<li><a href="https://www.zhihu.com/question/51174663" target="_blank" rel="external">如何评价缅甸毒枭糯康的故事？</a></li>
<li><a href="https://book.douban.com/subject/25812563/" target="_blank" rel="external">洗冤伏枭录</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;张涵予：你说『歌功颂德』没意思，但是有些人，你不歌颂，这世界上就没人知道他们的存在，没人知道他们为了保卫我们的国民安全做出了怎样的牺牲。&lt;/p&gt;
    
    </summary>
    
      <category term="Movie" scheme="http://wdxtub.com/categories/Movie/"/>
    
    
      <category term="国庆" scheme="http://wdxtub.com/tags/%E5%9B%BD%E5%BA%86/"/>
    
      <category term="2016" scheme="http://wdxtub.com/tags/2016/"/>
    
      <category term="缉毒" scheme="http://wdxtub.com/tags/%E7%BC%89%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>从文明 V 聊起</title>
    <link href="http://wdxtub.com/2016/10/05/from-civilization-v/"/>
    <id>http://wdxtub.com/2016/10/05/from-civilization-v/</id>
    <published>2016-10-05T09:43:35.000Z</published>
    <updated>2016-10-05T11:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>『文明』系列游戏以化简与抽象的艺术创造了一个平行世界，而真正让玩家投入大把时间的，是一种自己能够掌控世界的幻觉。系列最新作『文明六』将于 10 月 21 日发售，谨以此文表达期待之情。</p>
<a id="more"></a>
<hr>
<p>『文明五』断断续续玩了五六年，在众多内容更新包的加持下，除了因为初期设计（比如城市）而几乎无法改动的部分，整个游戏的可玩性已经到了极高的水平。而不同版本，不同风格的玩家都可以玩出唯一属于自己的游戏，所以本文也仅仅是我一家之言。欢迎大家来聊聊自己是怎么玩『文明』的。</p>
<h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p>正如席德梅尔所说，游戏本身并不是作为『模拟器』而打造的，很多设计是出于『游戏性』考虑的。所以游戏可以作为我们理解世界的辅助，而不是成为判断是非的准则，毕竟要是玩个游戏就能理解世界，那世界就要全乱套了。</p>
<p>只是娱乐，只是娱乐，只是娱乐。</p>
<p>接下来所说的都只是关于游戏本身，之所以会跟我们看到的现实生活有点像，是因为这就是『文明』系列的卖点。游戏中无论是经济、科技、文化、外交、军事等等都只是现实的极度化简的极度化简，拥有相关背景知识能够帮助我们做决策，但是不能反过来倒推，不然就要闹比『刻舟求剑』还要大的笑话了。</p>
<p>好了，走起！</p>
<h2 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h2><blockquote>
<p>社会主义阶段的最根本的任务就是发展生产力 —— 邓小平</p>
</blockquote>
<p>经济问题在游戏里远没有现实生活复杂，但仍旧涉及到方方面面。发展的竞赛，从文明发源之初便未曾停息，而这个就有点投胎的意思，因为位置本身在游戏初期就是最重要的资源。如果城市所在之处地形平坦资源丰富有河有海再有一面是高山，那真是含着金钥匙出生，如果再独占一些奢侈品资源，那经济发展就是蹭蹭的。</p>
<p>不过作为小城邦，如果拥有了如此得天独厚的天时地利，那么想要闷声发大财就很难了，毕竟这么一大块肥肉，任谁看了都眼馋。</p>
<p>人口，作为游戏中最重要的指标，需要在早期着力发展。人多了城市就大，城市大了分工就更细，分工更细了就可能在各行各业出伟人，伟人可以极大加快历史的进程。但是人和资源本身互相制约的，城市不能无限制扩张，如果一个城市占用了太多资源，周边城市的发展就容易陷入停滞。所以在建造之初，就要有一个全盘规划，是要打造成科技城市、文化城市、旅游城市还是宗教圣地，不提前准备是不行的。不同城市间通过贸易进行优势互补，最终形成一个良好的生态。</p>
<p>吃饱穿暖之后就要大力发展生产力，最终生产力可以转化成钱。无论是矿产资源（煤铁铜铝油铀等）还是奢侈资源（酒糖丝绸香料金银等），都是后续发展的基础。但是不可能一个国家全占了，所以就需要通过交易来互通有无了。国内的贸易收益要比国际贸易少得多，尤其是大航海时代开启之后，漂洋过海可以赚大钱，万一发现了没人的地方，占着就是自己的。不过航海也要科技跟得上，否则强行超越时代，非常拖节奏。</p>
<p>而国内的经济建设可以按照五年计划的路子走，大力发展公路和铁路，连通之后所带来的效率的提升，真的是『要致富，先修路』。而且基础建设需要大量的人力，顺带解决了失业率的问题。</p>
<p>发展的过程中，稳定很重要，打仗不但会破坏贸易路线，更会极大降低人民的幸福感，幸福感一低，工作效率和军队的战斗力都会低下，所以还是要哄好大家。</p>
<p>提高幸福感和其他信仰加成可以考虑建造『奇迹』，比如长城、紫禁城、埃菲尔铁塔、金字塔等等，但是一定要注意造这些大项目劳民伤财，需要的时间也比较久，如果没有强大的军事实力，还是不要作死。</p>
<p>一句话：经济发展就是物尽其用和想办法促使物尽其用。</p>
<h2 id="科技"><a href="#科技" class="headerlink" title="科技"></a>科技</h2><blockquote>
<p>不管过去还是现在，科学都是对一切可能的事物的观察。所谓先见之明，是对即将出现的事物的认识，而这认识要有一个过程 ——达·芬奇</p>
</blockquote>
<p>科技发展的前提条件是人口和生产力，是一个螺旋上升的过程，不要追求面面俱到，但是跨时代的研究一定要下大力气攻克，比如火药、蒸汽机、航海、计算机这些，领先进入新时代有很大优势。除了反过来提高生产力，用于军事方面也是一个主要的动力，在别的国家都没有飞机的时候有了飞机，在别的国家没有核潜艇的时候有了核潜艇，基本上就等于控制了天空和海洋。</p>
<p>因为科研和对应的设施建设（比如大学、研究所等等）是相辅相成的，和城市发展一样，也要提前做好计划，尽量不要出现因为一个地方卡住而全局等待的情况。</p>
<p>一句话：厉害，只是因为科技领先一整代。</p>
<h2 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h2><blockquote>
<p>质胜文则野，文胜质则史。文质彬彬，然后君子 —— 孔子</p>
</blockquote>
<p>和显示生活一样，一个宗教的诞生需要一个历史级别人物的诞生，然后就是设定教义以及通过贸易和传教者传播开来。一个有意思的设定是如果侵略的城市和我们信仰相同，并且深受我们文化影响的话，战争造成的负面影响非常有限，可能几个回合就可以恢复正常了，真是温水煮青蛙的和平演变啊。</p>
<p>因为我们采用上帝视角，所以文化制度如何其实各有各的优缺点，没有最完美的制度，只有最合适的制度。</p>
<p>不过通过天然的文化影响其实范围有限，还是要利用贸易强推，当然，这时候出现举世闻名的大人物，就特别有帮助了。</p>
<p>一句话：强势文化背后是更高级别的生活水平或者更为狂热的宗教色彩。</p>
<h2 id="外交"><a href="#外交" class="headerlink" title="外交"></a>外交</h2><blockquote>
<p>对任何国家的信任，不可超过其本身利益所能约束的范围 —— 华盛顿</p>
</blockquote>
<p>游戏中的外交其实选项很少，唯一比较有趣的是类似联合国的组织，可以用各种方式制裁特定国家，比方说那个国家特有的奢侈品禁止交易，这就少了很多经济来源。总体来说，老祖宗的经验还是非常有用的，配合上军事就是『远交近攻』。</p>
<p>很多套路都可以在历史上在生活中找到对应，比如：</p>
<ul>
<li>两个大国最好不要直接接壤，要么隔海，要么中间有其他国家做缓冲</li>
<li>小国都是墙头草，国家越小，变得越快，不过反过来看，准备好足够的钱就好</li>
<li>操纵选举是一个逆袭的好方式</li>
<li>能经济上解决的就不要打仗，要打仗就要一鼓作气</li>
<li>割地赔款通常只能换来十个回合的和平，到时候还是得挨打</li>
<li>小国家的意义在于投票的时候可以把黑的说成白的，因为是少数服从多数，所以可以这么玩</li>
<li>周围的国家开始吞并小国的时候，一定要阻止或者制裁，不然敌人力量强大了，身边出现一个战斗力很强的国家，总是不太让人放心</li>
</ul>
<p>一句话：利益有三，短期中期长期，基本上一个决策只能取一到两项，没有十全十美的办法。</p>
<h2 id="军事"><a href="#军事" class="headerlink" title="军事"></a>军事</h2><blockquote>
<p>苟利国家生死以，岂因祸福避趋之 —— 林则徐</p>
</blockquote>
<p>战争是一个颇为剑走偏锋的做法，相比于自己辛辛苦苦发展城市，直接开抢是成本很低的方式。牺牲一两支部队，就能换来一个经济技术文化资源中心及其配套的贸易线路，非常划算。但这只是明面上的数字，除了军队本身的建设和维护费用外，还需要大量的金钱和设施来安抚人民和其他小国家。不过话说回来，如果国家需要某种资源，但是资源拥有方狮子大开口，也许打一仗一了百了更加靠谱（现实生活中这么想就很危险了）。</p>
<p>除了因为资源开战，再就是争夺世界霸权需要打仗了，毕竟前霸主是不会禅让的。两个大国角力，就是看谁的科技强，谁的动员能力抢，兵法是战术层面的，战略层面真的就是实打实的比发展。常备军的维护成本非常高，比较靠谱的做法是维持少量高机动能力的精英部队，需要时快速组建新的军队。</p>
<p>不过战术层面还是有很多可以玩的，比如：</p>
<ul>
<li>在重要的关口利用大军事家开一个堡垒，可以做到一夫当关万夫莫开</li>
<li>远程武器用于消弱对方有生力量，但是攻城还是需要近战肉搏</li>
<li>速度很重要，能一个回合解决就不要给人机会</li>
<li>保证侧翼安全之后快速把部队展开，集中火力各个歼灭</li>
<li>善于利用地形，把敌人引诱到不利于他们发挥的地方去</li>
<li>避免进入消耗战，劳民伤财</li>
<li>三十六计里的套路几乎都可以用上</li>
<li>最重要的，兵贵神速</li>
</ul>
<p>一句话：战场上，最重要的就是信息，知道敌人在哪里，大约就赢了一大半。</p>
<h2 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h2><blockquote>
<p>你们给我搞的这个游戏啊，EXCITED —— 匿名</p>
</blockquote>
<p>新作马上就要出了，城市的参与感增加了很多，不过比起这个，我还是希望各个系统的深度能够做得更大一些（这样我就不用自己写模拟器了）。所谓深度，就是权衡的点更多一些，或者说不能让玩家有十全十美的选择（这就是系统平衡性问题了）。</p>
<p>文明六一出，2017 就过去了，我们 2018 年见。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『文明』系列游戏以化简与抽象的艺术创造了一个平行世界，而真正让玩家投入大把时间的，是一种自己能够掌控世界的幻觉。系列最新作『文明六』将于 10 月 21 日发售，谨以此文表达期待之情。&lt;/p&gt;
    
    </summary>
    
      <category term="Game" scheme="http://wdxtub.com/categories/Game/"/>
    
    
      <category term="策略" scheme="http://wdxtub.com/tags/%E7%AD%96%E7%95%A5/"/>
    
      <category term="游戏" scheme="http://wdxtub.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="文明" scheme="http://wdxtub.com/tags/%E6%96%87%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>数据平台技术指南</title>
    <link href="http://wdxtub.com/2016/10/01/data-platform-tech-guide/"/>
    <id>http://wdxtub.com/2016/10/01/data-platform-tech-guide/</id>
    <published>2016-09-30T23:15:22.000Z</published>
    <updated>2016-10-02T03:55:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近大部分精力花在为公司搭建统一的数据平台上，从技术选型到最终落地像打通隧道一样艰难和痛快，本文主要介绍数据平台的技术相关实践与思考。具体的设计思路可以参考我的另一篇文章 - <a href="http://wdxtub.com/2016/10/01/data-platform-design-guide/">数据平台设计指南</a></p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2016.10.2: 完成初稿</li>
</ul>
<p>数据平台的解决方案有很多，从数据仓库到现在最火的 Hadoop/Spark，随着开源运动的蓬勃发展，几乎各个组件都有足够多的项目供开发者选择。虽然不需要自己做轮子了，但是如何选择合适的轮子拼成最高效的车子，仍然需要技术团队谨慎选择。</p>
<p>尤其是不同的团队不同的风格不同的业务需求，不太存在一劳永逸的做法，无论是架构还是功能，都应该保证螺旋上升的趋势，以应对各种突发情况。</p>
<p>注：本文不涉及数据平台的设计思路，感兴趣请参考 <a href="http://wdxtub.com/2016/10/01/data-platform-design-guide/">数据平台设计指南</a></p>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>为了方便后文的叙述，先简要介绍一下背景。数据平台项目原先只是我们部门内部的一个项目，和我之前接手的日志项目基本处于并行的状态。数据平台项目和日志项目唯一的连接点在于数据的存储，共用一个 Elasticsearch 集群。</p>
<p>日志这边最初的架构是利用 Rsyslog + Logstash 直接把日志汇总到 Elasticsearch(后面用 ES 表示) 中。而数据平台的后端原先是基于 Ruby On Rails(后面用 RoR 表示) 的，功能也比较简单，一方面是利用 ES 的聚合来进行基本的日志数据收集，另一方面是从第三方的统计服务中（比如 Google Analysis）拉取数据，给前端进行展示。</p>
<p>在已有系统的基础上进行改动和完全从头开始搭建是两种完全不同的思路。虽然说从零开始几乎不受任何束缚，但实际情况中基本不太可能立马推倒重来，毕竟已有系统虽然比较简陋，至少还在服役中。于是只能一个模块一个模块进行调整，一是保证服务稳定，二是在人力不够的条件下，防止步子太大出问题。</p>
<p>所以在重构一开始，我给自己的设计定下的目标是：</p>
<ul>
<li>尽量小的改动（影响面越小，可能出的问题就越少）</li>
<li>尽量就近服务（因为要提供全球范围内的服务，需要尽量优化线路）</li>
<li>减少跨机房数据同步量（尤其是跨海传输，带宽和稳定性所带来的额外成本很令人头疼）</li>
</ul>
<p>在经历了一系列技术测试之后（详情见最后的链接），由我确定了日志部分的架构，而数据平台部分的架构由我的同事确定，后台部分最终选择的技术是：</p>
<p><strong>ELK Stack + Kafka + Spring MVC</strong></p>
<p>细节与原因如下：</p>
<ul>
<li>ELK Stack 在业界的实践中已被证明是比较靠谱的日志解决方案，加上原来的日志系统就已经采用了 ELK 方案，改动的成本较低</li>
<li>用 Logstash 取代了原先采用的系统级的 Rsyslog 用来传输日志，方便管理和配置（Logstash 的配置还是非常好写的）</li>
<li>加入了 Kafka 用作消息队列，把 Logstash 与 Elasticsearch 解耦，所有日志会先经过 Kafka，再由 Kafka 导入 Elasticsearch</li>
<li>出于性能考虑和其他一些因素的考虑，用基于 Java 的 Spring MVC 取代 Ruby on Rails，虽然 RoR 的开发效率很高，但是我和另一个核心开发人员都不熟悉 Ruby，所以转为 Java（至少好招人）</li>
</ul>
<p>总体来说，整个架构的调整需要考虑的因素很多，除了开发团队的技术栈外，更多是投入和产出的权衡。很多时候能争取到的资源非常有限，就需要想办法巧妇做少米之炊了。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>虽然前面提到的技术不多，但因为全球部署和全球服务的缘故，架构图还是有一些复杂的。理论上完美的方案，实际落地的时候会出现各种各样的因为物理因素导致的问题。这也是为什么要一个一个地区和市场去推进，不然不断涌现的各种问题，在人力不足的时候会把团队拖入『死亡进军』的状况。架构图做了一定化简（只有中、美两机房），具体如下：</p>
<p><img src="/images/14753730024863.jpg" alt=""></p>
<p>围绕着以 ES 集群为存储核心，整个系统主要分三大块：</p>
<ol>
<li>日志收集与分析</li>
<li>埋点上报与数据接入</li>
<li>数据与日志统计与分析</li>
</ol>
<p>因为采用了不同地区的不同服务提供商，还需要兼顾数据同步的问题，整个系统经过不断演化，最终达到了如上图所示的比较稳定的结构。不过由于我手头上的事情实在太多，具体的数据量、用户量、消息量评估只完成了最基本的部分。目前的重心主要还是在系统的完善与功能添加中，很多技术债是在人力不足的情况下不得不背的，对于我和另外一个同事这样的强迫症来说，只能尽量多做一点是一点了。</p>
<p>最后再强调一次，数据是拿来用的，一定要跟各个部门深入沟通好需求，并在不断磨合中找到让大家都最舒服的合作方式。很多技术和架构选择都是非常业务相关的，这里就不多提了。后面主要讨论的会是『如何让整一个系统流畅运行起来』这个问题</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>这一部分主要是介绍 <a href="http://wdxtub.com/2016/10/01/data-platform-design-guide/">数据平台设计指南</a> 中提到的四个主要流程的具体实现和相关思路。</p>
<h3 id="采集与预处理"><a href="#采集与预处理" class="headerlink" title="采集与预处理"></a>采集与预处理</h3><ul>
<li>日志的收集要跟不同团队的开发人员对接，了解真正有价值的参数，减少带宽与存储的消耗（毕竟日志中会有大量的冗余）</li>
<li>提取日志中真正有价值的东西</li>
<li>分词问题，string 字段要在 logstash 阶段就要设置为 <code>not_index</code></li>
<li>数据上报系统采用 ID 与密钥配对方式进行有效性校验，并且利用另外的数据库做权限控制，具体需要做到的粒度可以根据需求进行控制</li>
<li>做多机房同步的时候尽量利用云服务本身提供的服务，自己做数据同步很辛苦，得不偿失</li>
<li>不同的服务要有流量和数据量控制，保证不因为单个系统的不稳定而拖挂整个系统</li>
<li>不同数据源如何对齐，公共字段需要仔细设置</li>
<li>写日志的时候就要考虑未来的处理和应用，尤其是和已有数据源的对齐</li>
<li>字段同名但类型不同导致的索引冲突问题</li>
<li>设计埋点及统计字段时一定要基于具体的统计需求，不能为了打点而打点，字段是什么，后面要如何使用，不同的字段如何联系与互动，都需要事先想好</li>
<li>专注于核心指标，不同指标的优先级是什么</li>
<li>界面、事件和事件参数独立，但必须有公共的统计参数（最好两个一上，冗余保证后续数据清洗及验证的准确性）</li>
<li>维护埋点，增加上报的信息量（同样大小的前提下），减少上报压力</li>
</ul>
<p>整个 ETL 过程需要建立固定的流程，为开发者准备好对应的接口、文档及测试系统。对于老数据的导入也需要有自动化可重复的工具链。而对于需要内网才能访问的系统，可以考虑在内网假设服务，然后走数据上报的流程进行数据汇总。</p>
<h3 id="清洗与分类"><a href="#清洗与分类" class="headerlink" title="清洗与分类"></a>清洗与分类</h3><p>这一层主要是进行分发与过滤，利用 Logstash 和 Kafka 的诸多特性，不需要写很多代码就可以完成。一些考虑有：</p>
<ul>
<li>根据服务区分 Kafka 中不同的 topic，来进行隔离，虽然是同一管道，但是也要尽量避免相互影响</li>
<li>日志中可能有的非法字符以及过长的日志需要进行过滤，不然进入 ES 可能会导致问题</li>
<li>需要有定期任务机制，清理不需要的数据，保存到 S3 这种比较便宜的存储中</li>
<li>贯彻二八原则，20% 最有价值的数据进行结构化存储，剩下的以文本形式保存在云存储中，除非必要时，一般不需要动</li>
</ul>
<p>因为不需要跟外部系统交互，这部分其实需要做的东西不算太多，但是作为最重要的中转站，需要保证高可用性，这就需要对各个组件有一定深入了解了。</p>
<h3 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h3><p>基于 Luence 的 ES 集群在处理中文的时候可能有坑，不过目前 IK 分词基本可以满足需求。其他需要注意的有</p>
<ul>
<li>ES 集群的监控一定要做，要好好做，可以采用业界流行的方案，也需要了解 ES 的基本 API 和相关设置。 </li>
<li>如果可能的话，尽量多配几台机器，可以由专门的机器做不负责存储只负责调度的主节点以及只负责存储及查询的数据节点，具体需要根据需求进行调整</li>
<li>很多暴露出来的问题，回归到最初都是因为存的时候太随意导致的，还是那句话，即使是类似 NoSQL 的存储，好的设计仍然无比重要</li>
<li>监控部分需要和运维密切配合，以达到快速反应，保证服务质量的目的</li>
<li>安全是非常重要的话题，内部系统的好处在于可以用白名单与二次验证的机制保证数据安全，具体的备份策略也需要仔细斟酌，找到一个平衡</li>
</ul>
<h3 id="展示与应用"><a href="#展示与应用" class="headerlink" title="展示与应用"></a>展示与应用</h3><p>这部分主要是前端展现与后端数据挖掘，这两部分涉及的话题太多，这里就不展开了，简单说一下。</p>
<ul>
<li>数据可视化的核心在于目标明确，而这个目标怎么找到，一定是和相关业务部门沟通出来的，不能是开发人员拍脑袋</li>
<li>需要结合不同部门之前的业务实践，走之前提到了『取代-超越』两步战略</li>
<li>随着数据量的增大，可以结合 Spark/Hadoop 等分布式计算框架来进行数据挖掘，当然，这是比较后面的工作了，可能需要专门找人来负责</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在数据平台的建设中，总是会有各种各样的小问题，我的感受是临时的补丁不是不能打，但是一定要及时找出问题的根源，从系统的层面解决掉，不然补丁好修复，但是补丁的补丁，甚至补丁的补丁的补丁一多，很容易造成几乎无解的局面。</p>
<p>而对于系统中使用的相关技术，也一定要在『会用』的接触上深入理解其工作原理和运行机制，不需要深入到代码级别，但至少要能在出了问题之后第一时间有基本的排查思路，不然依靠 google 和 stackoverflow 编程，只会给同事带来巨大的困扰。</p>
<p>当然，本文只是目前我的一些想法，会随着系统的开发不断更新内容。如果大家有做过相关系统的经验，欢迎共同讨论，如果在深圳的话，可以约出来吃个饭聊一聊嘛。</p>
<h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul>
<li><a href="http://wdxtub.com/2016/08/15/kafka-guide/">Kafka 指南</a></li>
<li><a href="http://wdxtub.com/2016/07/26/elk-guide/">ELK 指南</a></li>
<li><a href="http://wdxtub.com/2016/09/28/elasticsearch-cluster-guide/">Elasticsearch 集群指南</a></li>
<li><a href="http://wdxtub.com/2016/07/24/elastic-search-guide/">Elasticsearch 入门指南</a></li>
<li><a href="http://wdxtub.com/2016/07/24/logstash-guide/">Logstash 入门指南</a></li>
<li><a href="http://wdxtub.com/2016/08/18/logstash-kafka-guide/">Logstash 连接 Kafka 指南</a></li>
<li><a href="http://wdxtub.com/2016/08/17/rsyslog-kafka-guide/">Rsyslog 连接 Kafka 指南</a></li>
<li><a href="http://wdxtub.com/2016/08/12/rsyslog-logstash-guide/">Rsyslog + Logstash 日志传输指南</a></li>
<li><a href="http://wdxtub.com/2016/09/28/linux-server-check-guide/">Linux 服务器检查指南</a></li>
<li><a href="http://wdxtub.com/2016/07/26/crontab-guide/">Crontab 指南</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近大部分精力花在为公司搭建统一的数据平台上，从技术选型到最终落地像打通隧道一样艰难和痛快，本文主要介绍数据平台的技术相关实践与思考。具体的设计思路可以参考我的另一篇文章 - &lt;a href=&quot;http://wdxtub.com/2016/10/01/data-platform-design-guide/&quot;&gt;数据平台设计指南&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="技术" scheme="http://wdxtub.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据平台设计指南</title>
    <link href="http://wdxtub.com/2016/10/01/data-platform-design-guide/"/>
    <id>http://wdxtub.com/2016/10/01/data-platform-design-guide/</id>
    <published>2016-09-30T23:11:20.000Z</published>
    <updated>2016-10-01T03:03:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近大部分精力花在为公司搭建统一的数据平台上，在不断地踩坑中慢慢摸索出了一套行之有效的方法，本文主要介绍数据平台的流程设计与相关思考，具体的技术实现可以参考我的另一篇文章 - <a href="http://wdxtub.com/2016/10/01/data-platform-tech-guide/">数据平台技术指南</a></p>
<a id="more"></a>
<hr>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>市场、运营、研发还是内部管理每天都会产生各种各样的数据及报表，一是用于监控各项事宜的运作情况，二是给决策提供更多有价值的信息。随着公司的快速发展与业务的不断扩大，产生和消费的数据也越来越多，传统手工以及简单的电子化统计已经不能满足各个部门的需求。我们来看看下面这三个问题：</p>
<ol>
<li>从前收集数据和制作报表只需要半天，但是现在随着需要统计的内容增多，可能需要三天，也就是说数据最重要的时效性大打折扣</li>
<li>很多时候依靠单一部门的数据无法完成复杂的分析，但由于不同部门间天生较高的沟通成本，除了需要专人对接外，还需要走一定的流程，就把原本简单的工作变得复杂了，甚至因为各种推诿最终不了了之</li>
<li>不同部门的业务统计很多需求是一致或者类似的，只是统计的数据维度不同，这也意味着很多没有意义的重复劳动</li>
</ol>
<p>为了解决上面提到的三个问题，一个统一的内部数据平台便应运而生。在此基础上，我们还从另外两个维度扩展了数据平台，一是更基础的服务监控，二是更高级的智能分析。更让我骄傲的是，整个项目的核心开发者只有三人，其中前端一人，后台及服务器两人（在此感谢曾为此项目付出过的其他同事）。</p>
<p>从白手起家到接入来自公司不同部门的十多项业务，从最初简单的原型到现在初具规模的系统，每次重构与架构调整，都是大家一起摸着石头过河淌出来的。虽然还有许多堆积的需求（缺人力呀），但只要地基打得好，就不怕盖高楼。</p>
<p>注：本文不涉及具体的技术实践，感兴趣请参考 <a href="http://wdxtub.com/2016/10/01/data-platform-tech-guide/">数据平台技术指南</a></p>
<h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>在这个『大数据』与『云计算』概念满天飞的年代，我对于数据平台的思考应该是偏谨慎的。这是屁股决定脑袋的一个非常清晰的例子，创业公司最需要的就是给投资人描绘一个愿景，那么就需要带上各种时髦的词汇；而对于我在做的数据平台来说，最重要的是提供有价值的服务，真正能帮助各个部门节约时间、综合信息、提高决策效率的服务。正因如此，我没有给数据平台制定一个看得见摸不着的目标，而是打算分两步走：</p>
<p><strong>第一步：取代</strong>。深入各个部门的业务流程与实践，了解第一手的需求。这里的取代，指的是利用数据平台自动化处理数据生成报表，把他们从繁重的人工统计中解放出来（用 Excel 仍然需要大量需要人工参与的中间过程）。只要各个部门把数据接入并打通数据流，我们就可以根据需求制作相应的页面（这里主要指长期且能够流程化处理的需求）。当他们需要具体数据与报表时，只需要登录网站查看即可。如果需要做一些临时分析，也可以把数据导出为 Excel 表格自行处理。</p>
<p><strong>第二步：超越</strong>。在接入了不同部门的数据后，数据平台实际上拥有了综合不同数据源进行协同统计的可能，相当于把原先部门范围的数据辐射到了公司范围，各个部门都可以方便地利用更加全面的信息进行业务判断。所谓超越，指数据平台应该能完成原先 Excel 不能做（或者是难以做好）的深入分析。通过挖掘隐藏在数据背后的规律，给各个部门提供更加简单轻松的数据服务。</p>
<p>我给这个方案起了个名字，叫做『数据自治自洽』，本质是给公司和用户带来有价值的数据产品，用来给公司的各项业务提供数据支持。作为公司平台化和数据化的重要一环，数据平台的意义不仅在于数据本身，而是通过信息共享与集体智慧形成某种意义上的『群脑』，最终转化成为更有意义的产品和服务。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>其实数据平台的流程化简之后都差不多，难点不在于思路而在于具体实现。这里简要介绍一下各个步骤中的设计要点，具体的实现可在 <a href="http://wdxtub.com/2016/10/01/data-platform-tech-guide/">数据平台技术指南</a> 查看</p>
<h3 id="采集与预处理"><a href="#采集与预处理" class="headerlink" title="采集与预处理"></a>采集与预处理</h3><p>数据采集也许是最被低估的一个步骤。做过数据挖掘和模型分析的朋友应该都知道『Garbage in, Garbage out』这个简单的道理，数据模型可谓是数据平台的灵魂，而数据采集的方法和策略是数据模型的基础，一定要谨慎。如果要用一句话总结数据收集的思路，那就是：</p>
<p><strong>从用数据的角度出发收集数据，而不是反过来</strong></p>
<p>具体的思路就有很多的扩展了，主要三点：细粒度、围绕业务、概念层级一致。</p>
<h3 id="清洗与分类"><a href="#清洗与分类" class="headerlink" title="清洗与分类"></a>清洗与分类</h3><p>这部分的内容需要大量的跨部门沟通，比如不同业务系统的日志信息筛选过滤，一是能够有效减少无意义的存储（日志中会有大量重复信息），二是为后续的存储与查询打下良好的基础。</p>
<p>我们目前是按照业务来进行划分的，不同的业务有不同的工作流，优点在于比较灵活，缺点在于没有把通用的部分抽出来（主要问题是目前公共的部分并不多）。</p>
<p>在这一步我们需要进行概念统一，比方说外部代号与内部代号的映射，这样在之后的统计分析中，我们能够以比较简洁的代码和模型去处理，而不用再去纠结格式与编号问题（与网络分层模型的思路一致）</p>
<h3 id="存储与查询"><a href="#存储与查询" class="headerlink" title="存储与查询"></a>存储与查询</h3><p>这一步唯一需要统一的就是『存储是为了查询』。存的时候随意存，查的时候肯定就没办法随意。我见过很多把 NoSQL 数据库当做 MySQL 来用的做法，那不就是自找苦吃嘛。</p>
<p>提一下『数据自治自洽』这个概念，自治指的是数据流的通畅以及自动根据多个系统的信息综合验证补全修复非正常数据，自洽指的是通过不同数据源得出的结论是说得通可以互相验证的。</p>
<p>这一阶段技术细节比较多，本文不再深入。</p>
<h3 id="展示与应用"><a href="#展示与应用" class="headerlink" title="展示与应用"></a>展示与应用</h3><p>展示与应用是数据平台价值的外现，也是各个部门实际能够体验感知的部分。根据前面提出的『取代-超越』两步走思路，注定是一个比较耗费人力且业务导向的工作。</p>
<p>这就涉及到数据可视化和数据挖掘的内容了，等我多看些书，请教下相关领域老司机，经过一段时间再找各个部门反馈一下再来更新后续内容。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>能够从零开始参与公司数据平台的设计和建设，感觉自己非常幸运，同时也责任重大。而在具体实践中能够一点一点把自己在学校里所学的东西真正用起来，才算是真正完成了从书本到实践的最终转变。说『数据』的公司很多，但是真正用好『数据』的公司却不多，在我看来，数据平台的设计和开发，与其说是一个项目，不如说是火种。到底能不能燎原，就要看具体能推进到什么程度了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近大部分精力花在为公司搭建统一的数据平台上，在不断地踩坑中慢慢摸索出了一套行之有效的方法，本文主要介绍数据平台的流程设计与相关思考，具体的技术实现可以参考我的另一篇文章 - &lt;a href=&quot;http://wdxtub.com/2016/10/01/data-platform-tech-guide/&quot;&gt;数据平台技术指南&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="设计" scheme="http://wdxtub.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="数据" scheme="http://wdxtub.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>第十六周 - 林中鸟</title>
    <link href="http://wdxtub.com/2016/09/30/bird-in-forest/"/>
    <id>http://wdxtub.com/2016/09/30/bird-in-forest/</id>
    <published>2016-09-30T13:10:08.000Z</published>
    <updated>2016-09-30T15:01:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>来不及祈祷就开始奔跑，总觉得外面世界有多美好。角落太寂静城市太喧闹，这世界很忙其实我都知道。离开了地面就随风飘摇，决定要走遍天涯心比天高。</p>
<a id="more"></a>
<hr>
<p>这周应该是开始工作以来最忙的一周，为了迎接一年中最长的假期，多做点工作也是应该的。能在节前完成大部分计划好的任务，并且把服务器的稳定性提高到足以安心放假的水平，我对自己的表现还是很满意的，毕竟我已经爆发出了洪荒之力了。</p>
<p>因为负责另外一个项目的同事在欧洲玩耍，我临时帮忙维护对应的日常工作。上周风平浪静，本以为能够相安无事度过这周，却在周末就出了乱子，警报邮件和短信直接把收件箱发爆。既来之则安之，就硬着头皮上吧。</p>
<p>临时接班最痛苦的是需要在缺乏上下文的情况下快速搞清楚状况，并在出问题的时候准确定位及处理。虽说同事千叮咛万嘱咐，不过还是有之前没有遇到的突发情况，于是我开始了翻日志查资料调配置测集群的工作，在忐忐忑忑中找到了问题所在，并顺利解决。</p>
<p>工作中遇到的很多问题，光看错误日志其实是颇为头疼医头脚疼医脚的方法，如果不深挖下去找到根源，这样的技术债迟早会让团队破产。这个时候之前打下的比较牢固的基础就发挥了作用，从虚拟机配置到垃圾回收机制，从网络通信到集群优化，看起来可能只是一点点改动，但需要做的分析和排查工作非常多。这不由得让我想起一个故事，大意是机器坏了，高价请来的工程师敲了一下就好了，于是付钱的人觉得很亏，花这么多钱就只为了这一下。而工程师说百分之一的价钱是为了敲这一下，而另外百分之九十九是为了确定这一下要敲在哪里。很多看起来暂时没用的偏基础的知识，在融会贯通后就起到的是这百分之九十九的作用，不然像无头苍蝇一样瞎折腾，不但问题解决不了，甚至可能把情况弄得更糟。</p>
<p>在公司做新业务，大家都不懂，其实是很正常的，但是一定要在每次掉坑里爬出来后学到点什么。除了插个牌子告诉大家这里有坑之外，更需要依靠合理的规范铺成一条路，这样后面的才可能跑自行车、汽车、火车等等。一直是泥泞的土路，肯定行不通。</p>
<p>周二深夜，公司正式在纽约发布了之前泄露的『小飞机』Mavic，看到我司直接甩出一个吊打一切的产品，自己内心确实是骄傲的，而且之后我也会参与到提供给用户的相关服务的设计和开发，想到自己的努力能让大家玩得更开心，拍得更精彩，就觉得忙一点累一点其实也是很有意义的。在这里我想特别感谢一下硬件研发相关的同事，是他们长期不懈努力精益求精，才让 Mavic 能够一发布就取得如此叫好又叫座的成绩。要知道做硬件和做软件不同，很多时候需要配合工厂和供应链的节奏，每个时间点的设定，都是根据发布日期倒推的，卡得很死。如果到某个时间点没有达到预计的进度，除了耽误时间，更是会带来各种实实在在的成本。相比之下，软件开发是一个顺序的工作，延迟主要是时间成本，虽然看起来轻松一些，但是一想到其他同事这么努力，还是希望自己能够拿出对得起他们的努力的作品。</p>
<p>其实任何创造价值的事情，都不太可能是轻松的。当初编辑问我是走『著』还是『编著』路线的时候，年少轻狂觉得要『著』，真正创造一些价值，而不是编撰整理成为搬运工。『创造价值』是『实现价值』的升级，所谓实现价值，可能是完成一个功能，一个项目。但是创造价值，则是在完成工作的基础上，通过深入思考，勇于承担责任，找到可以把工作做得更好，辐射影响力的方法。</p>
<p>当初选择回国选择到大疆，一是对于螺丝钉式工作的厌恶，二是想真正用自己的能力去承担更多的责任，三是渴望接受更大的挑战。虽然当初自己也不知道将来会变成怎样，但是一步一步走过来，一个一个小目标竟也都达到了，果然从心的路，就是最好的路。</p>
<p>放假前和 Prisma（就是那个火遍全球的照片风格化应用）的 CEO 以及投资顾问聊了聊，才知道原来他们一共就八个人，其中只有俩做研究。虽然利用深度学习进行风格化早在一年前就有人做出来，不过能够把它优化到能在移动设备上跑，也是非常了不起的工作（尤其考虑到他们是小团队）。不由得想起之前把一个平滑算法移植到 iOS 时的艰难，为了优化性能真是无所不用其极，最后也仅仅做到了『可以接受』的程度。而在具体的沟通过程中，我也深深意识到了拥有核心竞争力以及底层开发能力是多么重要的财富，没有牛逼的技术，再怎么吹商业思维也没用。</p>
<p>回家的路上我开始思考如何进一步在有限的时间内提高效率。一个人的高效其实是有限的，可能拿一个成功团队和一个失败团队比较，两个团队里最厉害的人提供的输出可能是差不多的，之所以会一个天上一个地下，更多的差别在于团队，而不在于个体（虽然团队也是由个体组成的）。</p>
<p>所以如何是一个团队成为成功团队，才是高效的秘密所在。一个优秀的技术领导，是能够在面对复杂问题时，不会被习惯和情绪左右，而是专注于问题本身，利用常识做出正确的判断。而这种做事的方法是会『传染』的，团队成员也会以这种方式处理问题，自然就能获得极高的解决问题的效率。真正的成功团队一定是从一个个坑中爬出来，越磨练越强大的，不可能是上几节课看几个视频就可以搞定的。在实战中提高技艺，反思每天的工作，用联系的方式去观察和思考问题，才可能找到真正的开门钥匙。</p>
<p>不由得想起笑傲江湖里的一段话：</p>
<blockquote>
<p>死招数破得再妙，遇上了活招数，免不了缚手缚脚，只有任人屠戮。这个‘活’字，你要牢牢记住了。学招时要活学，使招时要活使。倘若拘泥不化，便练熟了几千万手绝招，遇上了真正高手，终究还是给人家破得干干净净。</p>
<p>活学活使，只是第一步。要做到出手无招，那才真是踏入了高手的境界。你说‘各招浑成，敌人便无法可破’，这句话还只说对了一小半。不是‘浑成’，而是根本无招。你的剑招使得再浑成，只要有迹可寻，敌人便有隙可乘。但如你根本并无招式，敌人如何来破你的招式？</p>
</blockquote>
<p>我就像那一只林中的小鸟，努力挣脱冲向蓝天怀抱。勇敢的张开双臂闭上了双眼，远方离我只有一步之遥。那带血的羽毛不向命运乞讨，跌倒只能让我越飞越高。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来不及祈祷就开始奔跑，总觉得外面世界有多美好。角落太寂静城市太喧闹，这世界很忙其实我都知道。离开了地面就随风飘摇，决定要走遍天涯心比天高。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 集群指南</title>
    <link href="http://wdxtub.com/2016/09/28/elasticsearch-cluster-guide/"/>
    <id>http://wdxtub.com/2016/09/28/elasticsearch-cluster-guide/</id>
    <published>2016-09-28T13:03:57.000Z</published>
    <updated>2016-11-01T14:04:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch 集群的设置虽然比较简单，但是具体使用其实有很多需要注意的地方。本文结合工作中的实战经验，分享一下 Elasticsearch 集群的相关技巧。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2016.11.01: 更新导入数据过慢的解决方案</li>
<li>2016.09.28: 初稿完成，Elasticsearch 版本 2.4.0</li>
</ul>
<p>如果是第一次接触 Elasticsearch，不妨先看看我之前写的 <a href="http://wdxtub.com/2016/07/24/elastic-search-guide/">Elasticsearch 入门指南</a>，本文主要是介绍 Elasticsearch 集群相关的内容。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>虽然 Elasticsearch 的安装比较简单，不过我还是写了一个安装脚本，可以在<a href="https://github.com/wdxtub/wdxtools/tree/master/linux-script" target="_blank" rel="external">这里</a>查看，具体来说其实就两步，下载和解压，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">wget https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/tar/elasticsearch/2.4.0/elasticsearch-2.4.0.tar.gz</div><div class="line">tar -xvzf elasticsearch-2.4.0.tar.gz</div></pre></td></tr></table></figure>
<p>分别在集群中每台机器中完成安装即可，具体的启动也非常简单，如果要在前台，直接 <code>./bin/elasticsearch</code> 即可，如果要放到后台，则使用 <code>nohup ./bin/elasticsearch &amp;</code>。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置文件位于 <code>config</code> 文件夹中，其中 <code>elasticsearch.yml</code> 是 elasticsearch 的配置，而 <code>logging.yml</code> 是输出日志相关的设置。配置文件的内容有很多，不过因为默认值基本都够用了，所以我们只需要配置很少的内容。假设现在有两个节点，内部 IP 地址分别为 <code>A: 10.1.1.0</code> 和 <code>B: 10.1.1.1</code>，那么配置为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 节点 A</div><div class="line">cluster.name: wdxtubes</div><div class="line">node.name: &quot;es01&quot;</div><div class="line">bootstrap.mlockall: true</div><div class="line">network.host: 10.1.1.0</div><div class="line">network.publish_host: 10.1.1.0</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;10.1.1.1&quot;]</div><div class="line">discovery.zen.fd.ping_timeout: 120s</div><div class="line">discovery.zen.fd.ping_retries: 6</div><div class="line">discovery.zen.fd.ping_interval: 30s</div><div class="line"></div><div class="line"></div><div class="line"># 节点 B</div><div class="line">cluster.name: wdxtubes</div><div class="line">node.name: &quot;es02&quot;</div><div class="line">bootstrap.mlockall: true</div><div class="line">network.host: 10.1.1.1</div><div class="line">network.publish_host: 10.1.1.1</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;10.1.1.0&quot;]</div><div class="line">discovery.zen.fd.ping_timeout: 120s</div><div class="line">discovery.zen.fd.ping_retries: 6</div><div class="line">discovery.zen.fd.ping_interval: 30s</div></pre></td></tr></table></figure>
<p>这里需要注意的是我们采用单播的方式来进行集群中机器的查找，因为 elasticsearch 已经尽量帮我们做好了集群相关的工作，只要保证 <code>cluster.name</code> 一致，就可以自动发现。另外，我们调大了超时的间隔和互相 ping 发送的频率以及重试次数，防止某台机器在 Full GC 的时候因未能及时响应而造成的连锁反应（后面会详细说明）</p>
<p>多说一句，机器配置的时候，最好确保两台机器可以互相 ping 通，并开放所有端口的内部访问（如果是用云主机的话，尤其需要注意这一点）</p>
<p>如果需要扩展的话，只需要保证 <code>cluster.name</code> 一致即可，比如说现在新加入一台 <code>C: 10.1.1.2</code>，那么配置可以这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 节点 C</div><div class="line">cluster.name: wdxtubes</div><div class="line">node.name: &quot;es03&quot;</div><div class="line">bootstrap.mlockall: true</div><div class="line">network.host: 10.1.1.2</div><div class="line">network.publish_host: 10.1.1.2</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;10.1.1.0&quot;]</div><div class="line">discovery.zen.fd.ping_timeout: 120s</div><div class="line">discovery.zen.fd.ping_retries: 6</div><div class="line">discovery.zen.fd.ping_interval: 30s</div></pre></td></tr></table></figure>
<p>这里 <code>discovery.zen.ping.unicast.hosts</code> 中只需要填写原有集群中任意一台机器的地址即可。</p>
<p>然后我们可以在集群中的机器上使用 <code>curl http://10.1.1.0:9200/_cluster/health</code> 来查看集群状态。比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"cluster_name"</span>:<span class="string">"wdxtub-es"</span>,</div><div class="line">    <span class="attr">"status"</span>:<span class="string">"green"</span>,</div><div class="line">    <span class="attr">"timed_out"</span>:<span class="literal">false</span>,</div><div class="line">    <span class="attr">"number_of_nodes"</span>:<span class="number">2</span>,</div><div class="line">    <span class="attr">"number_of_data_nodes"</span>:<span class="number">2</span>,</div><div class="line">    <span class="attr">"active_primary_shards"</span>:<span class="number">821</span>,</div><div class="line">    <span class="attr">"active_shards"</span>:<span class="number">1642</span>,</div><div class="line">    <span class="attr">"relocating_shards"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"initializing_shards"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"unassigned_shards"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"delayed_unassigned_shards"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"number_of_pending_tasks"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"number_of_in_flight_fetch"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"task_max_waiting_in_queue_millis"</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">"active_shards_percent_as_number"</span>:<span class="number">100.0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果状态是 green，那就没有问题啦。下面我们会结合不同的实例进行介绍</p>
<h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p>Elasticsearch 的重启是一个非常需要按规矩操作的过程，否则会带来一系列的意想不到的问题，所以一定要按照官方建议的步骤来进行。</p>
<p>首先，因为 Elasticsearch 自带的高可用机制，一旦一个节点下线，就会在集群内部进行数据的重分配，会带来很多不必要的开销，所以需要先关闭，关闭方法是给集群发送一个请求，这个请求可以动态修改集群的设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">PUT /_cluster/settings</div><div class="line">&#123;</div><div class="line">  &quot;persistent&quot;: &#123;</div><div class="line">    &quot;cluster.routing.allocation.enable&quot;: &quot;none&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在重启之后需要进行数据恢复，如果停止索引并发送一个同步刷新请求，这个过程就会快很多，需要注意的是，如果此时有任何正在进行的索引操作，这个 flush 操作会失败，因此必要时我们可以重试多次，这是安全的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">POST /_flush/synced</div></pre></td></tr></table></figure>
<p>现在我们可以停止集群中的各个节点，完成重启或升级的操作。具体单台机器的操作可以看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rolling-upgrades.html#upgrade-node" target="_blank" rel="external">这里</a></p>
<p>完成之后，我们最好先启动那些 <code>node.master</code> 设置为 true 的节点（这也是默认设置），等到集群选举出了 master 节点，就可以继续添加数据节点了（即那些 <code>node.master</code> 为 false 且 <code>node.data</code> 为 true 的），这里我们可以用以下方式进行监控</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET _cat/health</div><div class="line"></div><div class="line">GET _cat/nodes</div></pre></td></tr></table></figure>
<p>每个节点加入集群之后，就会开始恢复本地保存的首要分片，一开始 <code>_cat/health</code> 查询的结果是 red，之后会变成 yellow，也就意味着所有的首要分片已经恢复了，但是其他的复制分片还没有恢复，因为我们一开始已经设置不恢复复制分片。</p>
<p>最后一步，我们需要重新开启集群的数据重分配，以保证集群的高可用性，操作也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">PUT /_cluster/settings</div><div class="line">&#123;</div><div class="line">  &quot;persistent&quot;: &#123;</div><div class="line">    &quot;cluster.routing.allocation.enable&quot;: &quot;all&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用 <code>_cat/health</code> 的结果为 green 时，则重启和恢复顺利完成。</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>无论是 Elasticsearch 官方还是社区，有很多插件可以完成监控的任务，但是本文只介绍默认的 API，主要是 <code>_cat</code> 和 <code>_cluster</code> 这两个接口，具体的文档可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html" target="_blank" rel="external">cat API</a> 和 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster.html" target="_blank" rel="external">cluster API</a> 中查看，这里简要介绍一下。</p>
<p>对于 <code>_cat</code> 接口，在请求后面加上 <code>?v</code> 就会输出详细信息，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">wdxtub:~$ curl 10.1.1.10:9200/_cat/master?v</div><div class="line">id                     host      ip        node   </div><div class="line">AoVFmiU4Q2SAHNVcMGPsWQ 10.1.1.11 10.1.1.11 node-2</div></pre></td></tr></table></figure>
<p>如果对于字段的名字有疑问，可以使用 <code>?help</code>，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">wdxtub:~$ curl 10.1.1.10:9200/_cat/master?<span class="built_in">help</span></div><div class="line">id   |   | node id    </div><div class="line">host | h | host name  </div><div class="line">ip   |   | ip address </div><div class="line">node | n | node name</div></pre></td></tr></table></figure>
<p>如果只想要查看指定字段，可以利用 <code>?h=</code> 来进行指定，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">wdxtub:~$ curl 10.1.1.10:9200/_cat/nodes?h=ip,port,heapPercent,name</div><div class="line">10.1.1.11 9300 64 node-2 </div><div class="line">10.1.1.10 9300 71 node-1</div></pre></td></tr></table></figure>
<p>对于带数字的输出，可以利用管道来进行排序，比如下面的命令就可以按照索引大小来进行排序（这里的 <code>-rnk8</code> 指的是按照第八列排序）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">wdxtub:~$ curl 10.1.1.10:9200/_cat/indices?bytes=b | sort -rnk8</div><div class="line">green open slog-2016-09-11   5 1 9729152      0 11128793222 5564396611 </div><div class="line">green open slog-2016-09-12   5 1 8355880      0  9539380440 4769690220 </div><div class="line">green open slog-2016-09-25   5 1 6720954      0  7415719218 3707859609 </div><div class="line">green open slog-2016-09-19   5 1 5840177      0  6575155002 3287577501 </div><div class="line">green open slog-2016-09-10   5 1 5858916      0  6504251544 3252125772</div></pre></td></tr></table></figure>
<p>其他比较常用的命令如下所示，具体的可以参阅文档，这里不再赘述：</p>
<ul>
<li><code>_cat/count</code> 文档总数</li>
<li><code>_cat/count/[index_name]</code> 某个索引的文档总数</li>
<li><code>_cat/fielddata?v</code> 显示每个节点的字段的堆内存使用量</li>
<li><code>_cat/health?v</code> 节点的健康状况<ul>
<li>可以使用下面的命令来自动检查集群状况</li>
<li><code>while true; do curl localhost:9200/_cat/health; sleep 120; done</code></li>
</ul>
</li>
<li><code>_cat/indices?v</code> 查看每个索引的详细信息，配合管道命令可以有很多应用，比如<ul>
<li>找出所有状态为 yellow 的索引 <code>curl localhost:9200/_cat/indices | grep ^yell</code></li>
<li>排序 <code>curl &#39;localhost:9200/_cat/indices?bytes=b&#39; | sort -rnk8</code></li>
<li>指定列及内存使用状况 <code>curl &#39;localhost:9200/_cat/indices?v&amp;h=i,tm&#39;</code></li>
</ul>
</li>
<li><code>_cat/nodes</code> 展示集群的拓扑结构</li>
<li><code>_cat/pending_tasks?v</code> 显示正在排队的任务</li>
<li><code>_cat/recovery?v</code> 显示分片恢复的过程</li>
<li><code>_cat/thread_pool?v</code> 显示线程池相关信息，有很多信息，可以根据需要进行查询</li>
<li><code>_cat/shards?v</code> 显示分片的相关信息</li>
<li><code>_cat/shards/[index-name]</code> 显示指定索引的分片信息  </li>
</ul>
<p><code>_cluster</code> 的接口的用法和 <code>_cat</code> 类似，这里就不再赘述了。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="合理计划服务器"><a href="#合理计划服务器" class="headerlink" title="合理计划服务器"></a>合理计划服务器</h3><p>在 Elasticsearch 的配置文件中，可以根据两个配置(<code>node.master</code> 和 <code>node.data</code>)选项来分配不同节点的角色，以达到提高服务器性能的目的。</p>
<ul>
<li><code>node.master: false; node.data: true</code> - 该节点只作为数据节点，用于存储和查询，资源消耗会较低</li>
<li><code>node.master: true; node.data: false</code> - 该节点只作为 master 节点，不存储数据，主要负责协调索引请求和查询请求</li>
<li><code>node.master: false; node.data: falst</code> - 该节点不作为 master 节点，也不存储数据，主要用于查询时的负载均衡（做结果汇总等工作）</li>
</ul>
<p>另外，一台服务器最好只部署一个节点以维持服务器稳定，毕竟资源是有限的，多开也没啥</p>
<h3 id="数据节点就是数据节点"><a href="#数据节点就是数据节点" class="headerlink" title="数据节点就是数据节点"></a>数据节点就是数据节点</h3><p>如果有配置数据节点，那么可以关闭其 http 功能，让它专注于索引的操作。插件之类的也最好安装到非数据节点服务器上，这样是一个兼顾数据安全和服务器性能的考虑。具体的配置项是 <code>http.enabled: false</code></p>
<h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p>针对 Elasticsearch 的不同操作，可以配置不同大小的线程池，这个需要根据业务需求确定最佳值，场景的操作有：index, search, suggest, get, bulk, percolate, snapshot, snapshot_data, warmer, refresh。</p>
<p>这里以 index(创建/更新/删除索引数据)和 search(搜索操作)为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">threadpool:</div><div class="line">     index:</div><div class="line">         type: fixed</div><div class="line">         size: 24（逻辑核心数*3）</div><div class="line">         queue_ size: 1000</div><div class="line"> </div><div class="line">     search:</div><div class="line">         type: fixed</div><div class="line">         size: 24（逻辑核心数*3）</div><div class="line">         queue_ size: 1000</div></pre></td></tr></table></figure>
<h3 id="分片与副本"><a href="#分片与副本" class="headerlink" title="分片与副本"></a>分片与副本</h3><p>默认的参数是 5 个分片(shard)和 1 个副本(replica)，碎片数目越多，索引速度越快；副本数目越多，搜索能力及可用性更高。分片的数目是在一开始就设定好的，但是副本的数目是可以后期修改的。</p>
<p>而在恢复数据的时候，可以先减少分片刷新索引的时间间隔，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">curl -XPUT <span class="string">'http://10.1.1.0:9200/_settings'</span> <span class="_">-d</span> <span class="string">'&#123; </span></div><div class="line">    "index" : &#123; </div><div class="line">        "refresh_interval" : "-1" </div><div class="line">    &#125; </div><div class="line">&#125;'</div></pre></td></tr></table></figure>
<p>完成插入之后再恢复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">curl -XPUT <span class="string">'http://10.1.1.0:9200/_settings'</span> <span class="_">-d</span> <span class="string">'&#123; </span></div><div class="line">    "index" : &#123; </div><div class="line">        "refresh_interval" : "1s" </div><div class="line">    &#125; </div><div class="line">&#125;'</div></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询中最重要的思路就是 routing，尽量减少慢查询的次数。而当索引越来越大的时候，每个分片也会增大，查询速度就会变慢。一个可行的解决思路就是分索引，比方说不同类型的数据利用不同的 routing 进行分离。</p>
<p>还有一个从业务出发的思路，就是不索引不需要的字段，这样就可以减小集群所需资源的量。</p>
<h3 id="JVM-设置"><a href="#JVM-设置" class="headerlink" title="JVM 设置"></a>JVM 设置</h3><p>关于 JVM 的设置我还在摸索中，不过有几个技巧：</p>
<ul>
<li>JVM 的堆大小不要超过 32G，来源 <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.html#compressed_oops" target="_blank" rel="external">Don’t Cross 32 GB!</a></li>
<li>使用 <code>bootstrap.mlockall: true</code>，启动时就锁定内存</li>
<li>用较小的 heapsize 配合 SSD</li>
</ul>
<h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><h3 id="Full-GC-问题"><a href="#Full-GC-问题" class="headerlink" title="Full GC 问题"></a>Full GC 问题</h3><p>这里以一个实例来介绍我是如何在生产环境中排查和修复 Elasticsearch 集群忽然响应时间剧增的问题的。</p>
<p>情况是这样的，随着接入 Elasticsearch 的数据量增大，忽然有一个周末出问题了 - ES 集群的查询和插入都变得巨慢无比。监控报警都把邮箱和手机发爆炸了。</p>
<p>那么问题来了，究竟是哪里出了乱子？</p>
<p>因为发送数据的客户端和服务器近期并没有特别大的改动，我检查了 Kafka 队列也一切正常，于是可以锁定问题出在 Elasticsearch 身上。</p>
<p>第一反应就是先去看 Elasticsearch 的日志，发现根据日志显示，一致在不停的垃圾回收。因此对症下药，把 JVM 的堆内存改大。但是在集群重启之后仍然会出现性能急剧下降的状况，于是继续检查日志，发现是因为 JVM 进行 Full GC 的时间过长，导致 ES 集群认为拓扑结构改变，开始迁移数据所导致。而迁移数据本身又会导致 Full GC，让情况更糟的是，在 Full GC 结束之后，集群的拓扑结构又再次改变，于是就陷入了这样的死循环。</p>
<p>破局的方法其实非常简单粗暴，把检测集群拓扑的时间间隔和超时次数加大一点，留足够的时间给 JVM 进行 Full GC 即可。</p>
<h3 id="导入数据过慢问题"><a href="#导入数据过慢问题" class="headerlink" title="导入数据过慢问题"></a>导入数据过慢问题</h3><p>最近在从 MySQL 数据库中导入大量数据到 Elasticsearch 的时候，出现写入极其缓慢，甚至在使用了 bulk（批量）接口之后也没有改善的问题。奇怪的是，从 MySQL 的表 A 和表 B 中导入甚至会有几十倍的速度差距，这是为什么呢？</p>
<p>经过一步一步排查，基本上 ES 的文档和可以配置的参数都调整过之后并没有改善，于是开始从数据源入手，最后发现表 A 和 表 B 的数据顺序是不太一样的。表 A 中基本是顺序递增的数据，主键（自增长 ID）基本对应于时间顺序；而表 B 中则基本是随机插入的，所以按照数据库中的 ID 进行顺序导出，就会发现相邻记录对应的日期可能相差很大，而正好我们在 ES 中又是根据日期来进行索引的切割的，导致每次都需要在不同的索引中进行切换，速度自然上不去。</p>
<p>所以我们把从 MySQL 数据库中选择数据的语句利用 timestamp 作为 order by 的标准，导入速度就很快了。</p>
<p>这里有一点需要注意每次除了 ID 之外，还需要记录 timestamp 的值，这样才能保证是顺序导入的 <code>where id &gt; xxx and timestamp &gt; xxx</code>，其中 timestamp 每次需要归 0。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经历了一次事故排查之后，我对 Elasticsearch 集群的相关认识也达到了比较深的程度，虽然在黑暗中探索的那两天很痛苦，不过总算是走出来了，于是赶紧把经验分享出来，这样大家可以少走弯路。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://my.oschina.net/shyloveliyi/blog/653751" target="_blank" rel="external">elasticsearch2.3.1 集群安装</a></li>
<li><a href="http://zhousheng29.iteye.com/blog/2101905" target="_blank" rel="external">ElasticSearch优化的一些方法</a></li>
<li><a href="http://chuansong.me/n/1610745" target="_blank" rel="external">亿级规模的Elasticsearch优化实战</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/restart-upgrade.html" target="_blank" rel="external">Full cluster restart upgrade</a></li>
<li><a href="https://www.loggly.com/blog/nine-tips-configuring-elasticsearch-for-high-performance/" target="_blank" rel="external">9 Tips on ElasticSearch Configuration for High Performance</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Elasticsearch 集群的设置虽然比较简单，但是具体使用其实有很多需要注意的地方。本文结合工作中的实战经验，分享一下 Elasticsearch 集群的相关技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="技巧" scheme="http://wdxtub.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Elasticsearch" scheme="http://wdxtub.com/tags/Elasticsearch/"/>
    
      <category term="集群" scheme="http://wdxtub.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
</feed>
