<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[小土刀]]></title>
  <subtitle><![CDATA[Agony is my triumph]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wdxtub.com/"/>
  <updated>2016-08-17T13:07:38.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name><![CDATA[wdxtub]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Rsyslog 连接 Kafka 指南]]></title>
    <link href="http://wdxtub.com/2016/08/17/rsyslog-kafka-guide/"/>
    <id>http://wdxtub.com/2016/08/17/rsyslog-kafka-guide/</id>
    <published>2016-08-17T13:04:14.000Z</published>
    <updated>2016-08-17T13:07:38.000Z</updated>
    <content type="html"><![CDATA[<p>从去耦合和安全性考虑，最近在负责把公司内各个业务的日志统一接入到 Kafka 再进行下一步的处理，除了常见的 ELK 方案，我还尝试了系统自带的 rsyslog，以下是具体的配置过程。</p>
<a id="more"></a>
<hr>
<p>Kafka 集群的配置可以在<a href="http://wdxtub.com/2016/08/15/kafka-guide/">这里</a>查阅，这里不再赘述，认为大家已经有一个可以正常运行的 Kafka 集群，并且创建了一个名为 test 的 topic</p>
<h2 id="Nginx__u914D_u7F6E"><a href="#Nginx__u914D_u7F6E" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><p>因为 Kafka 集群的通讯是走内网 ip，而外网访问的端口因为安全考虑只开了少数几个（这里是 8080），所以我们用 Nginx 反向代理来连通内外网</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">upstream mq_pool&#123;</span><br><span class="line">server ip1:<span class="number">13647</span> weight=<span class="number">1</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">server localhost:<span class="number">13647</span> weight=<span class="number">1</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listen <span class="number">8080</span>;</span><br><span class="line">allow all;</span><br><span class="line">proxy_pass mq_pool;</span><br><span class="line">proxy_connect_timeout <span class="number">24</span>h;</span><br><span class="line">proxy_timeout <span class="number">24</span>h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置的意思大概是把所有 8080 端口的消息转发到 <code>mq_pool</code> 的两台机器上（负载均衡），其他的就是常规配置。</p>
<h2 id="Kafka_server__u914D_u7F6E"><a href="#Kafka_server__u914D_u7F6E" class="headerlink" title="Kafka server 配置"></a>Kafka server 配置</h2><p>用 Nginx 反向代理之后，可以认为完全是内网环境，所以 Kafka 设置中的<code>advertised.listeners</code> 是唯一能设定外网访问的地方，所以要设置为<strong>外网可以访问的地址（也就是 Nginx 中配置的地址和端口）</strong></p>
<p>然后需要注意的是修改 config 文件夹中的 producer 和 consumer 的配置，把集群的信息统一配置好</p>
<p>如果在测试 producer/consumer 的时候出现 <code>WARN Error while fetching metadata with correlation id</code> 错误，一般重新开启 producer/ consumer 即可（可能需要多试几次）</p>
<h2 id="Python__u6D4B_u8BD5"><a href="#Python__u6D4B_u8BD5" class="headerlink" title="Python 测试"></a>Python 测试</h2><p>为了检测外网访问，我们可以用 python 进行测试，先安装一个 <a href="https://github.com/dpkp/kafka-python" target="_blank" rel="external">Kafka 客户端</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install kafka-python</span><br></pre></td></tr></table></figure>
<p>然后在 python 中执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line">producer = KafkaProducer(bootstrap_servers=<span class="string">'url:port'</span>)</span><br><span class="line">producer.send(<span class="string">'test'</span>, <span class="string">'hello from python'</span>)</span><br></pre></td></tr></table></figure>
<p>如果一切正常，应该可以在 Kafka 的 consumer 中见到这条消息。</p>
<h2 id="Rsyslog__u914D_u7F6E"><a href="#Rsyslog__u914D_u7F6E" class="headerlink" title="Rsyslog 配置"></a>Rsyslog 配置</h2><p>一般来说默认的 rsyslog 版本较低，如果想要连接 kafka，我们需要先升级到最新版本。这里可以用 <code>rsyslogd -N1</code> 来查看目前机器上的版本。</p>
<p>执行下面的命令升级</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:adiscon/v8-stable </span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rsyslog</span><br><span class="line"><span class="comment"># 安装 kafka 插件</span></span><br><span class="line">sudo apt-get install rsyslog-kafka rsyslog-imptcp</span><br></pre></td></tr></table></figure>
<p>如果一切正常，我们就可以来配置 rsyslog 了，打开 <code>/etc/rsyslog.d/</code> 文件夹，创建一个配置文件 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">module(<span class="operator"><span class="keyword">load</span>=<span class="string">"omkafka"</span>)</span><br><span class="line"><span class="keyword">module</span>(<span class="keyword">load</span>=<span class="string">"imfile"</span>)</span><br><span class="line"></span><br><span class="line">ruleset(<span class="keyword">name</span>=<span class="string">"kafka"</span>) &#123;</span><br><span class="line">  <span class="keyword">action</span> (</span><br><span class="line">    <span class="keyword">type</span>=<span class="string">"omkafka"</span></span><br><span class="line">    topic=<span class="string">"test"</span></span><br><span class="line">    broker=<span class="string">"broker.ip:port"</span></span><br><span class="line">    <span class="keyword">template</span>=<span class="string">"json"</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>(<span class="keyword">type</span>=<span class="string">"imfile"</span> Tag=<span class="string">"wdxtub"</span> <span class="keyword">File</span>=<span class="string">"/data/log/logstash_production.log"</span> Ruleset=<span class="string">"kafka"</span>)</span></span><br></pre></td></tr></table></figure>
<p>然后我们重启服务 <code>sudo service rsyslog restart</code> 应该就可以在 kafka 自带的 consumer 中看到日志了。</p>
<p><code>bin/kafka-console-consumer.sh --zookeeper bi03:2181,bi02:2181 --from-beginning --topic test</code></p>
<p>至此，配置完成。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.jianshu.com/p/1b7fdb1cff3c" target="_blank" rel="external">日志收集之rsyslog to kafka</a></li>
<li><a href="http://www.rsyslog.com/tag/omkafka/" target="_blank" rel="external">Tag Archives: omkafka</a></li>
<li><a href="http://www.rsyslog.com/doc/master/configuration/modules/omkafka.html" target="_blank" rel="external">omkafka: write to Apache Kafka</a></li>
<li><a href="http://youfu.xyz/2016/04/27/rsyslog-json-kafka/" target="_blank" rel="external">rsyslog存储json日志到kafka</a></li>
<li><a href="https://dzone.com/articles/recipe-rsyslog-kafka-logstash-1" target="_blank" rel="external">Recipe: rsyslog + Kafka + Logstash</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>从去耦合和安全性考虑，最近在负责把公司内各个业务的日志统一接入到 Kafka 再进行下一步的处理，除了常见的 ELK 方案，我还尝试了系统自带的 rsyslog，以下是具体的配置过程。</p>]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://wdxtub.com/tags/Kafka/"/>
    
      <category term="rsyslog" scheme="http://wdxtub.com/tags/rsyslog/"/>
    
      <category term="日志" scheme="http://wdxtub.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Coding.net 静态博客托管指南]]></title>
    <link href="http://wdxtub.com/2016/08/17/add-coding-platform/"/>
    <id>http://wdxtub.com/2016/08/17/add-coding-platform/</id>
    <published>2016-08-17T11:47:31.000Z</published>
    <updated>2016-08-17T14:43:07.000Z</updated>
    <content type="html"><![CDATA[<p>因为众所周知的原因，Github 在国内的访问体验并不好。为了节省国内用户的时间，我决定把博客同时托管于 Github 和 Coding 两个平台。本文是具体的操作指南。</p>
<a id="more"></a>
<hr>
<h2 id="Coding__u5E73_u53F0_u64CD_u4F5C"><a href="#Coding__u5E73_u53F0_u64CD_u4F5C" class="headerlink" title="Coding 平台操作"></a>Coding 平台操作</h2><p>首先去<a href="https://coding.net" target="_blank" rel="external">官网</a>注册，然后在账户设置中添加 <code>SSH 公钥</code>，具体的步骤为（Mac 下，且已部署到 github）：</p>
<ul>
<li>输入命令 <code>cat ~/.ssh/id_rsa.pub</code></li>
<li>然后把输出的以 <code>ssh-rsa</code> 开头的字符串粘贴到网页中</li>
<li>接着测试一下 <code>ssh -T git@git.coding.net</code></li>
<li>成功的话应该出现 <code>Hello wdxtub! You&#39;ve connected to Coding.net via SSH successfully!</code></li>
</ul>
<h2 id="Hexo__u914D_u7F6E_u6587_u4EF6_u4FEE_u6539"><a href="#Hexo__u914D_u7F6E_u6587_u4EF6_u4FEE_u6539" class="headerlink" title="Hexo 配置文件修改"></a>Hexo 配置文件修改</h2><p>然后我们需要修改 hexo 的配置文件，主要是部署的部分，增加一行</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Deployment&#10;## Docs: http://hexo.io/docs/deployment.html&#10;deploy:&#10;  type: git&#10;  repository:&#10;    github: git@github.com:wdxtub/wdxtub.github.io.git&#10;    # &#22686;&#21152;&#36825;&#19968;&#34892;&#10;    coding: git@git.coding.net:wdxtub/wdxtub.git&#10;  branch: master</span><br></pre></td></tr></table></figure>
<p>然后 <code>hexo g -d</code> 部署即可，如果出现问题，可以删除 <code>.deploy_git</code> 文件夹后再尝试一次</p>
<h2 id="u914D_u7F6E_u57DF_u540D_u89E3_u6790"><a href="#u914D_u7F6E_u57DF_u540D_u89E3_u6790" class="headerlink" title="配置域名解析"></a>配置域名解析</h2><p>我的域名是在万网买的，所以直接在阿里云后台进行修改，这里海外走 github，默认走 coding（也就是国内）</p>
<p><img src="/images/14714441200850.jpg" alt=""></p>
<p>稍等一会儿，我们来测试一下，先是连接 VPN 的时候</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Documents/Blog [22:37:43]</span></span><br><span class="line">$ traceroute wdxtub.com</span><br><span class="line">traceroute to prod.github.map.fastlylb.net (<span class="number">151.101</span>.<span class="number">100.133</span>), <span class="number">64</span> hops max, <span class="number">52</span> byte packets</span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Documents/Blog [22:41:52]</span></span><br><span class="line">$ ping wdxtub.com</span><br><span class="line">--- prod.github.map.fastlylb.net ping statistics ---</span><br><span class="line"><span class="number">13</span> packets transmitted, <span class="number">13</span> packets received, <span class="number">0.0</span>% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = <span class="number">48.754</span>/<span class="number">53.315</span>/<span class="number">66.105</span>/<span class="number">4.174</span> ms</span><br></pre></td></tr></table></figure>
<p>然后是断开 VPN 的时候 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Documents/Blog [22:39:35]</span></span><br><span class="line">$ traceroute wdxtub.com</span><br><span class="line">traceroute: Warning: wdxtub.com has multiple addresses; using <span class="number">103.218</span>.<span class="number">243.203</span></span><br><span class="line">traceroute to pages.coding.net (<span class="number">103.218</span>.<span class="number">243.203</span>), <span class="number">64</span> hops max, <span class="number">52</span> byte packets</span><br><span class="line"><span class="comment"># dawang at wdxtub.local in ~/Documents/Blog [22:39:59]</span></span><br><span class="line">$ ping wdxtub.com</span><br><span class="line">--- pages.coding.net ping statistics ---</span><br><span class="line"><span class="number">14</span> packets transmitted, <span class="number">14</span> packets received, <span class="number">0.0</span>% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = <span class="number">17.390</span>/<span class="number">23.946</span>/<span class="number">37.623</span>/<span class="number">5.742</span> ms</span><br></pre></td></tr></table></figure>
<p>可以看到国内的访问应该有了大幅度的速度提升。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.jeyzhang.com/blog-on-gitcafe-with-dns-settings.html" target="_blank" rel="external">如何将博客托管至Coding及相应的DNS设置</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为众所周知的原因，Github 在国内的访问体验并不好。为了节省国内用户的时间，我决定把博客同时托管于 Github 和 Coding 两个平台。本文是具体的操作指南。</p>]]>
    
    </summary>
    
      <category term="博客" scheme="http://wdxtub.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="托管" scheme="http://wdxtub.com/tags/%E6%89%98%E7%AE%A1/"/>
    
      <category term="访问" scheme="http://wdxtub.com/tags/%E8%AE%BF%E9%97%AE/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我们需要怎样的计算机科学教育]]></title>
    <link href="http://wdxtub.com/2016/08/16/how-to-teach-cs/"/>
    <id>http://wdxtub.com/2016/08/16/how-to-teach-cs/</id>
    <published>2016-08-16T12:55:18.000Z</published>
    <updated>2016-08-16T14:44:34.000Z</updated>
    <content type="html"><![CDATA[<p>一直在想，轮到我自己来写教材，书的主题是什么。有的从软件硬件接口入手，有的从体系架构入手，还有的从性能设计入手。这些切入角度都不错，不过我今天找到了更好的——从『计算思维』入手。</p>
<a id="more"></a>
<hr>
<p>这两个月把各类计算机系统的课本和计算机科学经典书籍大致都翻了一遍，悟出了一个很重要的道理：一本好的教材，一本好书，一定是有灵魂的，不然纵使有了骨架和血肉，也像行尸走肉一样，拼拼凑凑，毫无生机。</p>
<p>另外一个让我很有感触的是工作之后的变化，从中能清晰认识到高校教育和工程实践中存在的巨大鸿沟。工程中会用到大量成熟半成熟的工具和应用，但是在高校中往往没有足够时间来进行磨练（毕竟是以学期为单位），不过这倒不是重点，高等教育的初衷并不是职业技能培训，而是帮助同学构建广泛而有时效性的知识体系，培养独立解决问题的能力。</p>
<p>而我们的学科设计和教材往往两头够不着，在各种条件的制约下成了『四不像』。而具体到计算机科学上，我的感觉是没有真正让同学们喜欢上这门本来非常有趣的学科，症结在哪里？今天无意间找到了答案——计算思维。其实倒也不复杂：从我们的教材开始，就没有着力去培养『计算思维』，或者说没有把一门实践学科以实践的方式来进行教学。</p>
<p><img src="/images/14713585528520.jpg" alt=""><br>（感谢曲鳖带我去湾区的计算机博物馆，真正看到了历史的痕迹，给我非常大的触动）</p>
<p>那么，计算思维到底说的是什么，不同人有不同的理解，我们来看看 Jeannette M. Wing 最初于 2006 年提出时的<a href="https://www.cs.cmu.edu/~15110-s13/Wing06-ct.pdf" target="_blank" rel="external">定义</a>（是我 CMU 的教授，也跟着沾沾光）</p>
<blockquote>
<p>计算思维是运用计算机科学的基础概念进行问题求解、系统设计以及人类行为理解等涵盖计算机科学之广度的一系列思维活动</p>
</blockquote>
<p>具体的表现呢？</p>
<ul>
<li>本质是抽象和自动化</li>
<li>递归思维</li>
<li>通过约简、嵌入、转化和仿真等方法，把一个困难的问题转化为我们已经有办法解决的问题</li>
<li>通过合适的表示及建模方法来使问题得以解决</li>
<li>把数据转换成代码，把代码转换为数据</li>
<li>通过抽象和分解来解决复杂问题</li>
<li>通过简洁和优雅来判断系统设计的优劣</li>
<li>通过冗余、容灾和错误处理来从最坏情况中恢复</li>
<li>…..</li>
</ul>
<p>仔细回忆一下，其实我们所学的很多东西，都是围绕着『计算思维』的，或者说，是为了培养『计算思维』而准备的。而一旦拥有了『计算思维』，就意味着能够以计算机科学的角度去思考，才能更好地去利用计算机的力量来解决问题。</p>
<p>然后我们就会发现，教育工作者和企业最希望学生拥有的能力，都包含在其中了，比如：</p>
<ul>
<li>持续学习能力 -&gt; 利用抽象和自动化等特性</li>
<li>独立解决问题的能力 -&gt; 通过抽象和分解来解决复杂问题</li>
<li>逻辑分析能力 -&gt; 通过约简、嵌入、转化和仿真等方法，把一个困难的问题转化为我们已经有办法解决的问题</li>
<li>开源精神 -&gt; 通过简洁和优雅来判断系统设计的优劣</li>
<li>理论与实际结合 -&gt; 把数据转换成代码，把代码转换为数据</li>
</ul>
<p>所以核心是：<strong>想办法在课程设计上和习题上击中这些要点</strong>。比如说，开一门课一定是因为学生的能力培养需要什么，而不是为了教书而教书。也应该摒弃『计算机基础教学就是教学生怎么将计算机作为工具使用』这种错误思想，而是着眼于培养『计算思维』能力。</p>
<p>据此，给自己开出的药方是：</p>
<ul>
<li>用经典案例结合计算学科基本问题讲述计算机科学的来龙去脉，并结合相关学科展望学科融合与跨界发展</li>
<li>通过动手实验了解计算机本质与解决问题的基本步骤（习题要好好设计）</li>
<li>每一章节都要围绕『计算思维』来写，帮助读者建立完整的思维框架，尤其是在抽象和自动化这两个层面上</li>
<li>针对重要的设计思想一定要用翔实的例子帮助读者理解清楚，更重要的是点出设计背后的思考，也就是『为什么要这么设计』</li>
<li>多一点私心：加入更多中国与汉字相关的内容，让读者了解我们在数字浪潮中的位置（比如说处理器相关的内容在介绍 x86-64 的基础上加入龙芯的内容）</li>
</ul>
<p>憋了这么久，就是在等这『悟道』的一天，有趣的是，兜兜转转居然是在 CMU 的网站上找到了最重要的灵感，正如当初选择上 15213 这门神课，仿佛一切都被安排好了。</p>
<p>有了魂，剩下的血肉就好组织了。</p>
<p>在这个特殊的日子，让我说一句：苟利国家生死以，岂因祸福避趋之。(提前 +1S)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直在想，轮到我自己来写教材，书的主题是什么。有的从软件硬件接口入手，有的从体系架构入手，还有的从性能设计入手。这些切入角度都不错，不过我今天找到了更好的——从『计算思维』入手。</p>]]>
    
    </summary>
    
      <category term="思维" scheme="http://wdxtub.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="教育" scheme="http://wdxtub.com/tags/%E6%95%99%E8%82%B2/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Go 之旅】II 我的笨办法学 Go]]></title>
    <link href="http://wdxtub.com/2016/08/15/learn-go-the-hard-way/"/>
    <id>http://wdxtub.com/2016/08/15/learn-go-the-hard-way/</id>
    <published>2016-08-15T11:43:14.000Z</published>
    <updated>2016-08-15T11:43:51.000Z</updated>
    <content type="html"><![CDATA[<p>在学习新语言这个事情上，笨办法往往是最高效的办法。效仿『笨办法学 Python』和『笨办法学 Ruby』，我来写一篇『笨办法学 Go』吧！</p>
<a id="more"></a>
<hr>
<h2 id="u5F00_u59CB_u4E4B_u524D"><a href="#u5F00_u59CB_u4E4B_u524D" class="headerlink" title="开始之前"></a>开始之前</h2><p>在上一篇日志中我们大概对 Go 有了基本的认识，不过还不够系统，也远达不到掌握。所以就通过简单的例子和大量的编码练习来快速入门吧！</p>
<p>学新语言的关键点有三个：实践、能力培养和习惯养成。这些可能要比语言的语法本身更加重要！本日志基于 Go 1.6.3，仿照『笨办法学语言』系列的模式，用闯关的方式来学习。</p>
<p>具体的安装和基础知识可以参考 <a href="http://wdxtub.com/2016/08/11/golang-first-step/">Go 快速入门</a></p>
<p>本文的配套代码可以在<a href="https://github.com/wdxtub/learn-go-the-hard-way" target="_blank" rel="external">这里</a>查阅。</p>
<h2 id="u4E60_u9898_1__u7B2C_u4E00_u4E2A_u7A0B_u5E8F"><a href="#u4E60_u9898_1__u7B2C_u4E00_u4E2A_u7A0B_u5E8F" class="headerlink" title="习题 1 第一个程序"></a>习题 1 第一个程序</h2><p>新建一个名为 <code>ex1.go</code> 的文件，内容为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="comment">// 一个变量声明</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"dawang"</span></span><br><span class="line">    <span class="comment">// 也是一个变量声明</span></span><br><span class="line">    gender := <span class="string">"male"</span></span><br><span class="line">    fmt.Println(<span class="string">"What a great day! Let's Go!"</span>)</span><br><span class="line">    fmt.Println(name + <span class="string">"'s gender is "</span> + gender) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行 <code>go run ex1.go</code>，可以看到结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run ex1.go</span><br><span class="line">What a great day! Let<span class="string">'s Go!</span><br><span class="line">dawang'</span>s gender is male</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong></p>
<ul>
<li>注释</li>
<li>变量声明</li>
<li>输出语句</li>
<li>程序基本结构</li>
<li>包 Package</li>
</ul>
<h2 id="u4E60_u9898_2__u6570_u5B57_u548C_u6570_u5B66_u8FD0_u7B97"><a href="#u4E60_u9898_2__u6570_u5B57_u548C_u6570_u5B66_u8FD0_u7B97" class="headerlink" title="习题 2 数字和数学运算"></a>习题 2 数字和数学运算</h2><h2 id="u4E60_u9898_3__u5B57_u7B26_u4E32_u4E0E_u683C_u5F0F_u5316_u8F93_u51FA"><a href="#u4E60_u9898_3__u5B57_u7B26_u4E32_u4E0E_u683C_u5F0F_u5316_u8F93_u51FA" class="headerlink" title="习题 3 字符串与格式化输出"></a>习题 3 字符串与格式化输出</h2><h2 id="u4E60_u9898_4__u8F93_u5165"><a href="#u4E60_u9898_4__u8F93_u5165" class="headerlink" title="习题 4 输入"></a>习题 4 输入</h2><h2 id="u4E60_u9898_5__u5305_Package"><a href="#u4E60_u9898_5__u5305_Package" class="headerlink" title="习题 5 包 Package"></a>习题 5 包 Package</h2><h2 id="u4E60_u9898_6__u547D_u4EE4_u884C_u53C2_u6570"><a href="#u4E60_u9898_6__u547D_u4EE4_u884C_u53C2_u6570" class="headerlink" title="习题 6 命令行参数"></a>习题 6 命令行参数</h2><h2 id="u4E60_u9898_7__u8BFB_u5199_u6587_u4EF6"><a href="#u4E60_u9898_7__u8BFB_u5199_u6587_u4EF6" class="headerlink" title="习题 7 读写文件"></a>习题 7 读写文件</h2><h2 id="u4E60_u9898_8__u590D_u5236_u6587_u4EF6_u5185_u5BB9"><a href="#u4E60_u9898_8__u590D_u5236_u6587_u4EF6_u5185_u5BB9" class="headerlink" title="习题 8 复制文件内容"></a>习题 8 复制文件内容</h2><h2 id="u4E60_u9898_9__u51FD_u6570"><a href="#u4E60_u9898_9__u51FD_u6570" class="headerlink" title="习题 9 函数"></a>习题 9 函数</h2><h2 id="u4E60_u9898_10"><a href="#u4E60_u9898_10" class="headerlink" title="习题 10"></a>习题 10</h2><h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/wdxtub/learn-go-the-hard-way" target="_blank" rel="external">配套代码</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在学习新语言这个事情上，笨办法往往是最高效的办法。效仿『笨办法学 Python』和『笨办法学 Ruby』，我来写一篇『笨办法学 Go』吧！</p>]]>
    
    </summary>
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="笨鸟" scheme="http://wdxtub.com/tags/%E7%AC%A8%E9%B8%9F/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka 指南]]></title>
    <link href="http://wdxtub.com/2016/08/15/kafka-guide/"/>
    <id>http://wdxtub.com/2016/08/15/kafka-guide/</id>
    <published>2016-08-15T11:38:04.000Z</published>
    <updated>2016-08-17T13:03:52.000Z</updated>
    <content type="html"><![CDATA[<p>提到消息系统，目前最火热的非 Kafka 莫属，公司也打算利用 Kafka 进行各业务日志统一收集，这里结合自己的实践来分享一下具体的配置及使用。Kafka 版本 0.10.0.1</p>
<a id="more"></a>
<hr>
<h2 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h2><p>作为云计算大数据的套件，Kafka 是一个分布式的、可分区的、可复制的消息系统。该有的功能基本都有，而且有自己的特色：</p>
<ul>
<li>以 topic 为单位进行消息归纳</li>
<li>向 topic 发布消息的是 producer</li>
<li>从 topic 获取消息的是 consumer</li>
<li>集群方式运行，每个服务叫 broker</li>
<li>客户端和服务器通过 TCP 进行通信</li>
</ul>
<p>在Kafka集群中，没有“中心主节点”的概念，集群中所有的服务器都是对等的，因此，可以在不做任何配置的更改的情况下实现服务器的的添加与删除，同样的消息的生产者和消费者也能够做到随意重启和机器的上下线。</p>
<p>对每个 topic 来说，Kafka 会对其进行分区，每个分区都由一系列有序的、不可变的消息组成，这些消息被连续的追加到分区中。分区中的每个消息都有一个连续的序列号叫做 offset,用来在分区中唯一的标识这个消息。</p>
<p>发布消息通常有两种模式：队列模式(queuing)和发布-订阅模式(publish-subscribe)。队列模式中，consumers 可以同时从服务端读取消息，每个消息只被其中一个 consumer 读到；发布-订阅模式中消息被广播到所有的 consumer 中。更常见的是，每个 topic 都有若干数量的 consumer 组，每个组都是一个逻辑上的『订阅者』，为了容错和更好的稳定性，每个组由若干 consumer 组成。这其实就是一个发布-订阅模式，只不过订阅者是个组而不是单个 consumer。</p>
<p>通过分区的概念，Kafka可以在多个consumer组并发的情况下提供较好的有序性和负载均衡。将每个分区分只分发给一个consumer组，这样一个分区就只被这个组的一个consumer消费，就可以顺序的消费这个分区的消息。因为有多个分区，依然可以在多个consumer组之间进行负载均衡。注意consumer组的数量不能多于分区的数量，也就是有多少分区就允许多少并发消费。</p>
<p>Kafka 只能保证一个分区之内消息的有序性，在不同的分区之间是不可以的，这已经可以满足大部分应用的需求。如果需要 topic 中所有消息的有序性，那就只能让这个 topic 只有一个分区，当然也就只有一个 consumer 组消费它。</p>
<h2 id="u5355_u673A_u914D_u7F6E"><a href="#u5355_u673A_u914D_u7F6E" class="headerlink" title="单机配置"></a>单机配置</h2><p>按照下列步骤即可（来自官网教程）</p>
<p><strong>1. 下载 Kafka</strong></p>
<ul>
<li>下载 <code>wget http://apache.01link.hk/kafka/0.10.0.0/kafka_2.11-0.10.0.0.tgz</code> 或者 <code>wget http://ftp.cuhk.edu.hk/pub/packages/apache.org/kafka/0.10.0.0/kafka_2.11-0.10.0.0.tgz</code>（看哪个源比较快）</li>
<li>解压 <code>tar -xzf kafka_2.11-0.10.0.0.tgz</code> </li>
<li>进入文件夹 <code>cd kafka_2.11-0.10.0.0/</code></li>
</ul>
<p><strong>2. 启动服务</strong></p>
<ul>
<li>启动 ZooKeeper <code>bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code>（利用 <code>&amp;</code>放到后台方便继续操作）</li>
<li>启动 Kafka <code>bin/kafka-server-start.sh config/server.properties &amp;</code></li>
</ul>
<p><strong>3. 创建一个叫做 dawang 的 topic，它只有一个分区，一个副本</strong></p>
<ul>
<li>创建 <code>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic dawang</code></li>
<li>查看 <code>bin/kafka-topics.sh --list --zookeeper localhost:2181</code></li>
<li>还可以配置 broker 让它自动创建 topic</li>
</ul>
<p><strong>4. 发送消息。Kafka 使用一个简单的命令行producer，从文件中或者从标准输入中读取消息并发送到服务端。默认的每条命令将发送一条消息。</strong></p>
<ul>
<li>发送消息 <code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic dawang</code>（然后可以随意输入内容，回车可以发送，ctrl+c 退出）</li>
</ul>
<p><strong>5. 启动 consumer。可以读取消息并输出到标准输出：</strong></p>
<ul>
<li>接收消息 <code>bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic dawang --from-beginning</code></li>
<li>在一个终端中运行 consumer 命令行，另一个终端中运行 producer 命令行，就可以在一个终端输入消息，另一个终端读取消息。这两个命令都有自己的可选参数，可以在运行的时候不加任何参数可以看到帮助信息。</li>
</ul>
<p><strong>6. 搭建一个多个 broker 的集群，启动有 3 个 broker 组成的集群，这些 broker 节点也都在本机</strong></p>
<p>首先复制一下配置文件：<code>cp config/server.properties config/server-1.properties</code> 和 <code>cp config/server.properties config/server-2.properties</code></p>
<p>两个文件需要改动的内容为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">config/server-<span class="number">1.</span>properties:</span><br><span class="line">    broker.id=<span class="number">1</span></span><br><span class="line">    listeners=PLAINTEXT:<span class="comment">//:9093</span></span><br><span class="line">    <span class="built_in">log</span>.dir=/tmp/kafka-logs-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">config/server-<span class="number">2.</span>properties:</span><br><span class="line">    broker.id=<span class="number">2</span></span><br><span class="line">    listeners=PLAINTEXT:<span class="comment">//:9094</span></span><br><span class="line">    <span class="built_in">log</span>.dir=/tmp/kafka-logs-<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里我们把 broker id, 端口号和日志地址配置成和之前不一样，然后我们启动这两个 broker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server-<span class="number">1</span>.properties &amp;</span><br><span class="line">bin/kafka-server-start.sh config/server-<span class="number">2</span>.properties &amp;</span><br></pre></td></tr></table></figure>
<p>然后创建一个复制因子为 3 的 topic</p>
<p><code>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic oh3topic</code></p>
<p>可以使用 <code>describe</code> 命令来显示 topic 详情</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper localhost:<span class="number">2181</span> --topic oh3topic</span><br><span class="line">Topic:oh3topic	PartitionCount:<span class="number">1</span>	ReplicationFactor:<span class="number">3</span>	Configs:</span><br><span class="line">	Topic: oh3topic	Partition: <span class="number">0</span>	Leader: <span class="number">0</span>	Replicas: <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>	Isr: <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里简单解释一下</p>
<ul>
<li>Leader 是给定分区的节点编号，每个分区的部分数据会随机指定不同的节点</li>
<li>Replicas 是该日志会保存的复制</li>
<li>Isr 表示正在同步的复制</li>
</ul>
<p>我们也可以来看看之前的另一个 topic 的情况</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper <span class="string">localhost:</span><span class="number">2181</span> --topic dawang</span><br><span class="line"><span class="string">Topic:</span>dawang	<span class="string">PartitionCount:</span><span class="number">1</span>	<span class="string">ReplicationFactor:</span><span class="number">1</span>	<span class="string">Configs:</span></span><br><span class="line"><span class="label">	Topic:</span> dawang	<span class="string">Partition:</span> <span class="number">0</span>	<span class="string">Leader:</span> <span class="number">0</span>	<span class="string">Replicas:</span> <span class="number">0</span>	<span class="string">Isr:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>最后我们可以按照同样的方法来生产和消费消息，例如</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">生产</span></span><br><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">console</span><span class="literal">-</span><span class="comment">producer</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">broker</span><span class="literal">-</span><span class="comment">list</span> <span class="comment">localhost:9092</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">oh3topic</span></span><br><span class="line"><span class="comment">#</span> <span class="comment">消费</span></span><br><span class="line"><span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">console</span><span class="literal">-</span><span class="comment">consumer</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">from</span><span class="literal">-</span><span class="comment">beginning</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">oh3topic</span></span><br></pre></td></tr></table></figure>
<p>开俩终端就可以一边生产消息，一边消费消息了。</p>
<h2 id="u96C6_u7FA4_u914D_u7F6E"><a href="#u96C6_u7FA4_u914D_u7F6E" class="headerlink" title="集群配置"></a>集群配置</h2><p>kafka 使用 ZooKeeper 用于管理、协调代理。每个 Kafka 代理通过 Zookeeper 协调其他 Kafka 代理。当 Kafka 系统中新增了代理或某个代理失效时，Zookeeper 服务将通知生产者和消费者。生产者与消费者据此开始与其他代理协调工作。</p>
<h3 id="u5B89_u88C5_Java"><a href="#u5B89_u88C5_Java" class="headerlink" title="安装 Java"></a>安装 Java</h3><p>先给两台机子安装 Java</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install oracle-java8-installer</span><br></pre></td></tr></table></figure>
<h3 id="u66F4_u65B0_Hosts"><a href="#u66F4_u65B0_Hosts" class="headerlink" title="更新 Hosts"></a>更新 Hosts</h3><p>这里用两台机器做例子（理论上最好是 3 台起步，偶数个不是不可以的，但是zookeeper集群是以宕机个数过半才会让整个集群宕机的，所以奇数个集群更佳），分别配置 <code>/etc/hosts</code> 文件为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost</span><br><span class="line"><span class="number">10.1</span><span class="number">.1</span><span class="number">.164</span> bi03</span><br><span class="line"><span class="number">10.1</span><span class="number">.1</span><span class="number">.44</span> bi02</span><br></pre></td></tr></table></figure>
<h3 id="u4FEE_u6539_Zookeeper__u914D_u7F6E_u6587_u4EF6"><a href="#u4FEE_u6539_Zookeeper__u914D_u7F6E_u6587_u4EF6" class="headerlink" title="修改 Zookeeper 配置文件"></a>修改 Zookeeper 配置文件</h3><p>修改 <code>config/zookeeper.properties</code> 为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dataDir=/data/home/logger/kafka_2<span class="number">.11</span>-<span class="number">0.10</span><span class="number">.0</span><span class="number">.0</span>/zookeeper-logs/</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"><span class="preprocessor"># maxClientCnxns=<span class="number">0</span></span></span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">5</span></span><br><span class="line">syncLimit=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">server<span class="number">.1</span>=bi03:<span class="number">13645</span>:<span class="number">13646</span></span><br><span class="line">server<span class="number">.2</span>=bi02:<span class="number">13645</span>:<span class="number">13646</span></span><br></pre></td></tr></table></figure>
<p>参数的意义为：</p>
<ul>
<li>initLimit: zookeeper集群中的包含多台 server，其中一台为 leader，集群中其余的 server 为 follower。initLimit 参数配置初始化连接时，follower 和 leader 之间的最长心跳时间。此时该参数设置为 5，说明时间限制为 5 倍 tickTime，即 <code>5*2000=10000ms=10s</code></li>
<li>syncLimit: 该参数配置 leader 和 follower 之间发送消息，请求和应答的最大时间长度。此时该参数设置为 2，说明时间限制为 2 倍 tickTime，即 4000ms</li>
<li>server.X=A:B:C 其中 X 是一个数字, 表示这是第几号 server。A 是该 server 所在的 IP 地址。B 配置该 server 和集群中的 leader 交换消息所使用的端口。C 配置选举 leader 时所使用的端口。</li>
</ul>
<h3 id="u7ED9_u670D_u52A1_u5668_u7F16_u53F7"><a href="#u7ED9_u670D_u52A1_u5668_u7F16_u53F7" class="headerlink" title="给服务器编号"></a>给服务器编号</h3><p>在 dataDir 目录下建立一个 myid 文件，分别为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># server<span class="number">.1</span></span></span><br><span class="line">echo <span class="number">1</span> &gt; myid</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># server<span class="number">.2</span></span></span><br><span class="line">echo <span class="number">2</span> &gt; myid</span><br></pre></td></tr></table></figure>
<h3 id="u542F_u52A8_Zookeeper"><a href="#u542F_u52A8_Zookeeper" class="headerlink" title="启动 Zookeeper"></a>启动 Zookeeper</h3><p>然后在每台机子上启动 zookeeper 服务 </p>
<p><code>bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></p>
<p>所有机子的 zookeeper 都启动之前会报错，这都是正常的</p>
<p>如果不想要任何输出</p>
<p><code>nohup bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></p>
<h3 id="u4FEE_u6539_Kafka__u914D_u7F6E_u6587_u4EF6"><a href="#u4FEE_u6539_Kafka__u914D_u7F6E_u6587_u4EF6" class="headerlink" title="修改 Kafka 配置文件"></a>修改 Kafka 配置文件</h3><p>修改 <code>config/server.properties</code>，几个要改的部分是 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># 允许删除 topic</span></span><br><span class="line"><span class="keyword">delete</span>.topic.enable=<span class="literal">true</span></span><br><span class="line">broker.id=<span class="number">0</span> <span class="preprocessor"># 这里不能重复</span></span><br><span class="line">listeners=PLAINTEXT:<span class="comment">//bi03:13647 # 这里要配置成本机的 host name</span></span><br><span class="line"><span class="preprocessor"># 这里需要配置成外网能够访问的地址及端口</span></span><br><span class="line">advertised.listeners=PLAINTEXT:<span class="comment">//external.ip:8080</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.dirs=/data/home/logger/kafka_2<span class="number">.11</span>-<span class="number">0.10</span><span class="number">.0</span><span class="number">.0</span>/kafka-logs</span><br><span class="line">num.partitions=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">zookeeper.connect=bi03:<span class="number">2181</span>,bi02:<span class="number">2181</span></span><br></pre></td></tr></table></figure>
<h3 id="u542F_u52A8_Kafka"><a href="#u542F_u52A8_Kafka" class="headerlink" title="启动 Kafka"></a>启动 Kafka</h3><p>在每个节点上执行</p>
<p><code>bin/kafka-server-start.sh config/server.properties &amp;</code></p>
<p>如果不想要任何输出</p>
<p><code>nohup bin/kafka-server-start.sh config/server.properties &amp;</code></p>
<h3 id="u9A8C_u8BC1_u5B89_u88C5"><a href="#u9A8C_u8BC1_u5B89_u88C5" class="headerlink" title="验证安装"></a>验证安装</h3><p>创建一个 topic</p>
<p><code>bin/kafka-topics.sh --create --zookeeper bi03:2181,bi02:2181 --replication-factor 2 --partitions 1 --topic test</code></p>
<p>查看集群状态</p>
<p><code>bin/kafka-topics.sh --describe --zookeeper bi03:2181,bi02:2181 --topic test</code></p>
<p>生产消息，这里注意要生产到前面设置的监听端口，而不是 zookeeper 的端口</p>
<p><code>bin/kafka-console-producer.sh --broker-list bi03:13647,bi02:13647 --topic test</code></p>
<p>消费消息，这里注意是 zookeeper 的端口，而不是 kafka 的端口</p>
<p><code>bin/kafka-console-consumer.sh --zookeeper bi03:2181,bi02:2181 --from-beginning --topic test</code></p>
<p>显示 topic 列表</p>
<p><code>bin/kafka-topics.sh --zookeeper bi03:2181,bi02:2181 --list</code></p>
<p>删除 topic</p>
<p><code>bin/kafka-topics.sh --zookeeper bi03:2181,bi02:2181 --delete --topic hello</code></p>
<h3 id="u5176_u4ED6_u914D_u7F6E"><a href="#u5176_u4ED6_u914D_u7F6E" class="headerlink" title="其他配置"></a>其他配置</h3><p>Kafka 使用键值对的属性文件格式来进行配置，比如 <code>config/server.properties</code>，具体的值可以从文件中读取，或者在代码中进行指定。最重要的三个属性是：</p>
<ul>
<li><code>broker.id</code>: broker 的编号，不能相同</li>
<li><code>log.dirs</code>: 日志保存的文件夹，默认为 <code>/tmp/kafka-logs</code></li>
<li><code>zookeeper.connect</code>: zookeeper 的 host</li>
</ul>
<p>其他一些我觉得比较有用的属性为</p>
<ul>
<li><code>auto.create.topics.enable</code> 是否允许自动创建 topic，boolean 值，默认为 <code>true</code></li>
<li><code>auto.leader.rebalance.enable</code> 是否允许 leader 进行自动平衡，boolean 值，默认为 <code>true</code></li>
<li><code>background.threads</code> 后台进程数目，int 值，默认为 10 个</li>
<li><code>compression.type</code> 指定 topic 的压缩方式，string 值，可选有<ul>
<li><code>gzip</code>, <code>snappy</code>, <code>lz4</code> 压缩方法</li>
<li><code>uncompressed</code> 不压缩</li>
<li><code>producer</code> 跟随 producer 的压缩方式</li>
</ul>
</li>
<li><code>delete.topic.enable</code> 是否允许删除 topic，boolean 值，默认为 false（主要用于控制 admin 界面中的控制）</li>
<li><code>leader.imbalance.check.interval.seconds</code> 检查是否平衡的时间间隔，long 值，默认为 300</li>
<li><code>leader.imbalance.per.broker.percentage</code> 允许的不平衡的百分比，超出则会进行重平衡，int 值，默认为 10</li>
<li><code>log.flush.interval.messages</code> 攒了多少条消息之后会把数据刷入磁盘，long 值，默认是 9223372036854775807</li>
<li><code>log.flush.interval.ms</code> 每条消息在保存到磁盘中前会在内存中待多久，单位毫秒，long 值，如果不设定，默认使用 <code>log.flush.scheduler.interval.ms</code>，也就是 9223372036854775807</li>
</ul>
<p>更多的配置可以参考<a href="http://kafka.apache.org/documentation.html#brokerconfigs" target="_blank" rel="external">这里</a>，以上的配置均针对 broker，因为目前我只用 broker 的部分</p>
<h2 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h2><p>所有的工具都可以在 <code>bin/</code> 文件夹下查看，如果不带任何参数，就会给出所有命令的列表说明，这里只简要说明一些常用的命令</p>
<h3 id="u521B_u5EFA_u548C_u79FB_u9664_topic"><a href="#u521B_u5EFA_u548C_u79FB_u9664_topic" class="headerlink" title="创建和移除 topic"></a>创建和移除 topic</h3><p>可以手动创建 topic，或在数据进来时自动创建不存在的 topic，如果是自动创建的话，可能需要根据<a href="http://kafka.apache.org/documentation.html#topic-config" target="_blank" rel="external">这里</a>来进行对应调整。</p>
<p><strong>创建 topic</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --create --topic my_topic_name --partitions 20 --replication-factor 3 --config x=y</code></p>
<p>replication-factor 控制复制的份数，建议 2-3 份来兼顾容错和效率。partitions 控制该 topic 将被分区的数目，partitions 的数目最好不要超过服务器的个数（因为分区的意义是增加并行效率，而服务器数量决定了并行的数量，假设只有 2 台服务器，分 4 个区和 2 个区其实差别不大）。另外，topic 的名称不能超过 249 个字符</p>
<p><strong>修改 topic</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --alter --topic my_topic_name --partitions 40</code></p>
<p>这里需要注意，即使修改了分区的个数，已有的数据也不会进行变动，Kafka 不会做任何自动重分布</p>
<p><strong>增加配置</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --alter --topic my_topic_name --config x=y</code></p>
<p><strong>移除配置</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --alter --topic my_topic_name --delete-config x</code></p>
<p><strong>删除 topic</strong></p>
<p><code>bin/kafka-topics.sh --zookeeper zk_host:port/chroot --delete --topic my_topic_name</code></p>
<p>这个需要 <code>delete.topic.enable=true</code>，目前 Kafka 不支持减少 topic 的分区数目</p>
<h3 id="u4F18_u96C5_u5173_u95ED"><a href="#u4F18_u96C5_u5173_u95ED" class="headerlink" title="优雅关闭"></a>优雅关闭</h3><p>Kafka 会自动检测 broker 的状态并根据机器状态选举出新的 leader。但是如果需要进行配置更改停机的时候，我们就需要使用优雅关闭了，好处在于：</p>
<ol>
<li>会把所有的日志同步到磁盘上，避免重启之后的日志恢复，减少重启时间</li>
<li>会在关闭前把以这台机为 leader 的分区数据迁移到其他节点，会减少不可用的时间</li>
</ol>
<p>但是这个需要开启 <code>controlled.shutdown.enable=true</code>。</p>
<p>刚重启之后的节点不是任何分区的 leader，所以这时候需要进行重新分配：</p>
<p><code>bin/kafka-preferred-replica-election.sh --zookeeper zk_host:port/chroot</code></p>
<p>这里需要开启 <code>auto.leader.rebalance.enable=true</code></p>
<p>然后可以使用脚本 <code>bin/kafka-server-stop.sh</code></p>
<p>注意，如果配置文件中没有 <code>auto.leader.rebalance.enable=true</code>，就还需要重新平衡</p>
<h2 id="u6DF1_u5165_u7406_u89E3"><a href="#u6DF1_u5165_u7406_u89E3" class="headerlink" title="深入理解"></a>深入理解</h2><p>这里只是一部分摘录，更多内容可查阅参考链接（尤其是美团技术博客的那篇）</p>
<h3 id="u6587_u4EF6_u7CFB_u7EDF"><a href="#u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="文件系统"></a>文件系统</h3><p>Kafka 大量依赖文件系统去存储和缓存消息。而文件系统最终会放在硬盘上，不过不用担心，很多时候硬盘的快慢完全取决于使用它的方式。设计良好的硬盘架构可以和内存一样快。</p>
<p>所以与传统的将数据缓存在内存中然后刷到硬盘的设计不同，Kafka直接将数据写到了文件系统的日志中，因此也避开了 JVM 的劣势——Java 对象占用空间巨大，数据量增大后垃圾回收有困难。使用文件系统，即使系统重启了，也不需要刷新数据，也简化了维护数据一致性的逻辑。</p>
<p>对于主要用于日志处理的消息系统，数据的持久化可以简单的通过将数据追加到文件中实现，读的时候从文件中读就好了。这样做的好处是读和写都是 O(1) 的，并且读操作不会阻塞写操作和其他操作。这样带来的性能优势是很明显的，因为性能和数据的大小没有关系了。</p>
<p>既然可以使用几乎没有容量限制（相对于内存来说）的硬盘空间建立消息系统，就可以在没有性能损失的情况下提供一些一般消息系统不具备的特性。比如，一般的消息系统都是在消息被消费后立即删除，Kafka却可以将消息保存一段时间（比如一星期），这给consumer提供了很好的机动性和灵活性。</p>
<h3 id="u4E8B_u52A1_u5B9A_u4E49"><a href="#u4E8B_u52A1_u5B9A_u4E49" class="headerlink" title="事务定义"></a>事务定义</h3><p>数据传输的事务定义通常有以下三种级别：</p>
<ul>
<li>最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输。</li>
<li>最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.</li>
<li>精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的。</li>
</ul>
<p>Kafka 的机制和 git 有点类似，有一个 commit 的概念，一旦提交且 broker 在工作，那么数据就不会丢失。如果 producer 发布消息时发生了网络错误，但又不确定实在提交之前发生的还是提交之后发生的，这种情况虽然不常见，但是必须考虑进去，现在Kafka版本还没有解决这个问题，将来的版本正在努力尝试解决。</p>
<p>并不是所有的情况都需要“精确的一次”这样高的级别，Kafka 允许 producer 灵活的指定级别。比如 producer 可以指定必须等待消息被提交的通知，或者完全的异步发送消息而不等待任何通知，或者仅仅等待 leader 声明它拿到了消息（followers没有必要）。</p>
<p>现在从 consumer 的方面考虑这个问题，所有的副本都有相同的日志文件和相同的offset，consumer 维护自己消费的消息的 offset。如果 consumer 崩溃了，会有另外一个 consumer 接着消费消息，它需要从一个合适的 offset 继续处理。这种情况下可以有以下选择：</p>
<ul>
<li>consumer 可以先读取消息，然后将 offset 写入日志文件中，然后再处理消息。这存在一种可能就是在存储 offset 后还没处理消息就 crash 了，新的 consumer 继续从这个 offset 处理，那么就会有些消息永远不会被处理，这就是上面说的『最多一次』</li>
<li>consumer 可以先读取消息，处理消息，最后记录o ffset，当然如果在记录 offset 之前就 crash 了，新的 consumer 会重复的消费一些消息，这就是上面说的『最少一次』</li>
<li>『精确一次』可以通过将提交分为两个阶段来解决：保存了 offset 后提交一次，消息处理成功之后再提交一次。但是还有个更简单的做法：将消息的 offset 和消息被处理后的结果保存在一起。比如用 Hadoop ETL 处理消息时，将处理后的结果和 offset 同时保存在 HDFS 中，这样就能保证消息和 offser 同时被处理了</li>
</ul>
<h3 id="u6027_u80FD_u4F18_u5316"><a href="#u6027_u80FD_u4F18_u5316" class="headerlink" title="性能优化"></a>性能优化</h3><p>Kafka 在提高效率方面做了很大努力。Kafka 的一个主要使用场景是处理网站活动日志，吞吐量是非常大的，每个页面都会产生好多次写操作。读方面，假设每个消息只被消费一次，读的量的也是很大的，Kafka 也尽量使读的操作更轻量化。</p>
<p>线性读写的情况下影响磁盘性能问题大约有两个方面：太多的琐碎的 I/O 操作和太多的字节拷贝。I/O 问题发生在客户端和服务端之间，也发生在服务端内部的持久化的操作中。</p>
<p><strong>消息集(message set)</strong></p>
<p>为了避免这些问题，Kafka 建立了<strong>消息集(message set)</strong>的概念，将消息组织到一起，作为处理的单位。以消息集为单位处理消息，比以单个的消息为单位处理，会提升不少性能。Producer 把消息集一块发送给服务端，而不是一条条的发送；服务端把消息集一次性的追加到日志文件中，这样减少了琐碎的 I/O 操作。consumer 也可以一次性的请求一个消息集。</p>
<p>另外一个性能优化是在字节拷贝方面。在低负载的情况下这不是问题，但是在高负载的情况下它的影响还是很大的。为了避免这个问题，Kafka 使用了标准的二进制消息格式，这个格式可以在 producer, broker 和 producer 之间共享而无需做任何改动。</p>
<p><strong>zero copy</strong></p>
<p>Broker 维护的消息日志仅仅是一些目录文件，消息集以固定队的格式写入到日志文件中，这个格式 producer 和 consumer 是共享的，这使得 Kafka 可以一个很重要的点进行优化：消息在网络上的传递。现代的 unix 操作系统提供了高性能的将数据从页面缓存发送到 socket 的系统函数，在 linux 中，这个函数是 <code>sendfile</code></p>
<p>为了更好的理解 <code>sendfile</code> 的好处，我们先来看下一般将数据从文件发送到 socket 的数据流向：</p>
<ul>
<li>操作系统把数据从文件拷贝内核中的页缓存中</li>
<li>应用程序从页缓存从把数据拷贝自己的内存缓存中</li>
<li>应用程序将数据写入到内核中 socket 缓存中</li>
<li>操作系统把数据从 socket 缓存中拷贝到网卡接口缓存，从这里发送到网络上。</li>
</ul>
<p>这显然是低效率的，有 4 次拷贝和 2 次系统调用。<code>sendfile</code> 通过直接将数据从页面缓存发送网卡接口缓存，避免了重复拷贝，大大的优化了性能。</p>
<p>在一个多consumers的场景里，数据仅仅被拷贝到页面缓存一次而不是每次消费消息的时候都重复的进行拷贝。这使得消息以近乎网络带宽的速率发送出去。这样在磁盘层面你几乎看不到任何的读操作，因为数据都是从页面缓存中直接发送到网络上去了。</p>
<p><strong>数据压缩</strong></p>
<p>很多时候，性能的瓶颈并非CPU或者硬盘而是网络带宽，对于需要在数据中心之间传送大量数据的应用更是如此。当然用户可以在没有 Kafka 支持的情况下各自压缩自己的消息，但是这将导致较低的压缩率，因为相比于将消息单独压缩，将大量文件压缩在一起才能起到最好的压缩效果。</p>
<p>Kafka 采用了端到端的压缩：因为有『消息集』的概念，客户端的消息可以一起被压缩后送到服务端，并以压缩后的格式写入日志文件，以压缩的格式发送到 consumer，消息从 producer 发出到 consumer 拿到都被是压缩的，只有在 consumer 使用的时候才被解压缩，所以叫做『端到端的压缩』。Kafka支持GZIP和Snappy压缩协议。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://kafka.apache.org/" target="_blank" rel="external">Apache Kafka</a></li>
<li><a href="http://kafka.apache.org/documentation.html#quickstart" target="_blank" rel="external">Quick Start</a></li>
<li><a href="http://www.aboutyun.com/thread-12882-1-1.html" target="_blank" rel="external">Kafka入门经典教程</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-kafka/" target="_blank" rel="external">Apache kafka 工作原理介绍</a></li>
<li><a href="http://www.coderli.com/setup-kafka-cluster-step-by-step/" target="_blank" rel="external">事无巨细 Apache Kafka 0.9.0.1 集群环境搭建</a></li>
<li><a href="http://blog.csdn.net/dhtx_wzgl/article/details/46892231" target="_blank" rel="external">kafka集群搭建</a></li>
<li><a href="http://tech.meituan.com/kafka-fs-design-theory.html" target="_blank" rel="external">Kafka文件存储机制那些事</a></li>
<li><a href="http://kaimingwan.com/post/kafka/kafkayuan-li-yi-ji-she-ji-shi-xian-si-xiang" target="_blank" rel="external">kafka原理以及设计实现思想</a></li>
<li><a href="http://www.dexcoder.com/dexcoder/article/2194" target="_blank" rel="external">kafka设计原理介绍</a></li>
<li><a href="http://blog.jobbole.com/99195/" target="_blank" rel="external">Kafka集群操作指南</a></li>
<li><a href="https://www.quora.com/What-is-the-actual-role-of-ZooKeeper-in-Kafka" target="_blank" rel="external">What is the actual role of ZooKeeper in Kafka?</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>提到消息系统，目前最火热的非 Kafka 莫属，公司也打算利用 Kafka 进行各业务日志统一收集，这里结合自己的实践来分享一下具体的配置及使用。Kafka 版本 0.10.0.1</p>]]>
    
    </summary>
    
      <category term="分布式" scheme="http://wdxtub.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="日志" scheme="http://wdxtub.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="消息队列" scheme="http://wdxtub.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[好问题收集]]></title>
    <link href="http://wdxtub.com/2016/08/14/good-question/"/>
    <id>http://wdxtub.com/2016/08/14/good-question/</id>
    <published>2016-08-13T23:54:53.000Z</published>
    <updated>2016-08-14T00:24:21.000Z</updated>
    <content type="html"><![CDATA[<p>好的问题往往能引发人的思考，而思考的过程其实比答案更加重要。这里收集了各类我在网上看到的有趣问题。在这里跟大家分享一下，有空会更新。</p>
<a id="more"></a>
<hr>
<h2 id="Insightful_Questions__u667A_u6027_u95EE_u9898"><a href="#Insightful_Questions__u667A_u6027_u95EE_u9898" class="headerlink" title="Insightful Questions 智性问题"></a>Insightful Questions 智性问题</h2><p>来自即刻的对应栏目，截至 16/08/15</p>
<ul>
<li>Is it more common for a country to have more parties on the left or the right? 在一个国家中是不是通常左倾或者右倾党派会有一个占多数？</li>
<li>Would you give up your right to privacy to live in a Utopia? 为了生活在一个理想的乌托邦里，你会放弃隐私吗？</li>
<li>Do we need a visual image in order to be in love? 我们可以在不见到对方形象的情况下坠入爱河吗</li>
<li>Entropy is constantly increasing in the universe. Does this directly affect human lifestyle gradually? Is our world meant to be more chaotic with age? 雨中中熵总是增加的，这会直接性地渐渐改变人类的生活方式吗，我们的人类社会随着时间发展会变得更混乱无序吗？</li>
<li>Can an non sapient animal distinguish dreams from reality? 对没有智力的动物而言，它们能分清梦境与现实吗？</li>
<li>When does a human become a separative living being with their own rights? 一个人从何时起可以界定为具有自身权利的独立个体？</li>
<li>How would people react if the Simulation theory was proven correct? 如果我们真的发现自己生活在虚拟世界中，人类群体会作何反应？</li>
<li>Should people have the right to choose exactly where to funnel their tax dollars, and stop the spending of the tax dollars should they disagree with the service government is spending it on? 人民有权选择缴纳具体的税收项目吗？当人民不同意政府某些财政支出的时候，可以停止交税吗？</li>
<li>Does ironic racism still count as racism? 玩笑式的种族歧视话语仍然被当作真正的种族歧视吗？</li>
<li>Is reality just our perception of reality? 所谓『现实』是否仅仅是现实在我们的知觉中的反映？</li>
<li>How many generations could a dictatorship last if the first dictator was benevolent and intelligent? 如果第一代独裁者仁慈且智慧，他的独裁政权能持续多少代？</li>
<li>How do you rescue a group of people which may contain a murderer? 如果想救的一群人中混有杀人凶手，该怎么办？</li>
<li>Should people have the right to discriminate? 人们有歧视的权力吗？</li>
<li>Are ethics universal and unchanging, or culturally relative and man made? 伦理学是普世不变的还是随文化与人为而改变？</li>
<li>Is prejudice, when based upon one’s own life experiences, such a bad thing? 基于生活经验而来的偏见是不是一定不对呢？</li>
<li>Is pirating books online that you could also “rent” digitally from a library hurting anyone? 如果可以在图书馆接到免费电子版，那在网上下载同一本书的盗版会对任何人造成损害吗？</li>
<li>Would an artificial intelligence strive for survival? 人工智慧会有求生欲望</li>
<li>How would our society, emotions and law be affected if we learned death was an unquestionable good for people? 如果得知死亡毫无疑问是件好事，我们的社会在情感与法律上会受到什么影响</li>
<li>Why do humans need to control each other, and want to feel in control of situations? 人类为什么喜欢控制他人，有想要一切尽在掌控中的欲望？</li>
<li>Will medical advances kill morality after there are no consequences for taboo behavior? 如果医学上的进步使本来的一些禁忌行为不再造成后果，会消除它们在道德上的限制吗？</li>
<li>What gives an item or thing value? 是什么赋予了一件事情或东西以价值？</li>
<li>Should ALL victimless crimes be legalized? 没有受害者的犯罪是不是都该合法化？</li>
<li>Should humanity strive for immortality? 人类应该追求永生吗？</li>
<li>Can we accurately judge our own attractiveness? 我们可以准确评估自己的吸引力么？</li>
<li>Could a person who understands a complex idea (be it scientific, philosophical, etc.) have come up with the idea themselves? 在某人有能力理解一个复杂概念（哲学或科学上）的情况下，他是否一定可以在还没有这个概念的时候自己将它发现出来呢？</li>
<li>Why do we feel awe? 人为什么会有敬畏之情？</li>
<li>Do the benefits or freedom outweigh the problems freedom enables? 自由带来的正面与负面效应孰轻孰重？</li>
<li>What rights do we have? 我们有什么权利？</li>
<li>In the far future - how will territorial boundaries be handled after significant movement of earth’s plates? 在遥远的未来，因为大陆版快漂移造成的剧变会怎样影响既有的国家领土划分</li>
<li>If you could sacrifice your most joyous memory in order to take away your worse. Would you? 如果牺牲你最快乐的那段记忆来消除最痛苦的那段，你愿意吗？</li>
<li>How can one recognize one’s true personality? 一个人怎样发现自己真正的本性？</li>
<li>Are people rather egoistic or altruistic? 人性是利己的还是利他的</li>
<li>What heartfelt principles did you once hold, but have since changed? And what changed them? 哪些原则是你曾坚持，而后改变乐的，是什么改变了它</li>
<li>Could fresh water be the cause for the next major war? 对清洁饮用水的争夺是否会成为下次大战的起因？</li>
<li>What are the true intentions of charity? 做慈善的真正目的是什么</li>
<li>Should we be always painfully honest? 我们应该绝对诚实吗？</li>
<li>How different would our world be if the average lifespan was only 25? 如果人的平均寿命只有 25 岁，这个世界会有什么不同？</li>
<li>If you could take a pill that would remove the need for sleep, but it means you will never dream again, would you take it? 如果有一颗药能让人不需要睡眠，也不再做梦，你会不会吃？</li>
<li>What are we so confident in our beliefs about things that we can’t possibly know? 为什么我们会对 不可知的事抱有坚定的信念？</li>
<li>How has modern life incapacitated our ability to grow and adapt to stress? 现代生活如何让我们失去了成长和适应压力的能力？</li>
<li>Is democracy really the best form of government? 民主真的是最好的政府形式吗？</li>
<li>What is the best way to combat religious extremism occurring throughout the world? 宗教极端分子在全世界制造灾难，打击他们最好的办法是什么</li>
<li>When is war justifiable? 什么情况下，战争可能被认为是合理的选择？</li>
<li>What has been some of the most valuable lessons you’ve learned in life? 你在生活中学到最有价值的东西是什么？</li>
</ul>
<h2 id="u52A0_u6DF1_u5F7C_u6B64_u8BA4_u8BC6_u7684_36__u4E2A_u95EE_u9898"><a href="#u52A0_u6DF1_u5F7C_u6B64_u8BA4_u8BC6_u7684_36__u4E2A_u95EE_u9898" class="headerlink" title="加深彼此认识的 36 个问题"></a>加深彼此认识的 36 个问题</h2><p>在生活大爆炸里 Sheldon 和 Penny 做过的一套题目</p>
<ol>
<li>如果可以跟世上任何人共进晚餐, 你会选择谁?</li>
<li>你会想出名吗? 以什么样方式出名呢?</li>
<li>在打一通电话之前, 你会先排演要在电话中说什么吗? 为什么?</li>
<li>你心中最完美的一天是做哪些事呢?</li>
<li>你上一次唱歌给自己听是什么时候? 上一次唱给别人听又是何时?</li>
<li>如果你可以活到90岁, 并能在30岁过后让体态或大脑一直保持30岁的状态到死, 你会选保持体态还是大脑呢?</li>
<li>你有曾经预感过自己会怎么死亡吗?</li>
<li>举出3个你与你对面这位的共同点.</li>
<li>你人生中你最感激什么?</li>
<li>如果你能改变你是怎么被抚育成人的, 你会想改变什么?</li>
<li>用四分钟跟你对面这位分享你的一生, 越详细越好.</li>
<li>如果你明早一觉醒来发现自己获得了某种能力, 你希望是什么能力?</li>
<li>如果一颗魔法水晶球能告诉你有关你自己, 你的人生, 你的未来, 或任何事情, 你会想知道什么?</li>
<li>你有已经梦想了很久, 想做的事情吗? 你为什么还没去做?</li>
<li>你人生中最大的成就是什么?</li>
<li>一段友情中你最珍视的是什么?</li>
<li>你最珍贵的一段回忆是什么?</li>
<li>你最糟糕的一段回忆是什么?</li>
<li>如果你知道你会在一年后突然死去, 你会想改变任何你现在的生活方式吗? 为什么?</li>
<li>友情对你来说代表什么?</li>
<li>爱与喜欢在你的人生中有着什么样的地位?</li>
<li>轮流分享你觉得你的恋人应该具有的五项好品质?</li>
<li>你的家庭亲密温暖吗? 你觉得你的童年有比别人幸福点吗?</li>
<li>你觉得你跟你的母亲的关系怎么样呢?</li>
<li>用”我们”做主语造三个肯定句, 比如”我们都在这个房间里”.</li>
<li>完成以下句子”我希望我有一个人能与ta分享…”</li>
<li>如果你会跟你对面的人变成亲密好友, 分享一下你觉得对方必需得知道的事情.</li>
<li>告诉你对面的人你喜欢ta什么: 老实回答, 说一些你通常不会告诉刚认识的人的答案.</li>
<li>与你对面的人分享人生中很尴尬的一刻.</li>
<li>你上一次在别人面前哭是什么时候? 上一次自己哭是什么时候?</li>
<li>告诉你对面的人你已经喜欢上ta的什么?</li>
<li>有什么人事物是太严重, 不能随便开玩笑的?</li>
<li>如果你将在今晚死去, 没有任何再与他人交流的机会, 你最后悔没有把什么事情跟别人说?</li>
<li>你的家着火了, 里面有你所拥有的一切事物. 在救出你爱的人, 你的宠物后, 你还有时间最后再冲回去一趟拯救最后一样任何东西, 你会救出什么? 为什么?</li>
<li>你家庭中的所有人里, 谁的死会让你最难受? 为什么?</li>
<li>分享一个你私人的问题, 并想你对面的人询问ta会怎么处理. 之后再请ta回答, 对于你选这个问题, ta有什么看法?</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>好的问题往往能引发人的思考，而思考的过程其实比答案更加重要。这里收集了各类我在网上看到的有趣问题。在这里跟大家分享一下，有空会更新。</p>]]>
    
    </summary>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="问题" scheme="http://wdxtub.com/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第九周 - 天空]]></title>
    <link href="http://wdxtub.com/2016/08/13/sky/"/>
    <id>http://wdxtub.com/2016/08/13/sky/</id>
    <published>2016-08-13T13:27:13.000Z</published>
    <updated>2016-08-13T23:40:15.000Z</updated>
    <content type="html"><![CDATA[<p>昨夜星辰昨夜风，那是无边浪漫暖春，花树下起阵阵雨，淅沥淅沥，朝露拥吻山桃花，院子里面热气新茶，风铃摇曳屋簷下，嘀哒嘀哒。</p>
<a id="more"></a>
<hr>
<p>万万没想到，一周居然可以发生这么多的事儿。搭好个人工作室可以是一天，项目调整部门变化可以是一天，业务对接东拉西扯可以是一天，从深圳回广州也可以是一天。有了大桌子和显示器效率提升不止百分之百；拥抱变化大概是程序员的自我修养；对接业务更多需要的是耐心；而回家则是为了放松，毕竟弦不能总绷着嘛。</p>
<p>正是在这样的变动下，往往才更能看清自己的方向和价值，诚然有些东西因为这样那样的原因需要妥协，不过人嘛，还是要有自己的底线，就像谈判一样，不然总有一天要退无可退跌落悬崖的。</p>
<p>最近最火的恐怕是奥运了，本来没啥感觉，真正一块一块奖牌出现之后，不由自主开始牵肠挂肚。和四年前相比，更让我开心的不是金牌的变化，而是运动员和网民的变化，这种变化真的让我觉得，新时代的大幕在缓缓揭开。从『我们』中慢慢看到『我』，个体的觉醒也许方向有所不同，但是总比千人一面要好嘛。</p>
<p>因为项目的需求，我需要跟公司各个产品线进行一定的业务对接，在各种跨部门合作中，逐渐也摸索出来了一套工作流程，简单来说就是『找对接人的领导比找对接人有用』。各种摸爬滚打也让我有些感悟：一直以来我习惯的模式是 hack 而不是 build，而在公司里最需要的是 build，这也是我最需要提高的能力。虽然各种人员变动让人觉得不那么靠谱，不过首先还是要做好自己，剩下的，就是历史的行程了。</p>
<p>几周没回家，在深圳的小房间里切实『闭关』了一把，也把剩下的计算机学科经典看得七七八八。虽然岁月着实让曾经的光芒有些褪色，但相比于其他稍纵即逝的流星，经典还是颇为持久且耀眼的。同事问我为什么看书快，有没有什么技巧。我说其实我看书不快，只是我一直在看，比方说六点起床，到晚上睡觉，除了吃早餐点外卖睡个午觉之外我只做一件事，十多个小时就是看书记笔记。哪有什么所谓的技巧，有技巧的话，就是心无旁骛吧。</p>
<p>老板亲自抓的项目，项目组成员大概是没有什么好日子的：凌晨三四点下班或者干脆通宵；各种需求却要多快好省尽快做完；下班后开会赶工；各种朋友圈发广告刷屏。用纯银的话说就是：</p>
<blockquote>
<p>创业者要求员工加班，应该心怀歉意，毕竟经常性加班说明管理无能……管理无能也就罢了，最恶心的是要求员工在社交网络谈论公事，侵入员工的私域，以此微小的宣传收益，弥补公司的推广无能，公关无能。老板要真有这心思就把自己微博经营好，别去骚扰员工。</p>
</blockquote>
<p>深以为然，这样的成语我可以说一串：竭泽而渔杀鸡取卵饮鸩止渴刻舟求剑。但楚王好细腰，下面的人又能怎么办呢？我赶紧又把明朝那些事儿放到 kindle 里，以史为鉴嘛。</p>
<p>这周跑步了四次，不过也难以扭转体重一直在增长的趋势，所以给自己定下一个目标！减掉 5 公斤！因此，执行如下：</p>
<ol>
<li>过午不食，早上吃好，中午吃沙拉</li>
<li>除了牛奶和豆奶，不吃任何零食区的东西</li>
<li>坚持跑步和每小时的俯卧撑练习</li>
<li>十一点前睡觉</li>
<li>买个秤，每天早上记录体重</li>
</ol>
<p>这八月的天空，大桥下，河堤旁，抚过柳叶的风；不如就，一起散散步。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨夜星辰昨夜风，那是无边浪漫暖春，花树下起阵阵雨，淅沥淅沥，朝露拥吻山桃花，院子里面热气新茶，风铃摇曳屋簷下，嘀哒嘀哒。</p>]]>
    
    </summary>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="生活" scheme="http://wdxtub.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rsyslog + Logstash 日志传输指南]]></title>
    <link href="http://wdxtub.com/2016/08/12/rsyslog-logstash-guide/"/>
    <id>http://wdxtub.com/2016/08/12/rsyslog-logstash-guide/</id>
    <published>2016-08-12T15:03:57.000Z</published>
    <updated>2016-08-15T11:37:30.000Z</updated>
    <content type="html"><![CDATA[<p>最近在把公司各个业务线的数据和日志接入到统一的 ELK 平台中，我主要在做 LK 和对接的工作，涉及服务器和网络拓扑相关内容比较多和杂，网上没有太多相关资料，这里跟大家分享一下我的一点经验。</p>
<a id="more"></a>
<hr>
<h2 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h2><p>因为部分历史遗留问题以及业务线的情况，不同后台业务涉及两个云服务提供商在三地的不同机房。出于安全考虑，不同项目组的服务器需要隔离（目前还没有用容器，所以是虚拟机隔离），但是日志需要统一进行收集、统计和展示。因为人员调动，我其实是临时接手这部分业务，所以只能在平稳接入各个业务之后，再考虑架构的演进。</p>
<p>之前的架构基本是『怎么快怎么方便怎么来』，颇有『刀耕火种』的感觉，不过大部分时间还是运转良好的，在新架构完成之前，只能先用这套不太完善的机制进行传输了。</p>
<p>为了描述方便，这里我们虚构两个服务，各自服务器部署配置如下</p>
<ul>
<li>服务 A：两个机房<ul>
<li>机房 1：杭州阿里云，机器 x 3，编号 A-HZ-ALI-01, A-HZ-ALI-02, A-HZ-ALI-03</li>
<li>机房 2：美国 AWS，机器 x 3，编号 A-US-AWS-01, A-US-AWS-02, A-US-AWS-03</li>
</ul>
</li>
<li>服务 B：两个机房<ul>
<li>机房 1：杭州阿里云，机器 x 3，编号 B-HZ-ALI-01, B-HZ-ALI-02, B-HZ-ALI-03</li>
<li>机房 2：美国阿里云，机器 x 3，编号 B-US-ALI-01, B-US-ALI-02, B-US-ALI-03</li>
</ul>
</li>
</ul>
<p>而 Elasticsearch 集群部署在美国 AWS，后面统称 ES。另外还有部分数据需要从 RDS 中获取，统称为 MySQL 任务。</p>
<h2 id="u7F51_u7EDC"><a href="#u7F51_u7EDC" class="headerlink" title="网络"></a>网络</h2><p>每台服务器都有自己的日志，使用 logrotate 工具按日进行切割，如果服务异常，之前的做法是登录到对应机器上进行日志查看。因为使用 Nginx 做负载均衡的缘故，很可能没办法快速找到对应的日志（现在机器比较少还好，再多就很麻烦了）。所以我们首先需要考虑的是想个办法把各个机器的日志收集到一起。</p>
<p>在具体部署的时候，我们考虑过两种方案，这里简单介绍一下：</p>
<p>第一种，简单粗暴，每台机器均直接把自己的日志发送给 ES。第二种，在每个机房选择一台服务器进行日志汇总，然后再统一发送给 ES。这两种方案各有优劣，我们来简单思考一下：</p>
<p>第一种方案的优劣</p>
<ul>
<li>劣势<ul>
<li>每台机器直接发给 ES 需要大量配置（当然这个可以用自动配置工具完成），一旦需求变动，所有的配置都需要修改</li>
<li>每台机器都需要外网权限，运维难度增加，安全风险增加</li>
<li>没办法利用内网通讯速度快的优势，给线上服务带来较高的带宽压力</li>
</ul>
</li>
<li>优势<ul>
<li>避免了单点的问题，即使一台服务器出问题，其他的日志还能正常发送数据</li>
</ul>
</li>
</ul>
<p>第二种方案的优劣   </p>
<ul>
<li>劣势<ul>
<li>汇总服务器是单点，一旦出问题，所有的日志都没有办法正常发送</li>
</ul>
</li>
<li>优势 <ul>
<li>只需要配置一台机器（其他机器可以通过系统自带的 rsyslog 进行日志传输），即使人工操作也不太麻烦</li>
<li>只有一台服务器强制需要外网权限</li>
<li>内部的日志传输通过内网，速度快</li>
</ul>
</li>
</ul>
<p>综合上述考虑，我们决定采用第二种解决方案，接下来会介绍如何进行配置。</p>
<h2 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h2><p>在开始配置之前一定要确定下面几个事情：</p>
<ul>
<li>服务器上的对应端口是否有配置好权限</li>
<li>服务器的内网 ip 以及内网互访的权限</li>
<li>Logstash 和 Rsyslog 的版本</li>
<li>服务器配置及负载情况</li>
</ul>
<h3 id="u8F6C_u53D1_u673A_u914D_u7F6E"><a href="#u8F6C_u53D1_u673A_u914D_u7F6E" class="headerlink" title="转发机配置"></a>转发机配置</h3><p>有了这些信息，我们就可以从每个机房挑选一台服务器作为日志汇总和转发机，这里我们选择：A-HZ-ALI-01, A-US-AWS-01, B-HZ-ALI-01, B-US-ALI-01 这四台机器分别接入（后面称为汇总机）。</p>
<p>这里我们使用 Logstash 进行日志汇总转发，各台机器上的 Logstash 配置可以是一样的，因为需要在后台启用该服务，所以需要修改/创建 <code>/etc/logstash/conf.d/logstash.conf</code> 文件，然后使用 <code>sudo service logstash restart</code> 重启服务（或者也可以使用 <code>&amp;</code> 创建后台任务，总之把应用开起来就行）</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="name">input</span> &#123;</span><br><span class="line"> tcp &#123;</span><br><span class="line">   port=&gt; <span class="number">16666</span></span><br><span class="line">   codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="name">filter</span> &#123;</span><br><span class="line">  geoip &#123;</span><br><span class="line">    source =&gt; <span class="string">"ip"</span></span><br><span class="line">    fields =&gt; [<span class="string">"location"</span>, <span class="string">"city_name"</span>, <span class="string">"country_name"</span>, <span class="string">"country_code2"</span>,<span class="string">"country_code3"</span>, <span class="string">"region_name"</span>, <span class="string">"continent_code"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="name">output</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [<span class="string">"es.wdxtub.com:80"</span>]</span><br><span class="line">        index =&gt; <span class="string">"ServiceA-log-%&#123;+YYYY-MM-dd&#125;"</span></span><br><span class="line">        user =&gt; <span class="string">"wdxtub"</span></span><br><span class="line">        password =&gt; <span class="string">"www.wdxtub.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置文件的意思是当程序启动时，监听 16666 端口传来的 json 行，根据 ip 地址获取地理信息之后，发送到 <code>es.wdxtub.com:80</code> 这个 ES 集群中，对应的索引是 <code>ServiceA-log-%{+YYYY-MM-dd}</code>，这里实际上做了按日分隔（在 Kibana 中只需使用 <code>ServiceA-log-*</code> 就可以汇总所有的 ServiceA 的日志）</p>
<h3 id="u65E5_u5FD7_u8F6C_u53D1"><a href="#u65E5_u5FD7_u8F6C_u53D1" class="headerlink" title="日志转发"></a>日志转发</h3><p>我们现在已经有了从汇总机到 ES 的通道，现在需要做的就是把各个机器的日志发送到汇总机了，甚至汇总机本机的日志也可以通过这种方式进行（这样就是一个统一的过程了，不因为机器的角色有特殊情况）。这里具体选择的方式是 rsyslog，同一个机房同一个服务的机器的配置文件是一样的，我们在 <code>/etc/rsyslog.d/</code> 中新建一个 <code>10-file.conf</code> 文件，内容为</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># 载入文件读取模块</span></span><br><span class="line"><span class="variable">$ModLoad</span> imfile</span><br><span class="line"><span class="variable">$template</span> myFileMonitorTemplate,<span class="string">"%msg%"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 日志文件</span></span><br><span class="line"><span class="variable">$InputFileName</span> /data/home/service/project/shared/<span class="built_in">log</span>/lograge_production.<span class="built_in">log</span></span><br><span class="line"><span class="preprocessor"># 打标签</span></span><br><span class="line"><span class="variable">$InputFileTag</span> service-<span class="built_in">log</span>:</span><br><span class="line"><span class="preprocessor"># 下面这行是用来保存文件状态的</span></span><br><span class="line"><span class="variable">$InputFileStateFile</span> stat1470781524</span><br><span class="line"><span class="variable">$InputFileSeverity</span> info</span><br><span class="line"><span class="variable">$InputFileFacility</span> local7</span><br><span class="line"><span class="preprocessor"># 拉取时间间隔，单位是秒</span></span><br><span class="line"><span class="variable">$InputFilePollInterval</span> <span class="number">1</span></span><br><span class="line"><span class="variable">$InputFilePersistStateInterval</span> <span class="number">1</span></span><br><span class="line"><span class="variable">$InputRunFileMonitor</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 两个 @@ 为 tcp 请求</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$syslogtag</span> contains <span class="string">'service-log'</span> <span class="literal">and</span> <span class="variable">$syslogfacility</span>-text == <span class="string">'local7'</span> <span class="keyword">then</span> @<span class="constant">@10</span><span class="number">.0</span><span class="number">.1</span><span class="number">.2</span>:<span class="number">16666</span><span class="comment">;myFileMonitorTemplate</span></span><br><span class="line">&amp; stop</span><br></pre></td></tr></table></figure>
<p>配置文件最后的地址就是对应转发机的内网 ip 地址，这样我们就建立了每个服务器到转发机的连接。然后可以通过 <code>sudo service rsyslog restart</code> 来重启并加载新的配置文件。因为使用 logrotate，所以还要考虑 rotate 时候的日志传输问题，解决办法是在 <code>/etc/logrotate.d/</code> 文件夹中新建一个 <code>_machine_name</code> 文件，内容为</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/data/</span>home<span class="regexp">/service/</span><span class="keyword">project</span><span class="regexp">/current/</span>log<span class="comment">/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    size 200M</span><br><span class="line">    missingok</span><br><span class="line">    rotate 52</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    notifempty</span><br><span class="line">    copytruncate</span><br><span class="line">postrotate</span><br><span class="line"> (sudo stop rsyslog &amp;&amp; sudo sed -i "s/InputFileStateFile.*/</span>InputFileStateFile stat$(date +<span class="string">'%s'</span>)<span class="regexp">/" /</span>etc<span class="regexp">/rsyslog.d/</span><span class="number">10</span>-<span class="keyword">file</span>.conf &amp;&amp; sudo start rsyslog <span class="number">2</span>&gt;&amp;<span class="number">1</span>) || <span class="keyword">true</span></span><br><span class="line">        endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的比较常规，主要是 <code>postrotate</code> 之后执行的脚本，大意就是在日志切分之后完成收尾工作，保证不因为 logrotate 导致日志重复发送或者丢失。</p>
<p>至此，我们就建立了服务器 - 转发机 - ES 的完整链路。</p>
<hr>
<p>更新 rsyslog 的方法，因为要发送到 kafka 需要 v8 的配合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:adiscon/v8-stable</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rsyslog</span><br></pre></td></tr></table></figure>
<p>更新之后就可以弄到 kafka 上了</p>
<h2 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h2><p>前面的配置看起来不复杂，但是其中任何一步没跑通，整个套路就玩不转。具体有没有什么办法能测试呢？当然要有了，不然真是连错都找不到。我们来看看一步一步如何进行测试。</p>
<h3 id="u8F6C_u53D1_u673A_u5230_ES"><a href="#u8F6C_u53D1_u673A_u5230_ES" class="headerlink" title="转发机到 ES"></a>转发机到 ES</h3><p>首先是测试配置文件，直接从 logstash 文件夹前台启动 logstash，并查看具体的信息，确定无误后，再放到后台执行。这里可能遇到的问题基本是跟 logstash 版本相关的，要么升级要么改成对应版本的配置语法即可。</p>
<p>常用的命令有 </p>
<ul>
<li><code>sudo lsof -i:16666</code> 查看对应端口的占用情况</li>
<li><code>ifconfig</code> 查看本机的网络信息</li>
<li><code>cat /proc/meminfo</code> 查看本机的内存信息</li>
<li><code>cat /proc/cpuinfo</code> 查看本机的 CPU 信息</li>
<li><code>ps aux | grep logstash</code> 查看 logstash 对应的进程号（可以用于强制关闭）</li>
</ul>
<h3 id="u670D_u52A1_u5668_u5230_u8F6C_u53D1_u673A"><a href="#u670D_u52A1_u5668_u5230_u8F6C_u53D1_u673A" class="headerlink" title="服务器到转发机"></a>服务器到转发机</h3><p>具体配置的时候，这一步是问题最多的，因为 rsyslog 的配置实在是令人抓狂。基本的测试套路是这样的</p>
<ul>
<li>用 telnet 看看转发机的对应端口开起来没有，如果开起来了，应该是能连通的，不能的话，检查权限与服务配置</li>
<li>可以利用 <code>nc</code> 工具尝试发送单条 log，比如 <code>head -n1 service.log | nc 10.0.1.2 16666</code>，如果卡住，那么说明链路建立有问题，如果能正常发送，就可以看看 ES 到底收到没有了</li>
</ul>
<p>基本上如果这两步都没问题，大概是可以看到链路建立的。如果还不行，考虑到我对运维这块也不是很熟，就只能自力更生或者抱大腿了。</p>
<h2 id="u6539_u8FDB_u65B9_u5411"><a href="#u6539_u8FDB_u65B9_u5411" class="headerlink" title="改进方向"></a>改进方向</h2><p>目前这套非常脆弱的处理流程，每天只能祈祷服务器不崩，崩了之后得自己手动重启（或者写一个守护进程，挂了之后重新启动起来）。这种收集的工作，使用业务服务器『推』的模型，不如统一由日志服务器『拉』，如果借由诸如 S3 这样的外部存储，其实是可以做到解耦的。</p>
<p>所以这就衍生出两个套路，以后可以考虑尝试</p>
<ol>
<li>使用 fluentd</li>
<li>改为『拉』模型</li>
</ol>
<p>具体的以后细写，现在的我，感觉身体被掏空。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>搭建数据平台的过程基本把公司的业务线都过了一遍，深深感受到数据收集处理分析的重要性，这样对产品和服务的改进才不是瞎拍脑袋，才能真正把好钢用到刀刃上（现在的云资源浪费还是很严重的）。</p>
<p>不过嘛，慢慢来，一步一个脚印，每天都在进步就好。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.rsyslog.com/" target="_blank" rel="external">RSYSLOG 官网</a></li>
<li><a href="https://mos.meituan.com/library/5/how-to-config-rsyslog/" target="_blank" rel="external">如何对rsyslog进行配置</a></li>
<li><a href="http://blog.clanzx.net/2013/12/31/rsyslog.html" target="_blank" rel="external">rsyslog 配置简介</a></li>
<li><a href="https://segmentfault.com/a/1190000003509909" target="_blank" rel="external">Linux环境下使用rsyslog管理日志</a></li>
<li><a href="http://www.rsyslog.com/rsyslog-configuration-builder/" target="_blank" rel="external">配置文件生成器</a></li>
<li><a href="http://www.rsyslog.com/using-the-text-file-input-module/" target="_blank" rel="external">Using the Text File Input Module</a></li>
<li><a href="http://www.rsyslog.com/discarding-unwanted-messages/" target="_blank" rel="external">Discarding unwanted messages</a></li>
<li><a href="http://www.rsyslog.com/connecting-with-logstash-via-apache-kafka/" target="_blank" rel="external">Connecting with Logstash via Apache Kafka</a></li>
<li><a href="http://www.rsyslog.com/ubuntu-repository/" target="_blank" rel="external">Ubuntu Repository</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在把公司各个业务线的数据和日志接入到统一的 ELK 平台中，我主要在做 LK 和对接的工作，涉及服务器和网络拓扑相关内容比较多和杂，网上没有太多相关资料，这里跟大家分享一下我的一点经验。</p>]]>
    
    </summary>
    
      <category term="ELK" scheme="http://wdxtub.com/tags/ELK/"/>
    
      <category term="日志" scheme="http://wdxtub.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="服务器" scheme="http://wdxtub.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机科学中的女性]]></title>
    <link href="http://wdxtub.com/2016/08/12/women-in-computer-science/"/>
    <id>http://wdxtub.com/2016/08/12/women-in-computer-science/</id>
    <published>2016-08-12T14:16:41.000Z</published>
    <updated>2016-08-12T15:18:04.000Z</updated>
    <content type="html"><![CDATA[<p>读计算机或相关专业的同学应该都深深明白『僧多粥少』的滋味，之所以希望在书中增加这么一章，是想鼓励更多女生来接触和学习计算机科学。虽然文理分科存在，但是不一定要按照性别来划分嘛。</p>
<a id="more"></a>
<hr>
<p>不谈性别平等。历史上，女性在计算机科学中就扮演了重要角色，比方说第一个程序员就是女性。同时，我们也有女性 CEO，比如 HP 的 Meg Whitman 和 Yahoo 的 Marissa Mayer。</p>
<p>Grace Hopper 是第一个为编程语言创造编译器的人，也是 Mark I 电脑的程序员之一。ENIAC 的日常编程工作是由 6 名女数学家完成的。Adele Goldberg 是研发 Smalltalk 的七名程序员之一。</p>
<p>由 SWIFT(Supporting Women in Information Technology) 发起的调查发现女性通常认为自己缺少在计算机科学中成功的能力。</p>
<p>男女搭配干活不累，团队氛围。</p>
<h2 id="u77E5_u540D_u4EBA_u7269"><a href="#u77E5_u540D_u4EBA_u7269" class="headerlink" title="知名人物"></a>知名人物</h2><ul>
<li>1842: Ada Lovelace (1815–1852) 是查尔斯·巴贝奇计算机分析机论文的分析家，这论文详细说明用该机器计算伯努利数的方法，被认为是世界上第一个计算机程序。她也被后人公认为是第一位计算机程序员。</li>
<li>1926: Grete Hermann (1901-1984) 发表了计算代数奠基论文（其博士论文），名为 The Question of Finitely Many Steps in Polynomial Ideal Theory</li>
<li>1942: 海蒂·拉玛 (1913–2000), 是美国演员，也是展布频谱技术的共同发明人，该技术是现代许多无线通讯系统包括无线局域网络与移动电话的基础关键</li>
<li>1946: Betty Jennings, Betty Snyder, Frances Spence, Kay McNulty, Marlyn Wescoff, 和 Ruth Lichterman 是 ENIAC 的程序员。Adele Goldstine 撰写了 ENIAC 的指南</li>
<li>1948: Kathleen Booth (1922–) 为 ARC2 计算机编写汇编语言is credited with writing the assembly language for the ARC2 computer.[citation needed]</li>
<li>1949:葛丽丝·穆雷·霍普 (1906–1992)是美国海军准将及计算机科学家，世界最早一批的程序员之一，也是最早的女性程序员之一。她是Harvard Mark I上第一个专职程序员，创造了现代第一个编译器A-0 系统，以及第一个高级商用计算机程序语言“COBOL”，被誉为COBOL之母。著名的计算机术语“Debug”（调试排错）便是她在受到从电脑中驱除蛾子的启发而开始使用的，于是她也被冠以“Debug”之母的称号。她也是Y2K危机的创造者。她培育出许多编程语言专家，被人称为不可思议的葛丽丝（Amazing Grace）。</li>
<li>1958: 探险者 1 号的轨道计算由 NASA Jet Propulsion 实验室的全女性团队完成，从高中招募来的</li>
<li>1965: Sister Mary Kenneth Keller (1913–1985) 是第一个获得计算机科学博士学位的美国女性，论文是 Inductive Inference on Computer Generated Patterns</li>
<li>1969: Margaret Hamilton (1936–) 在 1960s 是 MIT Instrumentation 实验室 软件工程分部的主任，为阿波罗空间计划开发了飞行软件，后被授予 NASA Exceptional Space Act Award </li>
<li>1972: Mary Shaw (1943–) 是 CMU 第一位获得计算机科学博士的女性</li>
<li>1972: Adele Goldberg (1945–), Smalltalk 语言的开发者之一</li>
<li>1972: Karen Spärck Jones (1935–2007), 信息获取和自然语言处理的先锋</li>
<li>1974: Elizabeth Feinler (1931–) 和她的团队为互联网主机名定义了简单的文本文件格式，现在负责顶级域名的命名 .mil, .gov, .edu, .org, and .com.</li>
<li>1975: Irene Greif 是 MIT 第一位获得计算机科学博士的女性</li>
<li>1978: Sophie Wilson (1957–) 英国计算机科学家，设计了 Acorn 微处理器以及 ARM 的指令集</li>
<li>1979: Carol Shaw (1955–) 是 Atari 和 Activision 的游戏设计者和开发者</li>
<li>1984: Susan Kare (1954–), 创造了 Apple Macintosh 的图标和许多界面元素，是 NeXT 的创意总监</li>
<li>1988: Éva Tardos (1957–),因为其设计和分析算法的成就获得 Fulkerson Prize </li>
<li>1992: Donna Dubinsky (1955–), Palm 的 CEO 和共同创始人</li>
<li>1993: Shafi Goldwasser (1958–), 理论计算机科学家，因其在复杂性理论、密码学和数值计算理论的贡献，两次获得 Gödel Prizea </li>
<li>1993: 芭芭拉·利斯科夫 (1939.11.7–)与周以真（Jeannette Wing）一起合作提出了著名的Liskov代换原则。芭芭拉是2008年图灵奖得主和2004年约翰·冯诺依曼奖得主。</li>
<li>1994: Sally Floyd (1953–), 因其在 TCP 协议中工作而闻名</li>
<li>1996: Xiaoyuan Tu (1967–), 第一个获得 ACM’s Doctoral Dissertation Award 的女性</li>
<li>1997: 安妮塔·博格 (1949–2003)是安妮塔·博格妇女与科技研究所(IWT)的创建领导人。</li>
<li>2005: 鲁奇·桑维是Facebook第一位女性工程师。</li>
<li>2006: Maria Klawe (1951-), 是哈维马德学院的第一位女性校长，2002到2004年时任ACM计算机协会的主席。</li>
<li>2006: 法兰·艾伦 作为一名编译器优化领域的先驱。1989年成为第一位女性IBM Fellow。她也是IBM技术研究院的主席。2006年她是第一位获得图灵奖的女性。</li>
<li>2012: 玛丽莎·梅耶尔 (1975-), 曾是Google第一位女性工程师，曾任职工程师，设计师，产品经理以及公司副总裁。现在是雅虎的CEO。</li>
<li>2012: 莎菲·戈德瓦塞尔（1958年-) 2012年因她密码学的杰出工作获得图灵奖。[7]。她是美国工程院院士。</li>
</ul>
<h2 id="u56FE_u7075_u5956"><a href="#u56FE_u7075_u5956" class="headerlink" title="图灵奖"></a>图灵奖</h2><ul>
<li>2006 – Francis “Fran” Elizabeth Allen</li>
<li>2008 – Barbara Liskov</li>
<li>2012 – Shafi Goldwasser</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>读计算机或相关专业的同学应该都深深明白『僧多粥少』的滋味，之所以希望在书中增加这么一章，是想鼓励更多女生来接触和学习计算机科学。虽然文理分科存在，但是不一定要按照性别来划分嘛。</p>]]>
    
    </summary>
    
      <category term="女性" scheme="http://wdxtub.com/tags/%E5%A5%B3%E6%80%A7/"/>
    
      <category term="计算机" scheme="http://wdxtub.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Go 之旅】I Go 快速入门]]></title>
    <link href="http://wdxtub.com/2016/08/11/golang-first-step/"/>
    <id>http://wdxtub.com/2016/08/11/golang-first-step/</id>
    <published>2016-08-11T14:31:35.000Z</published>
    <updated>2016-08-16T23:32:36.000Z</updated>
    <content type="html"><![CDATA[<p>作为精简静态语言的狂热粉丝，在 Go 都出到 1.6 版本了才真正开始上手，着实有些说不过去。亡羊补牢犹未为晚，就以这篇文章作 Go 的开端吧，Let’s Go!</p>
<a id="more"></a>
<hr>
<p>本文更新中</p>
<h2 id="u7F18_u8D77"><a href="#u7F18_u8D77" class="headerlink" title="缘起"></a>缘起</h2><p>最初知道 Go，自然是因为是 Google 创造的语言，还想着按照这样的套路，百度可以出个 Ba，腾讯可以出个 Te，阿里可以出个 Al，我自己可以出一个 Wd（虽然并没有这个打算）</p>
<p>后来仔细了解了一下，觉得『嘿，这真是个好东西』，找回了当年学 C 的感觉不说，当时的各种痛点基本都解决了。而工作之后被动态语言折磨得死去活来，也让我更渴望 Keep It Simple Stupid 的编程语言及配套工具。经过一段时间的学习和使用，我觉得 Go 语言的优势在于：</p>
<ul>
<li>工程友好，从开发到部署哪怕需要纯手动配置也不会很麻烦，不用担心各种依赖</li>
<li>简单灵活，自带各种工具，免除很多烦恼，常用库都用，实在不行还有 C 库嘛</li>
<li>生而并发，用 goroutine 和 channel 机制简单粗暴并发，虽然很容易滥用，但是着实降低了门槛</li>
<li>基本上可以认为是靠谱的后台语言（你看！Docker!）</li>
</ul>
<p>当然，因为 Go 的年龄较小，在包版本，goroutine 逻辑和垃圾回收上都还有很大的进步空间，不过我倒是觉得很多『吐槽』都是因为我们被所谓面向对象给洗脑了，也许真正用 Go 的哲学去做事情，才更符合新时代的 Unix 精神吧。</p>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>这里以 Ubuntu 为例（毕竟现在的云服务器基本都是 Ubuntu Linux）进行讲解，安装非常简单，直接上命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">wget https://storage.googleapis.com/golang/go1.<span class="number">6.3</span>.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 解压到 /usr/local（或者也可以解压到自定义目录，就是需要对应配置一下路径）</span></span><br><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.<span class="number">6.3</span>.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 更新 PATH 环境变量，在 ~/.bashrc 中添加下面这行</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"><span class="comment"># 启用更新</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 检测版本</span></span><br><span class="line">go version</span><br></pre></td></tr></table></figure>
<p>如果最后一条命令会显示 go 版本，那么第一步配置就完成了。</p>
<p>第二步我们需要配置 <code>$GOPATH</code> 这个环境变量，这个变量类似于指定 Go 项目的 workspace，比方说新建一个 <code>~/Go</code> 文件夹，然后在 <code>~/.bashrc</code> 中添加 <code>export GOPATH=$HOME/Go</code> 即可（别忘了 <code>source ~/.bashrc</code>）</p>
<p>好消息是，并没有第三步，我们可以开始 Hello World 了！</p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 下的安装和 Linux 相比更为简单一些，因为有直接的安装包，双击然后一路下一步就好。不过这里我们还是绕点远路，配合 zsh 把 Go 环境搭建起来。上命令！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载安装包，wget 可能需要通过 homebrew 安装</span></span><br><span class="line">wget https://storage.googleapis.com/golang/go1.<span class="number">6.3</span>.darwin-amd64.tar.gz</span><br><span class="line"><span class="comment"># 解压到 /usr/local（或者也可以解压到自定义目录，就是需要对应配置一下路径）</span></span><br><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.<span class="number">6.3</span>.darwin-amd64.tar.gz</span><br><span class="line"><span class="comment"># 更新 PATH 环境变量，在 ~/.zshrc 中添加下面这行（注意要添加在原 PATH 之后）</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"><span class="comment"># 启用更新</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"><span class="comment"># 检测版本</span></span><br><span class="line">go version</span><br></pre></td></tr></table></figure>
<p>如果最后一条命令会显示 go 版本，那么第一步配置就完成了。</p>
<p>第二步我们需要配置 <code>$GOPATH</code> 这个环境变量，这个变量类似于指定 Go 项目的 workspace，比方说新建一个 <code>~/Go</code> 文件夹，然后在 <code>~/.zshrc</code> 中添加 <code>export GOPATH=$HOME/Go</code> 即可（别忘了 <code>source ~/.zshrc</code>）</p>
<p>好消息是，并没有第三步，我们可以开始 Hello World 了！</p>
<h3 id="u66F4_u65B0"><a href="#u66F4_u65B0" class="headerlink" title="更新"></a>更新</h3><p>本系列写了没几天 Go 就更新到了 1.7 版本，所以这里也更新一下，方法很简单，直接下载覆盖即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载安装包，wget 可能需要通过 homebrew 安装</span></span><br><span class="line">wget https://storage.googleapis.com/golang/go1.<span class="number">7</span>.darwin-amd64.tar.gz</span><br><span class="line"><span class="comment"># 删除老版本</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="comment"># 解压到 /usr/local（或者也可以解压到自定义目录，就是需要对应配置一下路径）</span></span><br><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.<span class="number">7</span>.darwin-amd64.tar.gz</span><br><span class="line"><span class="comment"># 检测版本</span></span><br><span class="line">go version</span><br></pre></td></tr></table></figure>
<p>应该可以正常看到输出为 <code>go version go1.7 darwin/amd64</code> 了，即更新完成。</p>
<h3 id="u5378_u8F7D_u4E0E_QA"><a href="#u5378_u8F7D_u4E0E_QA" class="headerlink" title="卸载与 QA"></a>卸载与 QA</h3><p>最后提一下删除 Go 的方法，把对应的文件夹和配置文件清理掉即可，非常绿色。</p>
<p>最后的最后，遇到问题可以在 <a href="https://groups.google.com/forum/#!forum/golang-nuts" target="_blank" rel="external">Go Nuts(需要翻墙)</a>，进行提问，也可以在此了解各类最新动态。</p>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>我们在 <code>GOBIG</code> 文件夹下新建一个名为 <code>hello.go</code> 的文件，内容为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="comment">// Say Hello</span>    fmt.Printf(<span class="string">"Hello World! This is wdxtub!\n"</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们执行 <code>go run hello.go</code> 就可以看到输出了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dawang:~/Go$ go run hello.go Hello World! This is wdxtub!</span><br></pre></td></tr></table></figure>
<p>从这个简单的程序中，我们知道：</p>
<ul>
<li>非注释的第一行代码定义包名，每个程序属于一个 package。每个 Go 应用都包含一个名为 main 的包</li>
<li>用 <code>import</code> 关键字来引用包，这里的 <code>fmt</code> 包含了格式化输入输出的相关函数</li>
<li>用 <code>func</code> 关键词来声明函数，而 <code>main</code> 函数是每一个可执行程序必须包含的，一般来说会最先执行（有 <code>init()</code> 函数除外）</li>
<li>和 C 语言一样，用 <code>//</code> 来进行单行注释，用 <code>/* ... */</code> 来进行多行注释</li>
<li>不用分号</li>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）</li>
</ul>
<h2 id="u5E38_u7528_u547D_u4EE4"><a href="#u5E38_u7528_u547D_u4EE4" class="headerlink" title="常用命令"></a>常用命令</h2><p>Go 已经自带了很多非常好用的工具，也可以通过简单的命令进行调用，当然也可以据此轻松配置自己喜欢的编辑器。完整的命令列表可以通过输入 <code>go</code> 来查看，这里简单介绍一下。</p>
<ul>
<li><code>go build hello.go</code> 就可以编译出最终执行文件，这样直接执行 <code>./hello</code> 就可以看到结果</li>
<li><code>go clean</code> 可以清理编译后的文件</li>
<li><code>go doc fmt</code> 可以查看 fmt 包的文档</li>
<li><code>go env</code> 显示 Go 相关的环境变量</li>
<li><code>go fmt</code> 利用 gofmt 工具自动排版代码</li>
<li><code>go get</code> 下载并安装 package</li>
<li><code>go install</code> 编译并安装 package</li>
<li><code>go list</code> 列出 package</li>
<li><code>go run hello.go</code> 编译并运行 Go 程序</li>
<li><code>go test fmt</code> 测试 fmt package</li>
<li><code>go tool</code> 运行指定的 Go 工具，包括 addr2line, asm, cgo, compile, cover, dist, doc, fix, link, nm, objdump, pack, pprof, tour, trace, vet, yacc</li>
</ul>
<p>具体的用法会在后面的介绍中详细说明，这里有个大概印象就好。这里我的开发工具选择是 sublime + terminal，如果觉得费事其实直接 vim 就可以搞定。因为 Go 的语法没有那么复杂，所以不用高级的代码提示与跳转也没有问题。</p>
<h2 id="u57FA_u7840_u5165_u95E8"><a href="#u57FA_u7840_u5165_u95E8" class="headerlink" title="基础入门"></a>基础入门</h2><p>这一部分主要介绍 Go 的基础语法，了解了之后就可以进行简单的编程了</p>
<h3 id="u8BED_u6CD5"><a href="#u8BED_u6CD5" class="headerlink" title="语法"></a>语法</h3><p>基本语法其实非常简单清晰，这里直接以要点的形式列出</p>
<ul>
<li>一行一个语句，不用写分号。如果一行写多个语句，需要用分号隔开，但是并不鼓励这种做法</li>
<li>标识符的第一个字符必须是字母或者下划线，从第二个开始才能用数字</li>
<li>Go 中有 25 个关键字：break, default, func, interface, select, case, defer, go, map, struct, chan, else, goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return var</li>
<li>Go 中有 36 个预定义标识符：append, bool, byte, cap, close, complex, complex64, complex128, uint, uint8, uint16, uint32, uint64, uintptr, copy, false, float32, float64, imag, int, int8, int16, int32, int64, iota, len, make, new, nil, panic, print, println, real, recover, string, true</li>
<li>数据类型有以下几种，非常简洁：<ul>
<li>布尔型 <code>bool</code>，值为 true 或者 false</li>
<li>数字类型 <code>int</code>, <code>float</code>，原生支持复数，如果后面跟了数字，就是指位数</li>
<li>字符串类型 <code>string</code>，用 UTF8 编码</li>
<li>派生类型：指针、数组、结构体、联合、函数、切片、接口、Map、Channel</li>
<li>几个比较特殊的：<ul>
<li><code>byte</code> 类似 <code>uint8</code></li>
<li><code>rune</code> 类似 <code>int32</code></li>
<li><code>uint</code> 32 位或 64 位</li>
<li><code>int</code> 与 <code>uint</code> 大小一样</li>
<li><code>uintptr</code> 无符号整型，用于存放一个指针</li>
</ul>
</li>
</ul>
</li>
<li>变量声明使用 <code>var</code> 关键字，模板为 <code>var identifier type</code>，也就是类型在后面，比如<ul>
<li><code>var a int</code> 标准声明，使用默认值 0</li>
<li><code>var b int = 10</code> 声明且赋值</li>
<li><code>var c = 10</code> 不指明类型，根据赋值类型自动判断</li>
<li><code>d := 10</code> 省略 <code>var</code> 而使用 <code>:=</code>，这里的 <code>d</code> 不能是已经声明过的</li>
<li>可以用 <code>&amp;</code> 来取得值对应的地址（也就是指针），这个后面会详细介绍</li>
</ul>
</li>
<li>常量声明使用 <code>const</code> 关键字，模板为 <code>const identifier [type] = value</code>，其中类型是可选的，比如<ul>
<li><code>const a string = &quot;hello&quot;</code> 显式定义</li>
<li><code>const b = &quot;world&quot;</code> 隐式定义</li>
</ul>
</li>
<li>特殊常量 <code>iota</code>，每一个 const 出现是会被重置为 0，每出现一次 <code>iota</code>，其值会加一，可以用作枚举值</li>
</ul>
<p>因为文字描述比较模糊，这里给出一个 <code>iota</code> 的用法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        a = <span class="constant">iota</span></span><br><span class="line">        b = <span class="number">3</span> &lt;&lt; <span class="constant">iota</span></span><br><span class="line">        c</span><br><span class="line">        d = <span class="number">100</span></span><br><span class="line">        e</span><br><span class="line">        f</span><br><span class="line">        g</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    fmt.Println(a, b, c, d, e, f, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的输出为 <code>0 6 2 100 4 5 6</code>，请仔细感受一下这个加一的过程</p>
<h3 id="u8FD0_u7B97_u7B26"><a href="#u8FD0_u7B97_u7B26" class="headerlink" title="运算符"></a>运算符</h3><p>Go 的运算符也比较『正常』，这里简单点一下</p>
<ul>
<li>算术运算符：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>++</code>, <code>--</code></li>
<li>关系运算符：<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
<li>逻辑运算符：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li>
<li>赋值运算符：<code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code></li>
<li>位运算符：<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li>其他运算符：<code>&amp;</code>(返回变量的存储地址)，<code>*</code> 指针变量</li>
</ul>
<p>运算符优先级也没有什么特别的地方，正常用一般不会有太多『意外』</p>
<h3 id="u6761_u4EF6_u8BED_u53E5"><a href="#u6761_u4EF6_u8BED_u53E5" class="headerlink" title="条件语句"></a>条件语句</h3><p>Go 中的条件语句主要分三种：<code>if</code>, <code>switch</code> 和 <code>select</code>，比较特别的是 <code>select</code>，会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</p>
<p><strong>if</strong></p>
<p>if 语句除了没有了 <code>( )</code> 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中的一样，而 <code>{ }</code> 是必须的。<code>if</code> 语句可以在条件之前执行一个简单的语句。由这个语句定义的变量的作用域仅在 if 范围之内。在 if 的便捷语句定义的变量同样可以在任何对应的 else 块中使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> sqrt(x <span class="typename">float64</span>) <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> pow(x, n, lim <span class="typename">float64</span>) <span class="typename">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里开始就不能使用 v 了</span></span><br><span class="line">	<span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	fmt.Println(sqrt(<span class="number">2</span>), sqrt(-<span class="number">4</span>))</span><br><span class="line">	fmt.Println(</span><br><span class="line">		pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">		pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>switch</strong></p>
<p>对于 switch 语句来说，除非以 fallthrough 语句结束，否则分支会自动终止。switch 的条件从上到下的执行，当匹配成功的时候停止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line">	<span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">"%s."</span>, os)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有条件的 switch 同 <code>switch true</code> 一样。这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	t := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Good morning!"</span>)</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Good afternoon."</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Good evening."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>select</strong></p>
<p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="typename">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="typename">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"c3 is closed\n"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"no communication\n"</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>每个case都必须是一个通信</li>
<li>所有channel表达式都会被求值</li>
<li>所有被发送的表达式都会被求值</li>
<li>如果任意某个通信可以进行，它就执行；其他被忽略。</li>
<li>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。否则：<ul>
<li>如果有default子句，则执行该语句。</li>
<li>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</li>
</ul>
</li>
</ul>
<h3 id="u5FAA_u73AF_u8BED_u53E5"><a href="#u5FAA_u73AF_u8BED_u53E5" class="headerlink" title="循环语句"></a>循环语句</h3><p>Go 只有一种循环结构——<code>for</code> 循环。基本的 for 循环除了没有了 <code>( )</code> 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中做的一样，而 <code>{ }</code> 是必须的。跟 C 或者 Java 中一样，可以让前置、后置语句为空。基于此可以省略分号：C 的 while 在 Go 中叫做 <code>for</code>。如果省略了循环条件，循环就不会结束，因此可以用更简洁地形式表达死循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">	</span><br><span class="line">	sum := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">		sum += sum</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">	</span><br><span class="line">	sum := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">		sum += sum</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u8FDB_u9636_u6982_u5FF5"><a href="#u8FDB_u9636_u6982_u5FF5" class="headerlink" title="进阶概念"></a>进阶概念</h2><p>这里简单了解一下稍微进阶一些的程序组成元素，为以后的学习打下基础。</p>
<h3 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h3><p>函数可以没有参数或接受多个参数，注意类型名在变量名之后。当两个或多个连续函数的命名参数是同一类型，则除了最后一个类型之外，其他都可以省略，函数可以返回任意数量的返回值，比如 <code>swap</code> 函数</p>
<p>Go 的返回值可以被命名，并且像变量那样使用。返回值的名称应当具有一定的意义，可以作为文档使用。没有参数的 return 语句返回结果的当前值。也就是<code>直接</code>返回。直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<p>在函数中，<code>:=</code> 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。函数外的每个语句都必须以关键字开始（<code>var</code>、<code>func</code>、等等），<code>:=</code> 结构不能使用在函数外。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="typename">bool</span></span><br><span class="line"><span class="keyword">var</span> i, j <span class="typename">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> add(x <span class="typename">int</span>, y <span class="typename">int</span>) <span class="typename">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> anotheradd(x, y <span class="typename">int</span>) <span class="typename">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> swap(x, y <span class="typename">string</span>) (<span class="typename">string</span>, <span class="typename">string</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> split(sum <span class="typename">int</span>) (x, y <span class="typename">int</span>) &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">    a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">    <span class="keyword">var</span> k <span class="typename">int</span></span><br><span class="line">    fmt.Println(k, c, python, java)</span><br><span class="line">    fmt.Println(i, j)</span><br><span class="line">    y := <span class="number">3</span></span><br><span class="line">    cpp, ruby, scala := <span class="constant">true</span>, <span class="constant">false</span>, <span class="string">"yes"</span></span><br><span class="line">    fmt.Println(y, cpp, ruby, scala)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h3><p>类型 <code>[n]T</code> 是一个有 n 个类型为 T 的值的数组。表达式 <code>var a [10]int</code> 定义变量 a 是一个有十个整数的数组。数组的长度是其类型的一部分，因此数组不能改变大小。 这看起来是一个制约，但是请不要担心； Go 提供了更加便利的方式来使用数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">2</span>]<span class="typename">string</span></span><br><span class="line">	a[<span class="number">0</span>] = <span class="string">"Hello"</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="string">"World"</span></span><br><span class="line">	fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6307_u9488"><a href="#u6307_u9488" class="headerlink" title="指针"></a>指针</h3><p>Go 具有指针。 指针保存了变量的内存地址。</p>
<p>类型 <code>*T</code> 是指向类型 <code>T</code> 的值的指针。其零值是 <code>nil</code>。</p>
<p><code>var p *int</code></p>
<p><code>&amp;</code> 符号会生成一个指向其作用对象的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure>
<p><code>*</code> 符号表示指针指向的底层的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(*p) <span class="comment">// 通过指针 p 读取 i</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针 p 设置 i</span></span><br></pre></td></tr></table></figure>
<p>这也就是通常所说的“间接引用”或“非直接引用”。与 C 不同，Go 没有指针运算。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">	p := &amp;i         <span class="comment">// point to i</span></span><br><span class="line">	fmt.Println(*p) <span class="comment">// read i through the pointer</span></span><br><span class="line">	*p = <span class="number">21</span>         <span class="comment">// set i through the pointer</span></span><br><span class="line">	fmt.Println(i)  <span class="comment">// see the new value of i</span></span><br><span class="line"></span><br><span class="line">	p = &amp;j         <span class="comment">// point to j</span></span><br><span class="line">	*p = *p / <span class="number">37</span>   <span class="comment">// divide j through the pointer</span></span><br><span class="line">	fmt.Println(j) <span class="comment">// see the new value of j</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7ED3_u6784_u4F53"><a href="#u7ED3_u6784_u4F53" class="headerlink" title="结构体"></a>结构体</h3><p>一个结构体（<code>struct</code>）就是一个字段的集合。（而 type 的含义跟其字面意思相符。）结构体字段使用点号来访问。结构体字段可以通过结构体指针来访问。通过指针间接的访问是透明的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="typename">int</span></span><br><span class="line">	Y <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">	v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	v.X = <span class="number">4</span></span><br><span class="line">	fmt.Println(v.X)</span><br><span class="line">	</span><br><span class="line">	p := &amp;v</span><br><span class="line">	p.X = <span class="number">1e9</span></span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）特殊的前缀 &amp; 返回一个指向结构体的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 类型为 Vertex</span></span><br><span class="line">	v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被省略</span></span><br><span class="line">	v3 = Vertex&#123;&#125;      <span class="comment">// X:0 和 Y:0</span></span><br><span class="line">	p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 类型为 *Vertex</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5207_u7247"><a href="#u5207_u7247" class="headerlink" title="切片"></a>切片</h3><p>一个 slice 会指向一个序列的值，并且包含了长度信息。 <code>[]T</code> 是一个元素类型为 T 的 slice。slice 可以重新切片，创建一个新的 slice 值指向相同的数组。表达式 <code>s[lo:hi]</code> 表示从 lo 到 hi-1 的 slice 元素，含两端。因此 <code>s[lo:lo]</code> 是空的，而 <code>s[lo:lo+1]</code> 有一个元素。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	p := []<span class="typename">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">"p =="</span>, p)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"p[%d] == %d\n"</span>, i, p[i])</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fmt.Println(<span class="string">"p[1:4] =="</span>, p[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略下标代表从 0 开始</span></span><br><span class="line">	fmt.Println(<span class="string">"p[:3] =="</span>, p[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略上标代表到 len(s) 结束</span></span><br><span class="line">	fmt.Println(<span class="string">"p[4:] =="</span>, p[<span class="number">4</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice 由函数 make 创建。这会分配一个零长度的数组并且返回一个 slice 指向这个数组： <code>a := make([]int, 5)  // len(a)=5</code> 为了指定容量，可传递第三个参数到 <code>make</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	a := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">5</span>)</span><br><span class="line">	printSlice(<span class="string">"a"</span>, a)</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">	printSlice(<span class="string">"b"</span>, b)</span><br><span class="line">	c := b[:<span class="number">2</span>]</span><br><span class="line">	printSlice(<span class="string">"c"</span>, c)</span><br><span class="line">	d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">	printSlice(<span class="string">"d"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> printSlice(s <span class="typename">string</span>, x []<span class="typename">int</span>) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s len=%d cap=%d %v\n"</span>,</span><br><span class="line">		s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice 的零值是 <code>nil</code>。一个 nil 的 slice 的长度和容量是 0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> z []<span class="typename">int</span></span><br><span class="line">	fmt.Println(z, <span class="built_in">len</span>(z), <span class="built_in">cap</span>(z))</span><br><span class="line">	<span class="keyword">if</span> z == <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"nil!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向 slice 添加元素是一种常见的操作，因此 Go 提供了一个内建函数 <code>append</code>。 内建函数的文档对 append 有详细介绍。<code>func append(s []T, vs ...T) []T</code></p>
<ul>
<li>append 的第一个参数 s 是一个类型为 T 的数组，其余类型为 T 的值将会添加到 slice。</li>
<li>append 的结果是一个包含原 slice 所有元素加上新添加的元素的 slice。</li>
<li>如果 s 的底层数组太小，而不能容纳所有值时，会分配一个更大的数组。 返回的 slice 会指向这个新分配的数组。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> a []<span class="typename">int</span></span><br><span class="line">	printSlice(<span class="string">"a"</span>, a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// append works on nil slices.</span></span><br><span class="line">	a = <span class="built_in">append</span>(a, <span class="number">0</span>)</span><br><span class="line">	printSlice(<span class="string">"a"</span>, a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the slice grows as needed.</span></span><br><span class="line">	a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">	printSlice(<span class="string">"a"</span>, a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we can add more than one element at a time.</span></span><br><span class="line">	a = <span class="built_in">append</span>(a, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">	printSlice(<span class="string">"a"</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> printSlice(s <span class="typename">string</span>, x []<span class="typename">int</span>) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s len=%d cap=%d %v\n"</span>,</span><br><span class="line">		s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环的 range 格式可以对 slice 或者 map 进行迭代循环。可以通过赋值给 <code>_</code> 来忽略序号和值。如果只需要索引值，去掉“, value”的部分即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>map 映射键到值。map 在使用之前必须用 make 而不是 new 来创建；值为 nil 的 map 是空的，并且不能赋值。map 的文法跟结构体文法相似，不过必须有键名。如果顶级的类型只有类型名的话，可以在文法的元素中省略键名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat, Long <span class="typename">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="typename">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mmm = <span class="keyword">map</span>[<span class="typename">string</span>]Vertex&#123;</span><br><span class="line">	<span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, -<span class="number">74.39967</span>&#125;,</span><br><span class="line">	<span class="string">"Google"</span>:    &#123;<span class="number">37.42202</span>, -<span class="number">122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]Vertex)</span><br><span class="line">	m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line">		<span class="number">40.68433</span>, -<span class="number">74.39967</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> mm = <span class="keyword">map</span>[<span class="typename">string</span>]Vertex&#123;</span><br><span class="line">    	<span class="string">"Bell Labs"</span>: Vertex&#123;</span><br><span class="line">    		<span class="number">40.68433</span>, -<span class="number">74.39967</span>,</span><br><span class="line">    	&#125;,</span><br><span class="line">    	<span class="string">"Google"</span>: Vertex&#123;</span><br><span class="line">    		<span class="number">37.42202</span>, -<span class="number">122.08408</span>,</span><br><span class="line">    	&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(mm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 map m 中插入或修改一个元素：<code>m[key] = elem</code>。获得元素：<code>elem = m[key]</code>。删除元素：<code>delete(m, key)</code>。通过双赋值检测某个键存在：<code>elem, ok = m[key]</code> 如果 key 在 m 中，<code>ok</code> 为 true 。否则， ok 为 <code>false</code>，并且 elem 是 map 的元素类型的零值。同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</span><br><span class="line"></span><br><span class="line">	m[<span class="string">"Answer"</span>] = <span class="number">42</span></span><br><span class="line">	fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">	m[<span class="string">"Answer"</span>] = <span class="number">48</span></span><br><span class="line">	fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(m, <span class="string">"Answer"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">	v, ok := m[<span class="string">"Answer"</span>]</span><br><span class="line">	fmt.Println(<span class="string">"The value:"</span>, v, <span class="string">"Present?"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这节课我们了解了 Go 语言中的基础概念，但是对于更多高级的特性涉及得不多，尤其是并发和错误处理的部分，接下来我们会结合例子来详细介绍一下 Go 中的高级特性。</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://golang.org/doc/install" target="_blank" rel="external">Getting Started</a></li>
<li><a href="http://www.runoob.com/go/go-tutorial.html" target="_blank" rel="external">Go 语言教程</a></li>
<li><a href="https://go-tour-zh.appspot.com/basics/1" target="_blank" rel="external">Go 指南</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为精简静态语言的狂热粉丝，在 Go 都出到 1.6 版本了才真正开始上手，着实有些说不过去。亡羊补牢犹未为晚，就以这篇文章作 Go 的开端吧，Let’s Go!</p>]]>
    
    </summary>
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="后端" scheme="http://wdxtub.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="静态语言" scheme="http://wdxtub.com/tags/%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【高效程序的奥秘】位之道]]></title>
    <link href="http://wdxtub.com/2016/08/11/hacker-delight/"/>
    <id>http://wdxtub.com/2016/08/11/hacker-delight/</id>
    <published>2016-08-11T13:04:58.000Z</published>
    <updated>2016-08-11T13:06:19.000Z</updated>
    <content type="html"><![CDATA[<p>上古时代的程序员为了提高程序性能挖空心思去创造『黑魔法』，在这之中，屠龙之技恐怕就是各种神乎其技的位操作了。果你要编写最优化编译器或者高性能的代码，就必须阅读这本书。</p>
<a id="more"></a>
<hr>
<p>但是话说回来，在编译器优化足够好并且各类高性能运算库层出不穷的今天，这类写快速代码的各种位操作的套路基本沦为面试题，比如：</p>
<ul>
<li><code>a = x &amp; (x-1)</code> 检查一个无符号整数是否为 2 的幂，如果是 <code>a</code> 应为 0</li>
<li><code>a = x &amp; (x+1)</code> 检测一个五符号整数是否为 $2^n-1$ 的形式</li>
<li><code>a = x &amp; (-x)</code> 找出最右侧的 1 位，如果没有 1 位则生成所有位均为 0 的字</li>
</ul>
<p>正如书中前言所说：软件维护成本的增加与程序设计人员的创造力的平方成正比。在计算机程序越来越复杂的今天，过分在意微小的性能优化而牺牲了可读性与可维护性其实是非常得不偿失的，反而从业务逻辑层面入手自上而下进行设计优化才可能是更加靠谱的方法。</p>
<p>每种技术方法和趋势都有其对应的时代背景，多多考虑历史的进程才能真正称为弄潮儿。另外，如果想要理解本书的各种小技巧，需要对计算机系统的基本知识有比较详细的了解，通过这种方法来夯实基础也是不错的选择。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上古时代的程序员为了提高程序性能挖空心思去创造『黑魔法』，在这之中，屠龙之技恐怕就是各种神乎其技的位操作了。果你要编写最优化编译器或者高性能的代码，就必须阅读这本书。</p>]]>
    
    </summary>
    
      <category term="位" scheme="http://wdxtub.com/tags/%E4%BD%8D/"/>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="程序" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[非主流程序员的自我修养]]></title>
    <link href="http://wdxtub.com/2016/08/09/im-a-programmer/"/>
    <id>http://wdxtub.com/2016/08/09/im-a-programmer/</id>
    <published>2016-08-09T11:43:07.000Z</published>
    <updated>2016-08-09T13:31:11.000Z</updated>
    <content type="html"><![CDATA[<p>作为一个非主流程序员，实话说，写代码其实是我最擅长的事情里面最不擅长的事情。但是在这个对单身狗伤害很大的日子里，谨以此文承担一点伤害。</p>
<a id="more"></a>
<hr>
<p>非主流程序员自然要走和别人不一样的路，所谓『不一样』，并不一定是大家都学的东西我就不学，而是在怎么学，什么时候学这些问题上『不一定』要按照所谓『最佳』路线，毕竟最高级的教育是『因材施教』。互联网上浩如烟海的资源使得我们甚至都不需要去找某个特定的老师，『因材施教』放到今天，对于非主流程序员来说，更应该是『因材自教』。借着奥运会的东风，就以起跑的口令为例，来写写我这个非主流程序员的自我修养吧。</p>
<p><img src="/images/14707486352075.jpg" alt=""></p>
<h2 id="u5404_u5C31_u5404_u4F4D"><a href="#u5404_u5C31_u5404_u4F4D" class="headerlink" title="各就各位"></a>各就各位</h2><p>比写代码还重要的事情，需要在写代码之前就做好，或者说，至少知道要做好。</p>
<h3 id="u558A_u5BF9_u540D_u5B57"><a href="#u558A_u5BF9_u540D_u5B57" class="headerlink" title="喊对名字"></a>喊对名字</h3><p>我觉得吧，英文不一定要母语水平这么高，但是基本的单词发音还是要读对的。比方说：</p>
<ul>
<li>Adobe, AJAX, APP, avatar, array</li>
<li>Chrome, C#, Cache</li>
<li>Debian</li>
<li>Exposé</li>
<li>GNU, GUI, GNOME</li>
<li>Integer</li>
<li>JAVA, jpg, JSON</li>
<li>Linux, LaTex, Lucene</li>
<li>MySQL, maven</li>
<li>Null, Nginx</li>
<li>Retina</li>
<li>suite, Safari</li>
<li>Tumblr</li>
<li>Ubuntu</li>
<li>WiFi</li>
</ul>
<p>不然听起来真的很傻，尤其是和外国人聊天的时候，对方会一脸懵逼的。扩展一下，其实基本的英语，包括听说读写，都是很重要的，毕竟大部分文档，都只有英文版不是吗？</p>
<h3 id="u8D77_u4E2A_u597D_u540D"><a href="#u8D77_u4E2A_u597D_u540D" class="headerlink" title="起个好名"></a>起个好名</h3><p>名字有多重要？先感受一下『楚留香陆小凤傅红雪李寻欢』，再感受一下『李狗蛋王二小黄小鸡张鸭蛋』，差别差别差别啊！</p>
<p>所以！大到项目，小到变量名，都需要仔细选择名字，就要那种一眼就看出来这是啥到底要干嘛的名字！不仅自己看得懂，重要的是别人也看得懂！</p>
<h3 id="u6587_u6863_u600E_u4E48_u5199"><a href="#u6587_u6863_u600E_u4E48_u5199" class="headerlink" title="文档怎么写"></a>文档怎么写</h3><p>文档其实就是作文，好的文档循序渐进深入浅出降低难度，不好的文档东一耙西一耙逻辑混乱根本没法读。当然如果这样说太抽象，那么就按照『标题党』的套路来写文档吧！重要的需要大家注意的直接塞标题里！然后开门见山先把最重要的东西说出来，然后才是各类『写得很长但估计没有人看』的细节。</p>
<p>没错了！这就是金字塔写作啊！</p>
<h3 id="u7A0B_u5E8F_u5458_u601D_u7EF4"><a href="#u7A0B_u5E8F_u5458_u601D_u7EF4" class="headerlink" title="程序员思维"></a>程序员思维</h3><p>首先要强调的是，程序员绝对不是呆板，反而应该是呆板的反面。在我看来，真正的程序员思维是：</p>
<ul>
<li>从学习规则到培养直觉，相信直觉的同时进行谨慎验证</li>
<li>从模仿开始，在实践中成长，最后通过教学完成蜕变</li>
<li>联系一切，努力透过现象看本质</li>
<li>主动阅读，组织学习小组</li>
<li>能够集中注意力，留给自己固定的时间去思考</li>
<li>高效管理知识</li>
<li>用版本控制的方式推进各类事情</li>
<li>不把事情做好不停歇，轻微的完美主义者</li>
</ul>
<p>一个这样的人怎么可能是呆板的人？？？！！！</p>
<h3 id="u975E_u4E3B_u6D41_u6280_u80FD"><a href="#u975E_u4E3B_u6D41_u6280_u80FD" class="headerlink" title="非主流技能"></a>非主流技能</h3><p>没有几个非主流技能，怎么好自称是『非主流程序员』呢？</p>
<ul>
<li>『跑火车』- 拉近距离，减少沟通成本，该正经的时候，比谁都认真</li>
<li>『开脑洞』- 思维跳跃，不按常理出牌，逆向思维是什么，我擅长乱向思维</li>
<li>『老人病』- 因为无论什么时候睡六点都会醒，所以只能早睡，也逼着自己按照更健康的方式去生活，比方说下班跑步回家</li>
<li>『挑食』- 挑的不是特定的食物，而是食物的水准，美酒美食，不能停止了供应</li>
<li>『不全务正业』- 多接触各行各业各类人，毕竟世界这么大，总得去看看</li>
<li>『打广告』- 抓住机会展示自我，毕竟，再不让别人知道有我这么个人，我就没人要了</li>
</ul>
<p>这年头没有点癖好都不好意思出来见人咧！</p>
<h2 id="u9884_u5907"><a href="#u9884_u5907" class="headerlink" title="预备"></a>预备</h2><p>怎么把代码写好这件事，需要在写的时候不断磨练。</p>
<h3 id="u5B66_u4F1A_u5B66_u4E60"><a href="#u5B66_u4F1A_u5B66_u4E60" class="headerlink" title="学会学习"></a>学会学习</h3><p>这又是一个好大好大的话题，其实秘诀大部分都在我们非常枯燥的语文教育中：</p>
<ul>
<li>背诵全文 - 识记，掌握基本概念，为后面的理解打基础</li>
<li>总结中心思想 - 在大量阅读中抽取核心内容，理清脉络</li>
<li>话题作文 - 不断问自己相互关联的概念和思路，搜索各类资料支持自己的思路，并组织文字来进行展示</li>
</ul>
<p>有悟性的同学应该已经意识到学习的精髓了，简单来说和现在数据挖掘的套路一样一样的：信息获取，信息抽取，发现关联。</p>
<p>如果还有什么，那就是『纸上得来终觉浅，绝知此事要躬行』</p>
<h3 id="u6570_u636E_u7ED3_u6784_u4E0E_u7B97_u6CD5"><a href="#u6570_u636E_u7ED3_u6784_u4E0E_u7B97_u6CD5" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>这俩真的太重要了，如果计算机是一个人，那么数据结构是肢体，算法是大脑。人进化到今天是自然选择，其实计算机进化的今天也是某种意义上的『自然选择』。所以就不难意识到，为什么很多生物学的方法都能用在计算机科学上。蚁群算法、随机过程、神经网络等等，这不是什么冥冥之中，这就是天注定啊。</p>
<p>所以不把这俩学好，都没办法成为一个程序员，更不要说成为一个非主流的程序员了。</p>
<p>至于怎么学，请看前一节。</p>
<h3 id="u7F16_u7A0B_u8BED_u8A00"><a href="#u7F16_u7A0B_u8BED_u8A00" class="headerlink" title="编程语言"></a>编程语言</h3><p>不同的编程语言类似不同的工具，有的像成为瑞士军刀，有的只是想成为螺丝刀，但是有的想成为航母。换个比喻，不同的编程语言类似不同的国家，各有各的风情万种，虽然有的地方大，有的土豪多，还有的特别混乱，但是去见见世面还是不错的。</p>
<p>不过大约我们都有自己的家乡，根据混江湖是时间长短，可能还有第二第三家乡。但是硬要成为一个『世界公民』，恐怕天下大乱的时候就会第一个被甩掉了。</p>
<p>至于家乡是哪种编程语言，有的时候真的不能强求。也许学习编程语言是最容易达成的『我懂八种语言！』成就的，但是说出来往往要被人嘲笑。</p>
<h3 id="u7F51_u7EDC_u4E0E_Linux"><a href="#u7F51_u7EDC_u4E0E_Linux" class="headerlink" title="网络与 Linux"></a>网络与 Linux</h3><p>没有 WiFi 就生病这种病，即使深入了解了计算机网络也治不了。但是现在的程序，不跟网络扯上关系的真的太少了。作为一个非主流程序员，不了解七层模型的每一层，走在路上都心慌慌。</p>
<p>和这个症状类似的还有 Linux。什么？你说你是 Windows 程序员，好吧，最近有个 Bash on Ubuntu on Windows 知道不。微软爸爸辛辛苦苦内嵌一个 Linux，就是要我们去学习的啊！不把 grep/awk/sed 这些搞懂，找个进程号真的都会找不到的。</p>
<p>真的，这俩绝对学起来装逼指数 MAX，外人看来就是在黑屏白字里啪啪啪就拯救世界了啊。</p>
<h3 id="u4E91_u670D_u52A1"><a href="#u4E91_u670D_u52A1" class="headerlink" title="云服务"></a>云服务</h3><p>以隔壁云老王为首的云服务已经成为居家旅行必备良药，很多以前需要劳神费力操八辈子心的东西，现在只要出点钱就可以了，甚至还比以前便宜，这就是云啊。</p>
<p>当然，基本原理还是要懂的嘛，毕竟学会了之后，就知道怎么褥云羊毛了嘛。</p>
<p>毕竟如果不想多买一台电脑，可以考虑几块钱一天租一台嘛！</p>
<h2 id="u7830_uFF01"><a href="#u7830_uFF01" class="headerlink" title="砰！"></a>砰！</h2><p>把代码写好之后，就该考虑考虑代码之外的东西了。</p>
<h3 id="u8BBE_u8BA1"><a href="#u8BBE_u8BA1" class="headerlink" title="设计"></a>设计</h3><blockquote>
<p>均衡，存乎万物之间</p>
</blockquote>
<p>设计其实就是平衡很多东西，包括但不限于：时间功能成本人力团队资源。</p>
<p>看吧，这篇文章结构设计这么精巧，就是有套路的。</p>
<h3 id="u4EA7_u54C1_u7ECF_u7406"><a href="#u4EA7_u54C1_u7ECF_u7406" class="headerlink" title="产品经理"></a>产品经理</h3><p>不由得想到了昨天看到的一个笑话，大意是程序员的大脑 50 元 1 斤，但是产品经理的大脑 500 元 1 斤。为什么？因为要 10 个产品经理的大脑才等于 1 个程序员的（比例可以根据需要随意调整）</p>
<p>都是被『人人都是产品经理』带坏的。毕竟不是所有事情都只需要拍脑袋。怎么获取所需的资源，怎么判断优先级，怎么跟上进度，这些把脑袋拍爆也没用啊。</p>
<h3 id="u535A_u5BA2"><a href="#u535A_u5BA2" class="headerlink" title="博客"></a>博客</h3><p>写博客最大的好处就是再也不用担心记不住命令配不好环境找不到参考链接啦。而且能把知识分享出去，你好我好大家好，通过输出来强迫自己输入，其实也是一种很好的自律方式。</p>
<p>而且写得好还可以出书！</p>
<p>可以出书！</p>
<p>出书！</p>
<h3 id="u56E2_u961F_u5408_u4F5C"><a href="#u56E2_u961F_u5408_u4F5C" class="headerlink" title="团队合作"></a>团队合作</h3><p>搬砖当然要大家一起搬！毕竟砖是搬不完的。这么想，如果一共要搬十块砖，而队友可以搬一百块，那么除了搬砖就可以去做很多有趣的事情了！</p>
<p>想想就很激动不是吗！万一搞出一个大新闻呢？？！！</p>
<h3 id="u4E66_u5355"><a href="#u4E66_u5355" class="headerlink" title="书单"></a>书单</h3><p>最后一部分是书单，站在巨人肩上最好的方式就是读巨人的书，真的真的就是这么简单，坚持读坚持思考坚持输入输出，有一天就会发现，一切似乎没有改变，但是一切其实都已改变。</p>
<p>书单其实就在这个页面上，但是我还是非常伟大的，贴了链接：</p>
<p><a href="http://wdxtub.com/booklist/">点这里</a> <a href="http://wdxtub.com/booklist/">或者点这里</a> <a href="http://wdxtub.com/booklist/">再或者点这里</a> </p>
<p><a href="http://wdxtub.com/booklist/">如果前面三个都不喜欢，可以点这里</a></p>
<h2 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实前面的都是套路，关键就在这里：</p>
<p><strong>我要告别单身狗，努力从今天做起，诚邀女友一名！</strong>（长期有效，有效到无效为止）</p>
<p>（男生也不要立即关闭，可以转发给身边的女性朋友啊）</p>
<h2 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.gitbook.com/book/leohxj/a-programmer-prepares/details" target="_blank" rel="external">程序员的自我修养 - 我所认为的程序员的自我养成手册</a></li>
<li><a href="https://www.zhihu.com/question/19739907" target="_blank" rel="external">IT 圈里有哪些经常被读错的词？</a></li>
<li><a href="http://coolshell.cn/articles/4990.html" target="_blank" rel="external">程序员技术练级攻略</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为一个非主流程序员，实话说，写代码其实是我最擅长的事情里面最不擅长的事情。但是在这个对单身狗伤害很大的日子里，谨以此文承担一点伤害。</p>]]>
    
    </summary>
    
      <category term="七夕" scheme="http://wdxtub.com/tags/%E4%B8%83%E5%A4%95/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="非主流" scheme="http://wdxtub.com/tags/%E9%9D%9E%E4%B8%BB%E6%B5%81/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【重构 改善既有代码的设计】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/08/09/refactoring-clip/"/>
    <id>http://wdxtub.com/2016/08/09/refactoring-clip/</id>
    <published>2016-08-08T22:10:41.000Z</published>
    <updated>2016-08-11T13:05:36.000Z</updated>
    <content type="html"><![CDATA[<p>重构：在代码写好之后改进它的设计。</p>
<a id="more"></a>
<hr>
<p>尽管关注对象是代码，但重构对于系统设计也有巨大影响。资深设计师和架构师也很有必要了解重构原理，并在自己的项目中运用重构技术。最好是由老资格、经验丰富的开发人员来引入重构技术，因为这样的人最能够透彻理解重构背后的原理，并根据情况加以调整，使之适用于特定工作领域。</p>
<p>如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。</p>
<p>重构之前，首先检查自己是否有一套可靠的测试机制，这些测试必须有自我检验能力。</p>
<p>重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。</p>
<p>任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。</p>
<p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</p>
<p>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p>
<h2 id="u91CD_u6784_u539F_u5219"><a href="#u91CD_u6784_u539F_u5219" class="headerlink" title="重构原则"></a>重构原则</h2><p>为何重构：</p>
<ul>
<li>重构改进设计</li>
<li>重构使软件更容易理解</li>
<li>帮助找到 bug</li>
<li>重构提高编程速度</li>
</ul>
<hr>
<p>何时重构：</p>
<ul>
<li>三次法则：事不过三，三则重构</li>
<li>添加功能时重构</li>
<li>修补错误时重构</li>
<li>复审代码时重构</li>
</ul>
<hr>
<p>重构的难题</p>
<ul>
<li>数据库</li>
<li>修改接口：不要过早发布接口</li>
<li>难以通过重构手法完成的设计改动</li>
</ul>
<hr>
<h2 id="u4EE3_u7801_u7684_u574F_u5473_u9053"><a href="#u4EE3_u7801_u7684_u574F_u5473_u9053" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><ul>
<li>重复代码</li>
<li>过长函数</li>
<li>过大的类</li>
<li>过长参数列</li>
<li>发散式变化：类经常因为不同的原因在不同的方向上发生变化</li>
<li>霰弹式修改：每遇到某种变化，你都必须在许多不同的类内做出许多小修改</li>
<li>依恋情结：一个类的动作过分依赖其他类</li>
<li>数据泥团：不同地方的相同数据字段</li>
<li>基本类型偏执</li>
<li>Switch 惊悚现身：考虑用多态代替 switch</li>
<li>平行继承体系：为某个类增加一个子类的时候，也必须为另一个类相应增加一个子类</li>
<li>冗赘类</li>
<li>夸夸其谈未来性：某个抽象类其实没啥太大作用</li>
<li>令人迷惑的暂时字段</li>
<li>过度耦合的消息链</li>
<li>中间人：某个类接口有一半的函数都委托给其他类</li>
<li>狎昵关系：两个类过于亲密</li>
<li>异曲同工的类：两个函数做同一件事，却有着不同的签名</li>
<li>不完美的库类</li>
<li>纯稚的数据类：单纯的数据容器</li>
<li>被拒绝的遗赠：子类复用超类的行为，却又不愿意支持超类的接口</li>
<li>过多的注释：当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余</li>
</ul>
<h2 id="u6784_u7B51_u6D4B_u8BD5_u4F53_u7CFB"><a href="#u6784_u7B51_u6D4B_u8BD5_u4F53_u7CFB" class="headerlink" title="构筑测试体系"></a>构筑测试体系</h2><ul>
<li>确保所有测试都完全自动化，让它们检查自己的测试结果</li>
<li>一套测试就是一个强大的 bug 侦测器，能够大大缩减查找 bug 所需要的时间</li>
<li>频繁地运行测试。每次编译请把测试也考虑进去——每天至少执行每个测试一次</li>
<li>每当你收到 bug 报告，请先写一个单元测试来暴露 bug</li>
<li>编写未臻完善的测试并实际运行，好过对完美测试的无尽等待</li>
<li>考虑可能出错的边界条件，把测试火力集中在那儿</li>
<li>当事情被认为应该会出错时，别忘了检查是否抛出了预期的异常</li>
<li>不要因为测试无法捕捉所有 bug 就不写测试，因为测试的确可以捕捉到大多数 bug</li>
</ul>
<h2 id="u91CD_u65B0_u7EC4_u7EC7_u51FD_u6570"><a href="#u91CD_u65B0_u7EC4_u7EC7_u51FD_u6570" class="headerlink" title="重新组织函数"></a>重新组织函数</h2><h3 id="u63D0_u70BC_u51FD_u6570_Extract_Method"><a href="#u63D0_u70BC_u51FD_u6570_Extract_Method" class="headerlink" title="提炼函数 Extract Method"></a>提炼函数 Extract Method</h3><p>有一段代码可以被组织在一起并独立出来 -&gt; 将折断代码放进一个独立函数中，并让函数名称解释该函数的用途。</p>
<ul>
<li>创造一个新函数，根据这个函数的意图来对它命名（以它『做什么』来命名，而不是以它『怎样做』命名）</li>
<li>将提炼出的代码从源函数复制到新建的目标函数中</li>
<li>仔细检查提炼出的代码，看看是否引用了『作用域限于源函数』的变量（包括局部变量和源函数参数）</li>
<li>检查是否有『仅用于被提炼代码段』的临时变量。如果有，在目标函数中将它们声明为临时变量</li>
<li>检查被提炼代码段，看看是否有任何局部变量的值被它改变。如果一个临时变量值被修改了，看看是否可以将被提炼代码段处理为一个查询，并将结果赋值给相关变量。如果被修改的变量不止一个，你就不能仅仅将这段代码原封不动地提炼出来</li>
<li>将被提炼代码段中需要读取的局部变量，当做参数传给目标函数</li>
<li>处理完所有局部变量之后，进行编译</li>
<li>在源函数中，将被提炼代码段替换为对目标函数的调用（如果你将任何临时变量移到目标函数中，请检查它们原本的声明式是否在被提炼代码段的外围。如果是，现在你可以删除这些声明式了）</li>
<li>编译，测试</li>
</ul>
<h3 id="u5185_u8054_u51FD_u6570_Inline_Method"><a href="#u5185_u8054_u51FD_u6570_Inline_Method" class="headerlink" title="内联函数 Inline Method"></a>内联函数 Inline Method</h3><p>一个函数的本体与名称同样清楚易懂 -&gt; 在函数调用点插入函数本体，然后移除该函数</p>
<ul>
<li>检查函数，确定它不具多态性（如果子类继承了这个函数，就不要将此函数内联，因为子类无法覆写一个根本不存在的函数）</li>
<li>找出这个函数的所有被调用点</li>
<li>将这个函数的所有被调用点都替换为函数本体</li>
<li>编译，测试</li>
<li>删除该函数的定义</li>
</ul>
<h3 id="u5185_u8054_u4E34_u65F6_u53D8_u91CF_Inline_Temp"><a href="#u5185_u8054_u4E34_u65F6_u53D8_u91CF_Inline_Temp" class="headerlink" title="内联临时变量 Inline Temp"></a>内联临时变量 Inline Temp</h3><p>你有一个临时变量，只被一个简单表示式赋值一次，而它妨碍了其他重构手法 -&gt; 将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。</p>
<ul>
<li>检查给临时变量赋值的语句，确保等号右边的表达式没有副作用</li>
<li>如果这个临时变量并未被声明为 <code>final</code>，那么就将它声明为 <code>final</code>，然后编译（这可以检查该临时变量是否真的只被赋值一次）</li>
<li>找到该临时变量的所有引用点，将它们替换为『为临时变量赋值』的表达式</li>
<li>每次修改后，编译并测试</li>
<li>修改完所有引用点之后，删除该临时变量的声明和赋值语句</li>
<li>编译，测试</li>
</ul>
<h3 id="u4EE5_u67E5_u8BE2_u53D6_u4EE3_u4E34_u65F6_u53D8_u91CF_Replace_Temp_with_Query"><a href="#u4EE5_u67E5_u8BE2_u53D6_u4EE3_u4E34_u65F6_u53D8_u91CF_Replace_Temp_with_Query" class="headerlink" title="以查询取代临时变量 Replace Temp with Query"></a>以查询取代临时变量 Replace Temp with Query</h3><p>你的程序以一个临时变量保存某一表达式的运算结果 -&gt; 将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。</p>
<ul>
<li>找出只被赋值一次的临时变量（如果某个临时变量被赋值超过一次，考虑使用 Split Temporary Variable 将它分割成多个变量）</li>
<li>将该临时变量声明为 <code>final</code></li>
<li>编译（这可确保该临时变量的确只被赋值一次）</li>
<li>将『对该临时变量赋值』的语句的等号右侧部分提炼到一个独立函数中（首先将函数声明为 private；确保提炼出来的函数无任何副作用，如果它有副作用，就对它进行 Separate Query from Modifier）</li>
<li>编译，测试</li>
<li>在该变量身上实施 Inline Temp</li>
</ul>
<h3 id="u5F15_u5165_u89E3_u91CA_u6027_u53D8_u91CF_Introduce_Explaining_Variable"><a href="#u5F15_u5165_u89E3_u91CA_u6027_u53D8_u91CF_Introduce_Explaining_Variable" class="headerlink" title="引入解释性变量 Introduce Explaining Variable"></a>引入解释性变量 Introduce Explaining Variable</h3><p>你有一个复杂的表达式 -&gt; 将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途</p>
<ul>
<li>声明一个 <code>final</code> 临时变量，将待分解之复杂表达式中的一部分动作的运算结果赋值给它</li>
<li>将表达式中的『运算结果』这一部分，替换为上述临时变量（如果被替换的这一部分在代码中重复出现，你可以每次一个，逐一替换）</li>
<li>编译测试</li>
<li>重复上述过程，处理表达式的其他部分</li>
</ul>
<h3 id="u5206_u89E3_u4E34_u65F6_u53D8_u91CF_Split_Temporary_Variable"><a href="#u5206_u89E3_u4E34_u65F6_u53D8_u91CF_Split_Temporary_Variable" class="headerlink" title="分解临时变量 Split Temporary Variable"></a>分解临时变量 Split Temporary Variable</h3><p>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果 -&gt; 针对每次赋值，创造一个独立、对应的临时变量</p>
<ul>
<li>在待分解临时变量的声明及其第一次被赋值处，修改其名称（如果稍后的赋值语句是 <code>i=i+expression</code> 形式，就意味着这是个结果搜收集变量，就不要分解。结果收集变量的做用通常是累加、字符串接合、写入流或者向集合添加元素）</li>
<li>将新的临时变量声明为 <code>final</code></li>
<li>以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让它们引用新的临时变量</li>
<li>在第二次赋值处，重新声明原先那个临时变量</li>
<li>编译，测试</li>
<li>逐次重复上述过程。每次都在声明出对临时变量改名，并修改下次赋值之前的引用点</li>
</ul>
<h3 id="u79FB_u9664_u5BF9_u53C2_u6570_u7684_u8D4B_u503C_Remove_Assignments_to_Parameters"><a href="#u79FB_u9664_u5BF9_u53C2_u6570_u7684_u8D4B_u503C_Remove_Assignments_to_Parameters" class="headerlink" title="移除对参数的赋值 Remove Assignments to Parameters"></a>移除对参数的赋值 Remove Assignments to Parameters</h3><p>代码对一个参数进行赋值 -&gt; 以一个临时变量取代该参数的位置</p>
<ul>
<li>建立一个临时变量，把待处理的参数值赋予它</li>
<li>以『对参数的赋值』为界，将其后所有对此参数的引用点，全部替换为『对此临时变量的引用』</li>
<li>修改赋值语句，使其改为对新建临时变量赋值</li>
<li>编译，测试（如果代码的语义是按引用传递的，请在调用端检查调用后是否还使用了这个参数。也要检查有多少个按引用传递的参数被赋值后又被使用。请尽量只以 return 方式返回一个值。如果需要返回的值不止一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数）</li>
</ul>
<h3 id="u4EE5_u51FD_u6570_u5BF9_u8C61_u53D6_u4EE3_u51FD_u6570_Replace_Method_with_Method_Object"><a href="#u4EE5_u51FD_u6570_u5BF9_u8C61_u53D6_u4EE3_u51FD_u6570_Replace_Method_with_Method_Object" class="headerlink" title="以函数对象取代函数 Replace Method with Method Object"></a>以函数对象取代函数 Replace Method with Method Object</h3><p>你有一个大型函数，其中对局部变量的使用使你无法采用 Extract Method -&gt; 将这个函数放进一个单独对象中，如此依赖局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数</p>
<ul>
<li>建立一个新类，根据待处理函数的用途，为这个类命名</li>
<li>在新类中建立一个 <code>final</code> 字段，用以保存原先大型函数所在的对象。我们将这个字段称为『源对象』。同时，针对原函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存</li>
<li>在新类中建立一个构造函数，接收源对象及原函数的所有参数作为参数</li>
<li>在新类中建立一个 <code>compute()</code> 函数</li>
<li>将原函数的代码复制到 <code>compute()</code> 函数中。如果需要调用源对象的任何函数，请通过源对象字段调用</li>
<li>编译</li>
<li>将旧函数的函数本体替换为这样一条语句：『创建上述新类的一个新对象，然后调用其中的 <code>compute()</code> 函数』</li>
</ul>
<h3 id="u66FF_u6362_u7B97_u6CD5_Substitute_Algorithm"><a href="#u66FF_u6362_u7B97_u6CD5_Substitute_Algorithm" class="headerlink" title="替换算法  Substitute Algorithm"></a>替换算法  Substitute Algorithm</h3><p>你想要把某个算法替换成一个更清晰的算法 -&gt; 将函数本体替换为另一个算法</p>
<ul>
<li>准备好另一个（替换用）算法，让它通过编译</li>
<li>针对现有测试，执行上述新算法。如果结果与原本相同，重构结束</li>
<li>如果测试结果不同于原先，在测试和调试过程中，以旧算法为比较参照标准（对于每个测试用例，分别以新旧两种算法执行，并观察两者结果是否相同）</li>
</ul>
<h2 id="u5728_u5BF9_u8C61_u4E4B_u95F4_u642C_u79FB_u7279_u6027"><a href="#u5728_u5BF9_u8C61_u4E4B_u95F4_u642C_u79FB_u7279_u6027" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h2><p>在对象的设计过程中，『决定把责任放在哪儿』即使不是最重要的事，也是最重要的事之一。</p>
<h3 id="u642C_u79FB_u51FD_u6570_Move_Method"><a href="#u642C_u79FB_u51FD_u6570_Move_Method" class="headerlink" title="搬移函数 Move Method"></a>搬移函数 Move Method</h3><p>你的程序中，有个函数与其所在类之外的另一个类进行更多交流：调用后者，或被后者调用 -&gt; 在该函数最常引用的类中建立一个有类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除</p>
<ul>
<li>检查源类中被源函数所使用的一切特性（包括字段和函数），考虑它们是否也该被搬迁（如果某个特性只被你打算搬移的那个函数用到，就应该将它一并搬迁。如果另有其他函数使用了这个特性，你可以考虑将使用该特性的所有函数全都一并搬迁。有时候，搬移一组函数比逐一搬移简单些）</li>
<li>检查源类的子类和超类，看看是否有该函数的其他声明（如果出现其他声明，你或许无法进行搬移，除非目标类也同样表现出多态性）</li>
<li>在目标类中声明这个函数（你可以选择一个更有意义的名称）</li>
<li>将源函数的代码复制到目标函数中。调整后者，使其能在新类中正常运行（如果源函数包含异常处理，你得判断逻辑上应该由哪个类来处理这一异常。如果应该由源类来负责，就把异常处理留在原地）</li>
<li>编译目标类</li>
<li>决定如何从源函数正确引用目标对象</li>
<li>修改源函数，使之成为一个纯委托函数</li>
<li>编译，测试</li>
<li>决定是否删除源函数，或将它当作一个委托函数保留下来（如果你经常要在源对象中引用目标函数，那么将源函数作为委托函数保留下来会比较简单）</li>
<li>如果要移除源函数，请将源类中对源函数的所有调用，替换为对目标函数的调用</li>
<li>编译，测试</li>
</ul>
<h3 id="u642C_u79FB_u5B57_u6BB5_Move_Field"><a href="#u642C_u79FB_u5B57_u6BB5_Move_Field" class="headerlink" title="搬移字段 Move Field"></a>搬移字段 Move Field</h3><p>你的程序中，某个字段被其所在类之外的另一个类更多的用到 -&gt; 在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段</p>
<ul>
<li>如果字段的访问级是 public，使用 Encapsulate Field 将它封装起来（如果你有可能移动那些频繁访问该字段的函数，或如果有许多函数访问某个字段，先使用 Self Encapsulate Field 也许会有帮助）</li>
<li>编译，测试</li>
<li>在目标类中建立与源字段相同的字段，并同时建立相应的设值/取值函数</li>
<li>编译目标类</li>
<li>决定如何在源对象中引用目标对象（首先看是否有一个现成的字段或函数可以帮助你得到目标对象，如果没有，就看能否轻易建立这样一个函数。如果还不行，就得在源类中新建一个字段来存放目标对象。这可能是个永久性修改，但你也可以让它是暂时的，因为后续重构可能会把这个新建字段除掉）</li>
<li>删除源字段</li>
<li>将所有对源字段的引用替换为对某个目标函数的调用</li>
<li>编译，测试</li>
</ul>
<h3 id="u63D0_u70BC_u7C7B_Extract_Class"><a href="#u63D0_u70BC_u7C7B_Extract_Class" class="headerlink" title="提炼类 Extract Class"></a>提炼类 Extract Class</h3><p>某个类做了应该由两个类做的事 -&gt; 建立一个新类，将相关的字段和函数从旧类搬移到新类</p>
<ul>
<li>决定如何分解类所负的责任</li>
<li>建立一个新类，用以表现从旧类中分离出来的责任（如果旧类剩下的责任与旧类名称不符，为旧类更名）</li>
<li>建立『从旧类访问新类』的连接关系（有可能需要一个双向链接。但是在真正需要它之前，不要建立『从新类通往旧类』的链接）</li>
<li>对于你想搬移的每一个字段，运用 Move Field 搬移之</li>
<li>每次搬移后，编译、测试</li>
<li>使用 Move Method 将必要函数搬移到新类，先搬移低层函数（也就是『被其他函数调用』多于『调用其他函数』的函数），再搬移较高层函数</li>
<li>每次搬移之后，编译、测试</li>
<li>检查，精简每个类的接口（如果你建立其双向链接，检查是否可以将它改为单向连接）</li>
<li>决定是否公开新类。如果你的确需要公开它，就要决定让它成为引用对象还是不可变的值对象</li>
</ul>
<p>这里也存在危险性。如果需要确保两个对象同时被锁定，你就面临事务问题，需要使用其他类型的共享锁。</p>
<h3 id="u5C06_u7C7B_u5185_u8054_u5316_Inline_Class"><a href="#u5C06_u7C7B_u5185_u8054_u5316_Inline_Class" class="headerlink" title="将类内联化 Inline Class"></a>将类内联化 Inline Class</h3><p>某个类没有做太多事情 -&gt; 将这个类的所有特性搬移到另一个类中，然后移除原类</p>
<ul>
<li>在目标类身上声明源类的 public 协议，并将其中所有函数委托至源类（如果『以一个独立接口表示源类函数』更合适的话，就应该在内联之前先使用 Extract Interface）</li>
<li>修改所有源类引用点，改而引用目标类（将源类声明为 private，以斩断包之外的所有引用可能。同时修改源类的名称，这便可使编译器帮助你捕捉到所有对于源类的隐藏引用点）</li>
<li>编译，测试</li>
<li>运用 Move Method 和 Move Field，将源类的特性全部搬移到目标类</li>
<li>为源类举行一个简单的『丧礼』</li>
</ul>
<h3 id="u9690_u85CF_u59D4_u6258_u5173_u7CFB_Hide_Delegate"><a href="#u9690_u85CF_u59D4_u6258_u5173_u7CFB_Hide_Delegate" class="headerlink" title="隐藏委托关系 Hide Delegate"></a>隐藏委托关系 Hide Delegate</h3><p>客户通过一个委托类来调用另一个对象 -&gt; 在服务类上建立客户所需的所有函数，用以隐藏委托关系</p>
<ul>
<li>对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数</li>
<li>调整客户，令它只调用服务对象提供的函数（如果使用者和服务提供者不在同一个包）</li>
<li>每次调整后，编译并测试</li>
<li>如果将来不再有任何客户需要用到 Delegate，便课移除服务对象中的相关访问函数</li>
<li>编译，测试</li>
</ul>
<h3 id="u79FB_u9664_u4E2D_u95F4_u4EBA_Remove_Middle_Man"><a href="#u79FB_u9664_u4E2D_u95F4_u4EBA_Remove_Middle_Man" class="headerlink" title="移除中间人 Remove Middle Man"></a>移除中间人 Remove Middle Man</h3><p>某个类做了过多的简单委托动作 -&gt; 让客户直接调用受托类</p>
<ul>
<li>建立一个函数，用以获得受托对象</li>
<li>对于每个委托函数，在服务类中删除该函数，并让需要调用该函数的客户转为调用受托对象</li>
<li>处理每个委托函数后，编译、测试</li>
</ul>
<h3 id="u5F15_u5165_u5916_u52A0_u51FD_u6570_Introduce_Foreign_Method"><a href="#u5F15_u5165_u5916_u52A0_u51FD_u6570_Introduce_Foreign_Method" class="headerlink" title="引入外加函数 Introduce Foreign Method"></a>引入外加函数 Introduce Foreign Method</h3><p>你需要为提供服务的类增加一个函数，但你无法修改这个类 -&gt; 在客户类中建立一个函数，并以第一参数形式传入一个服务类实例</p>
<p>外加函数终究是权宜之计。如果有可能，你仍然应该将这些函数搬移到它们的理想家园。如果由于代码所有权的原因使你无法这么做，就把外加函数交给服务类的拥有者，请他帮你在服务类中实现这个函数。</p>
<ul>
<li>在客户类中建立一个函数，用来提供你需要的功能（这个函数不应该调用客户类的任何特性。如果它需要一个值，把该值当做参数传给它）</li>
<li>以服务类实例作为该函数的第一个参数</li>
<li>将该函数注释为『外加函数(foreign method)，应该在服务类实现』（这么一来，如果将来有机会将外加函数搬移到服务类中时，你便可以轻松找出这些外加函数）</li>
</ul>
<h3 id="u5F15_u5165_u672C_u5730_u6269_u5C55_Introduce_Local_Extension"><a href="#u5F15_u5165_u672C_u5730_u6269_u5C55_Introduce_Local_Extension" class="headerlink" title="引入本地扩展 Introduce Local Extension"></a>引入本地扩展 Introduce Local Extension</h3><p>你需要为服务类提供一些额外函数，但你无法修改这个类 -&gt; 建立一个新类，使它包含这些额外函数。让这个扩展品陈伟源类的子类或包装类</p>
<ul>
<li>建立一个扩展类，将它作为原始类的子类或包装类</li>
<li>在扩展类中加入转型构造函数（所谓『转型构造函数』是指『接受原对象作为参数』的构造函数。如果采用子类化方案，那么转型构造函数应该调用适当的超类构造函数；如果采用包装类方案，那么转型构造函数应该将它得到的传入参数以实例变量的形式保存起来，用作接受委托的原对象）</li>
<li>在扩展类中加入新特性</li>
<li>根据需要，将原对象替换为扩展对象</li>
<li>将针对原始类定义的所有外加函数搬移到扩展类中</li>
</ul>
<h2 id="u91CD_u65B0_u7EC4_u7EC7_u6570_u636E"><a href="#u91CD_u65B0_u7EC4_u7EC7_u6570_u636E" class="headerlink" title="重新组织数据"></a>重新组织数据</h2><h3 id="u81EA_u5C01_u88C5_u5B57_u6BB5_Self_Encapsulate_Field"><a href="#u81EA_u5C01_u88C5_u5B57_u6BB5_Self_Encapsulate_Field" class="headerlink" title="自封装字段 Self Encapsulate Field"></a>自封装字段 Self Encapsulate Field</h3><p>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙 -&gt; 为这个字段建立取值/设值函数，并且只以这些函数来访问字段</p>
<ul>
<li>为待封装字段建立取值/设值函数</li>
<li>找出该字段的所有引用点，将它们全部改为调用取值/设值函数</li>
<li>将该字段声明为 private</li>
<li>复查，确保找出所有引用点</li>
<li>编译，测试</li>
</ul>
<h3 id="u4EE5_u5BF9_u8C61_u53D6_u4EE3_u6570_u636E_u503C_Replace_Data_Value_with_Object"><a href="#u4EE5_u5BF9_u8C61_u53D6_u4EE3_u6570_u636E_u503C_Replace_Data_Value_with_Object" class="headerlink" title="以对象取代数据值 Replace Data Value with Object"></a>以对象取代数据值 Replace Data Value with Object</h3><p>你有一个数据项 -&gt; 需要与其他数据和行为一起使用才有意义 -&gt; 将数据项变成对象</p>
<ul>
<li>为待替换数值新建一个类，在其中声明一个 final 字段，其类型和源类中的待替换数值类型一样。让后在新类中加入这个字段的取值函数，再加上一个接受此字段为参数的构造函数</li>
<li>编译</li>
<li>将源类中的待替换数值字段的类型改为前面新建的类</li>
<li>修改源类中该字段的取值函数，令它调用新类的取值函数</li>
<li>如果源类构造函数中用到这个待替换字段（多半是赋值动作），我们就修改构造函数，令它改用新类的构造函数来对字段进行赋值动作</li>
<li>修改源类中待替换字段的设值函数，令它为新类创建一个实例</li>
<li>编译，测试</li>
<li>现在，你有可能需要对新类使用 Change Value to Reference</li>
</ul>
<h3 id="u5C06_u503C_u5BF9_u8C61_u6539_u4E3A_u5F15_u7528_u5BF9_u8C61_Change_Value_to_Reference"><a href="#u5C06_u503C_u5BF9_u8C61_u6539_u4E3A_u5F15_u7528_u5BF9_u8C61_Change_Value_to_Reference" class="headerlink" title="将值对象改为引用对象 Change Value to Reference"></a>将值对象改为引用对象 Change Value to Reference</h3><p>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象 -&gt; 将这个值对象编程引用对象</p>
<ul>
<li>使用 Replace Constructor with Factory Method</li>
<li>编译，测试</li>
<li>决定由什么对象负责提供访问新对象的途径（可能是一个静态字典或一个注册表对象；也可以使用多个对象作为新对象的访问点）</li>
<li>决定这些引用对象应该预先创建号，或是应该动态创建（如果这些引用对象是预先创建号的，而你必须从内存中将它们读取出来，那么就得去报它们在被需要的时候能够被及时加载）</li>
<li>修改工厂函数，令它返回引用对象（如果对象是预先创建号的，你就需要考虑：万一有人请求一个并不存在的对象，要如何处理错误；可能希望对工厂函数使用 Rename Method，使其传达这样的信息：它返回的是一个已存在的对象）</li>
<li>编译，测试</li>
</ul>
<h3 id="u5C06_u5F15_u7528_u5BF9_u8C61_u6539_u4E3A_u503C_u5BF9_u8C61_Change_Reference_to_Value"><a href="#u5C06_u5F15_u7528_u5BF9_u8C61_u6539_u4E3A_u503C_u5BF9_u8C61_Change_Reference_to_Value" class="headerlink" title="将引用对象改为值对象 Change Reference to Value"></a>将引用对象改为值对象 Change Reference to Value</h3><p>你有一个引用对象，很小且不可变，而且不易管理 -&gt; 将它变成一个值对象</p>
<ul>
<li>检查重构目标是否为不可变对象，或是否可修改为不可变对象（如果该对象目前还不是不可变的，就使用 Removing Setting Method，直到它成为不可变的为止；如果无法将该对象修改为不可变的，就放弃使用本项重构）</li>
<li>建立 <code>equals()</code> 和 <code>hashCode()</code></li>
<li>编译，测试</li>
<li>考虑是否可以删除工厂函数，并将构造函数声明为 public</li>
</ul>
<h3 id="u4EE5_u5BF9_u8C61_u53D6_u4EE3_u6570_u7EC4_Replace_Array_with_Object"><a href="#u4EE5_u5BF9_u8C61_u53D6_u4EE3_u6570_u7EC4_Replace_Array_with_Object" class="headerlink" title="以对象取代数组 Replace Array with Object"></a>以对象取代数组 Replace Array with Object</h3><p>你有一个数组，其中的元素各自代表不同的东西 -&gt; 以对象替换数组。对于数组中的每个元素，以一个字段来表示</p>
<ul>
<li>新建一个类表示数组所拥有的信息，并在其中以一个 public 字段保存原先的数组</li>
<li>修改数组的所有用户，让它们改用新类的实例</li>
<li>编译，测试</li>
<li>逐一为数组元素添加取值/设值函数。根据元素的用途，为这些访问函数命名。修改客户代码，让它们动过访问函数取用数组内的元素。每次修改后，编译并测试</li>
<li>当所有对数组的直接访问都转而调用访问函数后，将新类中保存该数组的字段声明为 private</li>
<li>编译</li>
<li>对于数组内的每一个元素，在新类中创建一个类型相当的字段。修改该元素的访问函数，令它改用上述的新建字段</li>
<li>每修改一个元素，编译并测试</li>
<li>数组的所有元素都有了相应字段之后，删除该数组</li>
</ul>
<h3 id="u590D_u5236_u300E_u88AB_u76D1_u89C6_u7684_u6570_u636E_u300F_Duplicate_Observed_Data"><a href="#u590D_u5236_u300E_u88AB_u76D1_u89C6_u7684_u6570_u636E_u300F_Duplicate_Observed_Data" class="headerlink" title="复制『被监视的数据』 Duplicate Observed Data"></a>复制『被监视的数据』 Duplicate Observed Data</h3><p>你有一些领域数据置身于 GUI 控件中，而领域函数需要访问这些数据 -&gt; 将该数据复制到一个领域对象中。建立一个 Observer 模式，用以同步领域对象和 GUI 对象内的重复数据</p>
<ul>
<li>修改展现类，使其成为领域类的 Observer[GOF]（如果尚未有领域类，就建立一个；如果没有『从展现类到领域类』的关联，就将领域类保存与展现类的一个字段中）</li>
<li>针对 GUI 类中的领域数据，使用 Self Encapsulate Field</li>
<li>编译，测试</li>
<li>在事件处理函数中调用设值函数，直接更新 GUI 组件</li>
<li>编译，测试</li>
<li>在领域类中定义数据及其相关访问函数（确保领域类中的设值函数能够触发 Observer 模式的通报机制；对于被观察的数据，在领域类中使用与展现类所用的相同类型来保存。后续重构中你可以自由改变这个数据类型）</li>
<li>修改展现类中的访问函数，将它们的操作对象改为领域对象（而非 GUI 组件）</li>
<li>修改 Observer 的 <code>update()</code>，使其从相应的领域对象中将所需数据复制给 GUI 组件</li>
<li>编译，测试</li>
</ul>
<h3 id="u5C06_u5355_u5411_u5173_u8054_u6539_u4E3A_u53CC_u5411_u5173_u8054_Change_Unidirectional_Association_to_Bidirectional"><a href="#u5C06_u5355_u5411_u5173_u8054_u6539_u4E3A_u53CC_u5411_u5173_u8054_Change_Unidirectional_Association_to_Bidirectional" class="headerlink" title="将单向关联改为双向关联 Change Unidirectional Association to Bidirectional"></a>将单向关联改为双向关联 Change Unidirectional Association to Bidirectional</h3><p>两个类都需要使用对方特性，但期间只有一条单向连接 -&gt; 添加一个反向指针，并使修改函数能够同时更新两条连接</p>
<ul>
<li>在被引用类中增加一个字段，用以保存反向指针</li>
<li>决定由哪个类——引用端还是被引用端——控制关联关系</li>
<li>在被控端建立一个辅助函数，其命名应该清楚指出它的有限用途</li>
<li>如果既有的修改函数在控制端，让它负责更新方向指针</li>
<li>如果既有的修改函数在被控端，就在控制端建立一个控制函数，并让既有的修改函数调用这个新建的控制函数</li>
</ul>
<h3 id="u5C06_u53CC_u5411_u5173_u8054_u6539_u4E3A_u5355_u5411_u5173_u8054_Change_Bidirectional_Association_to_Unidirectional"><a href="#u5C06_u53CC_u5411_u5173_u8054_u6539_u4E3A_u5355_u5411_u5173_u8054_Change_Bidirectional_Association_to_Unidirectional" class="headerlink" title="将双向关联改为单向关联 Change Bidirectional Association to Unidirectional"></a>将双向关联改为单向关联 Change Bidirectional Association to Unidirectional</h3><p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性 -&gt; 去除不必要的关联</p>
<p>双向关联很有用，但是也必须为它付出代价，那就是维护双向连接、确保对象被正确创建和删除增加的复杂度。而且，由于很多程序员并不习惯使用双向关联，它往往成为错误之源。大量的双向连接也很容易造成『僵尸对象』：某个对象本来已经该死亡了，却仍然保留在系统中，因为对它的引用还没有完全清除。</p>
<ul>
<li>找出保存『你想去除的指针』的字段，检查它的每一个用户，判断是否可以去除该指针（不但要检查直接访问点，也要检查调用这些直接访问点的函数）</li>
<li>如果客户使用了取值函数，先运用 Self Encapsulate Field 将待删除字段自我封装起来，然后使用 Substitute Algorithm 对付取值函数，令它不再使用该字段。然后编译、测试</li>
<li>如果客户并未使用取值函数，那就直接修改待删除字段的所有被引用点：改以其他途径获得该字段所保存的对象。每次修改后，编译并测试</li>
<li>如果已经没有任何函数使用待删除字段，移除所有对该字段的更新逻辑，然后移除该字段</li>
<li>编译，测试</li>
</ul>
<h3 id="u4EE5_u5B57_u9762_u5E38_u91CF_u53D6_u4EE3_u9B54_u6CD5_u6570_Replace_Magic_Number_with_Symbolic_Constant"><a href="#u4EE5_u5B57_u9762_u5E38_u91CF_u53D6_u4EE3_u9B54_u6CD5_u6570_Replace_Magic_Number_with_Symbolic_Constant" class="headerlink" title="以字面常量取代魔法数 Replace Magic Number with Symbolic Constant"></a>以字面常量取代魔法数 Replace Magic Number with Symbolic Constant</h3><p>你有一个字面数值，带有特别含义 -&gt; 创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量</p>
<ul>
<li>声明一个常量，令其值为原本的魔法数值</li>
<li>找出这个魔法数的所有引用点</li>
<li>检查是否可以使用这个新声明的常量来替换该魔法数。如果可以，便以此常量替换之</li>
<li>编译</li>
<li>所有魔法数都被替换完毕后，编译并测试。此时整个程序应该运转如常</li>
</ul>
<h3 id="u5C01_u88C5_u5B57_u6BB5_Encapsulate_Field"><a href="#u5C01_u88C5_u5B57_u6BB5_Encapsulate_Field" class="headerlink" title="封装字段 Encapsulate Field"></a>封装字段 Encapsulate Field</h3><p>你的类中存在一个 public 字段 -&gt; 将它声明为 private，并提供相应的访问函数</p>
<ul>
<li>为 Public 字段提供取值/设值函数</li>
<li>找到这个类以外使用该字段的所有地点。用取值/设置函数进行替代</li>
<li>每次修改之后，编译并测试</li>
<li>将字段的所有用户修改完毕后，把字段声明为 private</li>
<li>编译，测试</li>
</ul>
<h3 id="u5C01_u88C5_u96C6_u5408_Encapsulate_Collection"><a href="#u5C01_u88C5_u96C6_u5408_Encapsulate_Collection" class="headerlink" title="封装集合 Encapsulate Collection"></a>封装集合 Encapsulate Collection</h3><p>有个函数返回一个集合 -&gt; 让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数（类似 MVC 的 M）</p>
<ul>
<li>加入为集合添加/移除元素的函数</li>
<li>将保存集合的字段初始化为一个空集合</li>
<li>编译</li>
<li>找出集合设值函数的所有调用者。你可以修改那个设值函数，让它使用上述新建立的『添加/移除元素』函数；也可以直接修改调用端，改让它们调用上述新建立的『添加/移除元素』函数</li>
<li>编译，测试</li>
<li>找出所有『通过取值函数获得集合并修改其内容』的函数。逐一修改这些函数，让它们改用添加/移除函数。每次修改后，编译并测试</li>
<li>修改完上述所有『通过取值函数获得集合并修改集合内容』的函数后，修改取值函数自身，使它返回该集合的一个只读副本</li>
<li>编译，测试</li>
<li>找出取值函数的所有用户，从中找出应该存在于集合所属对象内的代码。运用 Extract Method 和 Move Method 将这些代码移到宿主对象去</li>
<li>修改现有取值函数的名字，然后添加一个新取值函数，使其返回一个枚举。找出旧取值函数的所有被实用点，将它们都改为使用新取值函数</li>
<li>如果这一步跨度太大，可以先使用 Rename Method 修改原取值函数的名称；再建立一个新取值函数用以返回枚举；最后再修改所有调用者，使其调用新取值函数</li>
<li>编译，测试</li>
</ul>
<h3 id="u4EE5_u6570_u636E_u7C7B_u53D6_u4EE3_u8BB0_u5F55_Replace_Record_with_Data_Class"><a href="#u4EE5_u6570_u636E_u7C7B_u53D6_u4EE3_u8BB0_u5F55_Replace_Record_with_Data_Class" class="headerlink" title="以数据类取代记录 Replace Record with Data Class"></a>以数据类取代记录 Replace Record with Data Class</h3><p>你需要面对传统编程环境中的记录结构 -&gt; 为该记录创建一个『哑』数据对象</p>
<ul>
<li>新建一个类，表示这个记录</li>
<li>对于记录中的每一项数据，在新建的类中建立对应的一个 private 字段，并提供相应的取值/设值函数</li>
</ul>
<h3 id="u4EE5_u7C7B_u53D6_u4EE3_u7C7B_u578B_u7801_Replace_Type_Code_with_Class"><a href="#u4EE5_u7C7B_u53D6_u4EE3_u7C7B_u578B_u7801_Replace_Type_Code_with_Class" class="headerlink" title="以类取代类型码 Replace Type Code with Class"></a>以类取代类型码 Replace Type Code with Class</h3><ul>
<li>为类型码建立一个类</li>
<li>修改源类的实现，让它使用上述新建的类</li>
<li>编译，测试</li>
<li>对于源类中每一个使用类型码的函数，相应建立一个函数，让新函数使用新建的类</li>
<li>逐一修改源类用户，让它们使用新接口</li>
<li>每修改一个用户，编译并测试</li>
<li>删除使用类型码的旧接口，并删除保存旧类型码的静态变量</li>
<li>编译，测试</li>
</ul>
<h3 id="u4EE5_u5B50_u7C7B_u53D6_u4EE3_u7C7B_u578B_u7801_Replace_Type_Code_with_Subclasses"><a href="#u4EE5_u5B50_u7C7B_u53D6_u4EE3_u7C7B_u578B_u7801_Replace_Type_Code_with_Subclasses" class="headerlink" title="以子类取代类型码 Replace Type Code with Subclasses"></a>以子类取代类型码 Replace Type Code with Subclasses</h3><p>你有一个不可变的类型码，它会影响类的行为 -&gt; 以子类取代这个类型码</p>
<ul>
<li>使用 Self Encapsulate Field 将类型码自我封装起来（如果类型码被传递给构造函数，就需要将构造函数换成工厂函数）</li>
<li>为类型码的每一个数值建立一个相应的子类。在每个子类中覆写类型码的取值函数，使其返回相应的类型码值</li>
<li>每建立一个新的子类，编译并测试</li>
<li>从超类中删掉保存类型码的字段。将类型码访问函数声明为抽象函数</li>
<li>编译，测试</li>
</ul>
<h3 id="u4EE5_State/Strategy__u53D6_u4EE3_u7C7B_u578B_u7801_Replace_Type_Code_with_State/Strategy"><a href="#u4EE5_State/Strategy__u53D6_u4EE3_u7C7B_u578B_u7801_Replace_Type_Code_with_State/Strategy" class="headerlink" title="以 State/Strategy 取代类型码 Replace Type Code with State/Strategy"></a>以 State/Strategy 取代类型码 Replace Type Code with State/Strategy</h3><p>你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它</p>
<ul>
<li>使用 Self Encapsulate Field 将类型码自我封装起来</li>
<li>新建一个类，根据类型码的用途为它命名。这就是一个状态对象</li>
<li>为这个新类添加子类，每个子类对应一种类型码</li>
<li>在超类中建立一个抽象的查询函数，用以返回类型码。在每个子类中覆写该函数，返回确切的类型码</li>
<li>编译</li>
<li>在源类中建立一个字段，用以保存新建的状态对象</li>
<li>调整源类中负责查询类型码的函数，将查询动作转发给状态对象</li>
<li>调整源类中为类型码设值的函数，将一个恰当的状态对象子类赋值给『保存状态对象』的那个字段</li>
<li>编译，测试</li>
</ul>
<h3 id="u4EE5_u5B57_u6BB5_u53D6_u4EE3_u5B50_u7C7B_Replace_Subclass_with_Fields"><a href="#u4EE5_u5B57_u6BB5_u53D6_u4EE3_u5B50_u7C7B_Replace_Subclass_with_Fields" class="headerlink" title="以字段取代子类 Replace Subclass with Fields"></a>以字段取代子类 Replace Subclass with Fields</h3><p>你的各个子类的唯一差别只在『返回常量数据』的函数身上 -&gt; 修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类</p>
<ul>
<li>对所有子类使用 Replace Constructor with Factory Method</li>
<li>如果有任何代码直接引用子类，令它改而引用超类</li>
<li>针对每个常量函数，在超类中声明一个 final 字段</li>
<li>为超类声明一个 protected 构造函数，用以初始化这些新增字段</li>
<li>新建或修改子类构造函数，使他调用超类的新增构造函数</li>
<li>编译，测试</li>
<li>在超类中实现所有的常量函数，令它们返回相应字段值，然后将该函数从子类中删掉</li>
<li>每删除一个常量函数，编译并测试</li>
<li>子类中所有的常量函数都被删除后，使用 Inline Method 将子类构造函数内联到超类的工厂函数中</li>
<li>编译，测试</li>
<li>将子类删掉</li>
<li>编译，测试</li>
<li>重复『内联构造函数、删除子类』过程，直到所有子类都被删除</li>
</ul>
<h2 id="u7B80_u5316_u6761_u4EF6_u8868_u8FBE_u5F0F"><a href="#u7B80_u5316_u6761_u4EF6_u8868_u8FBE_u5F0F" class="headerlink" title="简化条件表达式"></a>简化条件表达式</h2><p>相比于面向过程程序，免息那个对象程序的条件表达式通常比较少，这是因为很多条件行为都被多态机制处理掉了。多态还有一种十分有用但鲜为人知的用途：通过  Introduce Null Object 去除对于 null 值的检验。</p>
<h3 id="u5206_u89E3_u6761_u4EF6_u8868_u8FBE_u5F0F_Decompose_Conditional"><a href="#u5206_u89E3_u6761_u4EF6_u8868_u8FBE_u5F0F_Decompose_Conditional" class="headerlink" title="分解条件表达式 Decompose Conditional"></a>分解条件表达式 Decompose Conditional</h3><p>你有一个复杂的条件(if-then-else)语句 -&gt; 从 if, then, else 三个段落中分别提炼出独立函数</p>
<ul>
<li>将 if 段落提炼出来，构成一个独立函数</li>
<li>将 then 段落和 else 段落都提炼出来，各自构成一个独立函数</li>
</ul>
<h3 id="u5408_u5E76_u6761_u4EF6_u8868_u8FBE_u5F0F_Consolidate_Conditional_Expression"><a href="#u5408_u5E76_u6761_u4EF6_u8868_u8FBE_u5F0F_Consolidate_Conditional_Expression" class="headerlink" title="合并条件表达式 Consolidate Conditional Expression"></a>合并条件表达式 Consolidate Conditional Expression</h3><p>你有一系列条件测试，都得到相同结果 -&gt; 将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数</p>
<ul>
<li>确定这些条件语句都没有副作用（如果条件表达式有副作用，你就不能使用本项重构）</li>
<li>使用适当的逻辑操作符，将一系列相关条件表达式合并为一个</li>
<li>编译，测试</li>
<li>对合并后的表达式实施 Extract Method</li>
</ul>
<h3 id="u5408_u5E76_u91CD_u590D_u7684_u6761_u4EF6_u7247_u6BB5_Consolidate_Duplicate_Conditional_Fragments"><a href="#u5408_u5E76_u91CD_u590D_u7684_u6761_u4EF6_u7247_u6BB5_Consolidate_Duplicate_Conditional_Fragments" class="headerlink" title="合并重复的条件片段 Consolidate Duplicate Conditional Fragments"></a>合并重复的条件片段 Consolidate Duplicate Conditional Fragments</h3><p>在条件表达式的每个分支上有着相同的一段代码 -&gt; 将折断代码搬移到条件表达式之外</p>
<ul>
<li>鉴别出『执行方式不随条件变化而变化』的代码</li>
<li>如果这些共通代码位于条件表达式起始处，就将它移到条件表达式之前</li>
<li>如果这些共通代码位于条件表达式尾端，就将它移到条件表达式之后</li>
<li>如果这些共同代码位于条件表达式中段，就需要观察来向前或向后移动</li>
<li>如果共通代码不止一条语句，应该先使用 Extract Method 将共通代码提炼到一个独立函数中，再以前面所说的办法来处理</li>
</ul>
<h3 id="u79FB_u9664_u63A7_u5236_u6807_u8BB0_Remove_Control_Flag"><a href="#u79FB_u9664_u63A7_u5236_u6807_u8BB0_Remove_Control_Flag" class="headerlink" title="移除控制标记 Remove Control Flag"></a>移除控制标记 Remove Control Flag</h3><p>在一系列布尔表达式中，某个变量带有『控制标记(control flag)』的作用 -&gt; 以 break 语句或 return 语句取代控制标记</p>
<ul>
<li>找出让你跳出这段逻辑的控制标记值</li>
<li>找出对标记变量赋值的语句，代以恰当的 break 语句或 continue 语句</li>
<li>每次替换后，编译并测试</li>
</ul>
<p>在未能提供 break 和 continue 语句的编程语言中，可以使用下述办法</p>
<ul>
<li>运用 Extract Method，将整段逻辑提炼到一个独立函数中</li>
<li>找出让你跳出这段逻辑的控制标记值</li>
<li>找出对标记变量赋值的语句，代以恰当的 return 语句</li>
<li>每次替换后，编译并测试</li>
</ul>
<h3 id="u4EE5_Guard__u8BED_u53E5_u53D6_u4EE3_u5D4C_u5957_u6761_u4EF6_u8868_u8FBE_u5F0F_Replace_Nested_Conditional_with_Guard_Clauses"><a href="#u4EE5_Guard__u8BED_u53E5_u53D6_u4EE3_u5D4C_u5957_u6761_u4EF6_u8868_u8FBE_u5F0F_Replace_Nested_Conditional_with_Guard_Clauses" class="headerlink" title="以 Guard 语句取代嵌套条件表达式 Replace Nested Conditional with Guard Clauses"></a>以 Guard 语句取代嵌套条件表达式 Replace Nested Conditional with Guard Clauses</h3><p>函数中的条件逻辑使人难以看清正常的执行路径 -&gt; 使用 Guard 语句表现所有特殊情况</p>
<ul>
<li>对于每个检查，放进一个 Guard 语句（要么从函数中返回，要么抛出一个异常）</li>
<li>每次将条件检查替换成 Guard 语句后，编译并测试（如果所有 Guard 语句都导致相同结果，请使用 Consolidate Conditional Expressions）</li>
</ul>
<h3 id="u4EE5_u591A_u6001_u53D6_u4EE3_u6761_u4EF6_u8868_u8FBE_u5F0F_Replace_Conditional_with_Polymorphism"><a href="#u4EE5_u591A_u6001_u53D6_u4EE3_u6761_u4EF6_u8868_u8FBE_u5F0F_Replace_Conditional_with_Polymorphism" class="headerlink" title="以多态取代条件表达式 Replace Conditional with Polymorphism"></a>以多态取代条件表达式 Replace Conditional with Polymorphism</h3><p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为 -&gt; 将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数</p>
<ul>
<li>如果要处理的表达式是一个更大函数中的一部分，首先对条件表达式进行分析，然后使用 Extract Method 将它提炼到一个独立函数去</li>
<li>如果有必要，使用 Move Method 将条件表达式放置到继承结构的顶端</li>
<li>任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新建函数中，并对它进行适当调整</li>
<li>编译，测试</li>
<li>在超类中删掉条件表达式内被复制了的分支</li>
<li>编译，测试</li>
<li>针对条件表达式的每个分支，重复上述过程，直到所有分支都被移到子类内的函数为止</li>
<li>将超类之中容纳条件表达式的函数声明为抽象函数</li>
</ul>
<h3 id="u5F15_u5165_Null__u5BF9_u8C61"><a href="#u5F15_u5165_Null__u5BF9_u8C61" class="headerlink" title="引入 Null 对象"></a>引入 Null 对象</h3><p>你需要再三检查某对象是否为 null -&gt; 将 null 值替换为 null 对象</p>
<ul>
<li>为源类建立一个子类，使其行为就像是源类的 null 版本。在源类和 null 子类中都加上 <code>isNull()</code> 函数，前者的 <code>isNull()</code> 应该返回 false，后者的返回 true</li>
<li>编译</li>
<li>找出所有『请求源对象却获得一个 null』 的地方，修改这些地方，使它们改而获得一个空对象</li>
<li>找出所有『将源对象与 null 做比较的地方』，修改这些地方，使它们调用 <code>isNull()</code> 函数</li>
<li>编译，测试</li>
<li>找出这样的程序点：如果对象不是 null，做 A 动作，否则做 B 动作</li>
<li>对于每一个上述抵挡，在 null 类中覆写 A 动作，使其行为和 B 动作相同</li>
<li>使用上述被覆写的动作，然后删除『对象是否等于 null』 的条件测试。编译并测试</li>
</ul>
<h3 id="u5F15_u5165_u65AD_u8A00_Introduce_Assertion"><a href="#u5F15_u5165_u65AD_u8A00_Introduce_Assertion" class="headerlink" title="引入断言 Introduce Assertion"></a>引入断言 Introduce Assertion</h3><p>某一段代码需要对程序状态做出某种假设 -&gt; 以断言明确表现出这种假设</p>
<ul>
<li>如果你发现代码假设某个条件始终为真，就加入一个断言明确说明这种情况</li>
</ul>
<h2 id="u7B80_u5316_u51FD_u6570_u8C03_u7528"><a href="#u7B80_u5316_u51FD_u6570_u8C03_u7528" class="headerlink" title="简化函数调用"></a>简化函数调用</h2><p>容易被理解和被使用的接口，是开发良好面向对象软件的关键。良好的接口只像用户展现必须展现的东西。如果一个接口暴露了过多细节，你可以将不必要暴露的东西隐藏起来，从而改进接口的质量。</p>
<h3 id="u51FD_u6570_u6539_u540D_Rename_Method"><a href="#u51FD_u6570_u6539_u540D_Rename_Method" class="headerlink" title="函数改名 Rename Method"></a>函数改名 Rename Method</h3><p>函数名称未能揭示函数的用途 -&gt; 修改函数名称</p>
<ul>
<li>检查函数签名是否被超类或子类实现过。如果是，则需要针对每份实现分别进行下列步骤</li>
<li>声明一个新函数，将它命名为你想要的新名称。将旧函数的代码复制到新函数中，并进行适当调整</li>
<li>编译</li>
<li>修改旧函数，令它将调用转发给新函数</li>
<li>编译，测试</li>
<li>找出旧函数的所有被引用点，修改它们，令它们改而引用心函数。每次修改后，编译并测试</li>
<li>删除旧函数</li>
<li>编译，测试</li>
</ul>
<h3 id="u6DFB_u52A0_u53C2_u6570_Add_Parameter"><a href="#u6DFB_u52A0_u53C2_u6570_Add_Parameter" class="headerlink" title="添加参数 Add Parameter"></a>添加参数 Add Parameter</h3><p>某个函数需要从调用端得到更多信息 -&gt; 为此函数添加一个对象函数，让该对象带进函数所需信息</p>
<ul>
<li>检查函数签名是否被超类或子类实现过。如果是，则需要针对每份实现分别进行下列步骤</li>
<li>声明一个新函数，名称与原函数同，只是加上新添参数，将旧代码复制到新函数中</li>
<li>编译</li>
<li>修改旧函数，令它调用新函数</li>
<li>编译，测试</li>
<li>找出旧函数的所有被引用点，修改它们，令它们改而引用心函数。每次修改后，编译并测试</li>
<li>删除旧函数</li>
<li>编译，测试</li>
</ul>
<h3 id="u79FB_u9664_u53C2_u6570_Remove_Parameter"><a href="#u79FB_u9664_u53C2_u6570_Remove_Parameter" class="headerlink" title="移除参数 Remove Parameter"></a>移除参数 Remove Parameter</h3><p>函数本体不再需要某个参数 -&gt; 将该参数去除</p>
<ul>
<li>检查函数签名是否被超类或子类实现过。如果是，则需要针对每份实现分别进行下列步骤</li>
<li>声明一个新函数，名称与原函数同，只是去除新添参数，将旧代码复制到新函数中</li>
<li>编译</li>
<li>修改旧函数，令它调用新函数</li>
<li>编译，测试</li>
<li>找出旧函数的所有被引用点，修改它们，令它们改而引用心函数。每次修改后，编译并测试</li>
<li>删除旧函数</li>
<li>编译，测试</li>
</ul>
<h3 id="u5C06_u67E5_u8BE2_u51FD_u6570_u548C_u4FEE_u6539_u51FD_u6570_u5206_u88C2_Separate_Query_from_Modifier"><a href="#u5C06_u67E5_u8BE2_u51FD_u6570_u548C_u4FEE_u6539_u51FD_u6570_u5206_u88C2_Separate_Query_from_Modifier" class="headerlink" title="将查询函数和修改函数分裂 Separate Query from Modifier"></a>将查询函数和修改函数分裂 Separate Query from Modifier</h3><p>某个函数既返回对象状态值，又修改对象状态 -&gt; 建立两个不同的函数，其中一个负责查询，另一个负责修改</p>
<ul>
<li>新建一个查询函数，令它返回的值与原函数相同</li>
<li>修改原函数，令它调用查询函数，并返回获得的结果</li>
<li>编译，测试</li>
<li>将调用原函数的代码改为调用查询函数。然后在调用查询函数的那一行之前，加上对原函数的调用。每次修改后，编译并测试</li>
<li>将原函数的返回值改为 void，并且删掉其中所有的 return 语句</li>
</ul>
<h3 id="u4EE4_u51FD_u6570_u643A_u5E26_u53C2_u6570_Parameterized_Method"><a href="#u4EE4_u51FD_u6570_u643A_u5E26_u53C2_u6570_Parameterized_Method" class="headerlink" title="令函数携带参数 Parameterized Method"></a>令函数携带参数 Parameterized Method</h3><p>若干函数做了类似的工作，但在函数本体中却包含了不同的值 -&gt; 建立单一函数，以参数表达那些不同的值</p>
<ul>
<li>新建一个带有参数的函数，使他可以先替换先前所有的重复性函数</li>
<li>编译</li>
<li>将调用旧函数的代码改为调用新函数</li>
<li>编译，测试</li>
<li>对所有旧函数重复上述步骤，每次替换后，修改并测试</li>
</ul>
<h3 id="u4EE5_u660E_u786E_u51FD_u6570_u53D6_u4EE3_u53C2_u6570_Replace_Parameter_with_Explicit_Methods"><a href="#u4EE5_u660E_u786E_u51FD_u6570_u53D6_u4EE3_u53C2_u6570_Replace_Parameter_with_Explicit_Methods" class="headerlink" title="以明确函数取代参数 Replace Parameter with Explicit Methods"></a>以明确函数取代参数 Replace Parameter with Explicit Methods</h3><p>你有一个函数，其中完全取决于参数值而采取不同行为 -&gt; 应该针对该参数的每一个可能值，建立一个独立函数</p>
<ul>
<li>针对参数的每一种可能值，新建一个明确函数</li>
<li>修改条件表达式的每个分支，使其调用合适的新函数</li>
<li>修改每个分支后，编译并测试</li>
<li>修改原函数的每一个被调用点，改而调用上述的某个合适的新函数</li>
<li>编译，测试</li>
<li>所有调用端都修改完毕后，删除原函数</li>
</ul>
<h3 id="u4FDD_u6301_u5BF9_u8C61_u5B8C_u6574_Preserve_Whole_Object"><a href="#u4FDD_u6301_u5BF9_u8C61_u5B8C_u6574_Preserve_Whole_Object" class="headerlink" title="保持对象完整 Preserve Whole Object"></a>保持对象完整 Preserve Whole Object</h3><p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数 -&gt; 改为传递整个对象</p>
<ul>
<li>对你的目标函数新添一个参数项，用以代表原数据所在的完整对象</li>
<li>编译，测试</li>
<li>判断哪些参数可被包含在新添的完整对象中</li>
<li>选择上述参数之一，将被调用函数中原来引用该参数的地方，改为调用新添参数对象的相应取值函数</li>
<li>删除该项参数</li>
<li>编译，测试</li>
<li>针对所有可从完整对象中获得的参数，重复上述过程</li>
<li>删除调用端中那些带有被删除参数的代码</li>
<li>编译，测试</li>
</ul>
<h3 id="u4EE5_u51FD_u6570_u53D6_u4EE3_u53C2_u6570_Replace_Parameter_with_Method"><a href="#u4EE5_u51FD_u6570_u53D6_u4EE3_u53C2_u6570_Replace_Parameter_with_Method" class="headerlink" title="以函数取代参数 Replace Parameter with Method"></a>以函数取代参数 Replace Parameter with Method</h3><p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数 -&gt; 让参数接受者去除该项参数，并直接调用前一个函数</p>
<ul>
<li>如果有必要，将参数的计算过程提炼到一个独立函数中。将函数本体内引用该参数的地方改为调用新建的函数</li>
<li>每次替换后，修改并测试</li>
<li>全部替换完成后，使用 Remove Parameter 将该参数去掉</li>
</ul>
<h3 id="u5F15_u5165_u53C2_u6570_u5BF9_u8C61_Introduce_Parameter_Object"><a href="#u5F15_u5165_u53C2_u6570_u5BF9_u8C61_Introduce_Parameter_Object" class="headerlink" title="引入参数对象 Introduce Parameter Object"></a>引入参数对象 Introduce Parameter Object</h3><p>某些参数总是很自然地同时出现 -&gt; 以一个对象取代这些参数</p>
<ul>
<li>新建一个类，用以表现你想替换的一组参数。将这个类设为不可变的</li>
<li>编译</li>
<li>针对使用该组参数的所有函数，实施 Add Parameter，传入上述新建类的实例对象，并将次参数设为 null</li>
<li>对于 Data Clumps 中的每一项（在此均为参数），从函数签名中移除，并修改调用端和函数本体，令它们都改而通过新的参数对象取得该值</li>
<li>每去除一个参数，编译并测试</li>
<li>将原先的参数全部去除之后，观察有无适当函数可以运行 Move Method 搬移到参数对象之中</li>
</ul>
<h3 id="u79FB_u9664_u8BBE_u503C_u51FD_u6570_Remove_Setting_Method"><a href="#u79FB_u9664_u8BBE_u503C_u51FD_u6570_Remove_Setting_Method" class="headerlink" title="移除设值函数 Remove Setting Method"></a>移除设值函数 Remove Setting Method</h3><p>类中的某个字段应该在对象创建时被设值，然后就不再改变 -&gt; 去掉该字段的所有设值函数</p>
<ul>
<li>检查设值函数被使用的情况，看它是否只被构造函数调用，或者被构造函数所调用的另一个函数调用</li>
<li>修改构造函数，使其直接访问设值函数所针对的那个变量</li>
<li>编译，测试</li>
<li>移除这个设值函数，将它所针对的字段设为 final</li>
<li>编译，测试</li>
</ul>
<h3 id="u9690_u85CF_u51FD_u6570_Hide_Method"><a href="#u9690_u85CF_u51FD_u6570_Hide_Method" class="headerlink" title="隐藏函数 Hide Method"></a>隐藏函数 Hide Method</h3><p>有一个函数，从来没有被其他任何类用到 -&gt; 将这个函数修改为 private</p>
<ul>
<li>经常检查有没有可能降低某个函数的可见度</li>
<li>尽可能降低所有函数的可见度</li>
<li>每完成一组函数的隐藏之后，编译并测试</li>
</ul>
<h3 id="u4EE5_u5DE5_u5382_u51FD_u6570_u53D6_u4EE3_u6784_u9020_u51FD_u6570_Replace_Constructor_with_Factory_Method"><a href="#u4EE5_u5DE5_u5382_u51FD_u6570_u53D6_u4EE3_u6784_u9020_u51FD_u6570_Replace_Constructor_with_Factory_Method" class="headerlink" title="以工厂函数取代构造函数 Replace Constructor with Factory Method"></a>以工厂函数取代构造函数 Replace Constructor with Factory Method</h3><p>你希望在创建对象时不仅仅是做简单的构建动作 -&gt; 将构造函数替换为工厂函数</p>
<ul>
<li>新建一个工厂函数，让它调用现有的构造函数</li>
<li>将调用构造函数的代码改为调用工厂函数</li>
<li>每次替换后，编译并测试</li>
<li>将构造函数声明为 private</li>
<li>编译</li>
</ul>
<h3 id="u5C01_u88C5_u5411_u4E0B_u8F6C_u578B_Encapsulate_Downcast"><a href="#u5C01_u88C5_u5411_u4E0B_u8F6C_u578B_Encapsulate_Downcast" class="headerlink" title="封装向下转型 Encapsulate Downcast"></a>封装向下转型 Encapsulate Downcast</h3><p>某个函数返回的对象，需要由函数调用者执行向下转型(downcast)</p>
<ul>
<li>找出必须对函数调用结果进行向下转型的地方（这种情况通常出现在返回一个集合或迭代器的函数中）</li>
<li>将向下转型动作搬移到该函数中（针对返回集合的函数，使用 Encapsulate Collection）</li>
</ul>
<h3 id="u4EE5_u5F02_u5E38_u53D6_u4EE3_u9519_u8BEF_u7801_Replace_Error_Code_with_Exception"><a href="#u4EE5_u5F02_u5E38_u53D6_u4EE3_u9519_u8BEF_u7801_Replace_Error_Code_with_Exception" class="headerlink" title="以异常取代错误码 Replace Error Code with Exception"></a>以异常取代错误码 Replace Error Code with Exception</h3><p>某个函数返回一个特定的代码，用以表示各种错误情况 -&gt; 改用异常</p>
<ul>
<li>决定应该抛出受控(checked)异常还是非受控(unchecked)异常</li>
<li>找到该函数的所有者，对它们进行相应调整，让他们使用异常</li>
<li>修改该函数的签名，令它反映出新用法</li>
</ul>
<h3 id="u4EE5_u6D4B_u8BD5_u53D6_u4EE3_u5F02_u5E38_Replace_Exception_with_Test"><a href="#u4EE5_u6D4B_u8BD5_u53D6_u4EE3_u5F02_u5E38_Replace_Exception_with_Test" class="headerlink" title="以测试取代异常 Replace Exception with Test"></a>以测试取代异常 Replace Exception with Test</h3><p>面对一个调用者可以预先检查的条件，你抛出了一个异常 -&gt; 修改调用者，使它在调用函数之前先做检查</p>
<ul>
<li>在函数调用点之前，放置一个测试语句，将函数内 catch 区段中的代码复制到测试句的适当 if 分支中</li>
<li>在 catch 区段起始处加入一个断言，确保 catch 区段绝对不会被执行</li>
<li>编译，测试</li>
<li>移除所有 catch 区段，让后将 try 区段内的代码复制到 try 之外，然后移除 try 区段</li>
<li>编译，测试</li>
</ul>
<h2 id="u5904_u7406_u6982_u62EC_u5173_u7CFB"><a href="#u5904_u7406_u6982_u62EC_u5173_u7CFB" class="headerlink" title="处理概括关系"></a>处理概括关系</h2><h3 id="u5B57_u6BB5_u4E0A_u79FB_Pull_Up_Field"><a href="#u5B57_u6BB5_u4E0A_u79FB_Pull_Up_Field" class="headerlink" title="字段上移 Pull Up Field"></a>字段上移 Pull Up Field</h3><p>两个子类拥有相同的字段 -&gt; 将该字段移至超类</p>
<ul>
<li>针对提升字段，检查它们所有被使用点，确认它们以同样的方式被使用</li>
<li>如果这些字段的名称不同，先将它们改名，使每一个名称都和你想为超类字段取的名称相同</li>
<li>编译，测试</li>
<li>在超类中新建一个字段（声明为 protected）</li>
<li>移除子类中的字段</li>
<li>编译，测试</li>
<li>考虑对超类的新建字段使用 Self Encapsulate Field</li>
</ul>
<h3 id="u51FD_u6570_u4E0A_u79FB_Pull_Up_Method"><a href="#u51FD_u6570_u4E0A_u79FB_Pull_Up_Method" class="headerlink" title="函数上移 Pull Up Method"></a>函数上移 Pull Up Method</h3><p>有些函数，在各个子类中产生完全相同的结果 -&gt; 将函数移至超类</p>
<ul>
<li>检查待提升函数，确定它们是完全一致的</li>
<li>如果待提升函数的签名不同，将那些签名都修改为你想要在超类中使用的签名</li>
<li>在超类中新建一个函数，将某个待提升函数的代码复制到其中，做适当调整，然后编译</li>
<li>移除一个待提升的子类函数</li>
<li>编译，测试</li>
<li>逐一移除待提升的子类函数，直到只剩下超类中的函数为止。每次移除之后都需要测试</li>
<li>观察该函数的 调用者，看看是否可以改为使用超类类型的对象</li>
</ul>
<h3 id="u6784_u9020_u51FD_u6570_u672C_u4F53_u4E0A_u79FB_Pull_Up_Constructor_Body"><a href="#u6784_u9020_u51FD_u6570_u672C_u4F53_u4E0A_u79FB_Pull_Up_Constructor_Body" class="headerlink" title="构造函数本体上移 Pull Up Constructor Body"></a>构造函数本体上移 Pull Up Constructor Body</h3><p>你在各子类中拥有一些构造函数，它们的本体几乎完全一致 -&gt; 在超类中新建一个构造函数，并在子类构造函数中调用它</p>
<ul>
<li>在超类中定义一个构造函数</li>
<li>将子类构造函数中的共同代码搬移到超类构造函数中</li>
<li>将子类构造函数中的共同代码删掉，改为调用新建的超类构造函数</li>
<li>编译，测试</li>
</ul>
<h3 id="u51FD_u6570_u4E0B_u79FB_Push_Down_Method"><a href="#u51FD_u6570_u4E0B_u79FB_Push_Down_Method" class="headerlink" title="函数下移 Push Down Method"></a>函数下移 Push Down Method</h3><p>超类中的某个函数只与部分（而非全部）子类有关 -&gt; 将这个函数移到相关的那些子类去</p>
<ul>
<li>在所有子类声明该函数，将超类中的函数本体复制到每一个子类函数中</li>
<li>删除超类中的函数</li>
<li>编译，测试</li>
<li>将该函数从所有不需要它的那些子类中删掉</li>
<li>编译，测试</li>
</ul>
<h3 id="u5B57_u6BB5_u4E0B_u79FB_Push_Down_Field"><a href="#u5B57_u6BB5_u4E0B_u79FB_Push_Down_Field" class="headerlink" title="字段下移 Push Down Field"></a>字段下移 Push Down Field</h3><p>超类中的某个字段只部分（而非全部）子类用到 -&gt; 将这个字段移到需要它的那些子类去</p>
<ul>
<li>在所有子类中声明该字段</li>
<li>将该字段从超类中移除</li>
<li>编译，测试</li>
<li>将该字段从所有不需要它的那些子类中删掉</li>
<li>编译，测试</li>
</ul>
<h3 id="u63D0_u70BC_u5B50_u7C7B_Extract_Subclass"><a href="#u63D0_u70BC_u5B50_u7C7B_Extract_Subclass" class="headerlink" title="提炼子类 Extract Subclass"></a>提炼子类 Extract Subclass</h3><p>类中的某些特性只被某些（而非全部）实例用到 -&gt; 新建一个子类，将上面所说的那一部分特性移到子类中</p>
<ul>
<li>为源类定义一个新的子类</li>
<li>为这个新的子类提供构造函数</li>
<li>找出调用超类构造函数的所有地点。如果它们需要的是新建的子类，令它们改而调用新构造函数</li>
<li>逐一使用 Push Down Method 和 Push Down Field 将源类的特性移到子类去</li>
<li>找到所有这样的字段：它们所传达的信息如今可由继承体系自身传达。以 Self Encapsulate Field 避免直接使用这些字段，然后将它们的取值函数替换为多态常量函数。所有使用这些字段的地方都应该以 Replace Conditional with Polymorphism 重头</li>
<li>每次下移之后，编译并测试</li>
</ul>
<h3 id="u63D0_u70BC_u8D85_u7C7B_Extract_Superclass"><a href="#u63D0_u70BC_u8D85_u7C7B_Extract_Superclass" class="headerlink" title="提炼超类 Extract Superclass"></a>提炼超类 Extract Superclass</h3><p>两个类具有相似特性 -&gt; 为这两个类建立一个超类，将相同特性移至超类</p>
<ul>
<li>为原本的类新建一个空白的抽象超类</li>
<li>运用 Pull Up Field, Pull Up Method 和 Pull Up Constructor Body 逐一将子类的共同元素上移到超类</li>
<li>每次上移后，编译并测试</li>
<li>检查留在子类中的函数，看它们是否还有共通成分</li>
<li>将所有共同元素都上移到超类之后，检查子类的所有用户。如果它们只使用共同接口，你就可以把它们请求的对象类型改为超类</li>
</ul>
<h3 id="u63D0_u70BC_u63A5_u53E3_Extract_Interface"><a href="#u63D0_u70BC_u63A5_u53E3_Extract_Interface" class="headerlink" title="提炼接口 Extract Interface"></a>提炼接口 Extract Interface</h3><ul>
<li>新建一个空接口</li>
<li>在接口中声明待提炼类的共同操作</li>
<li>让相关的类实现上述接口</li>
<li>调整客户端的类型声明，令其使用该接口</li>
</ul>
<h3 id="u6298_u53E0_u7EE7_u627F_u4F53_u7CFB_Collapse_Hierarchy"><a href="#u6298_u53E0_u7EE7_u627F_u4F53_u7CFB_Collapse_Hierarchy" class="headerlink" title="折叠继承体系 Collapse Hierarchy"></a>折叠继承体系 Collapse Hierarchy</h3><p>超类和子类之间无太大区别 -&gt; 将它们合为一题</p>
<ul>
<li>选择你想移除的类：是超类还是子类？</li>
<li>把想要移除的类的所有行为和数据搬移到另一个类</li>
<li>每次移动后，编译并测试</li>
<li>调整即将被移除的那个类的所有引用点，令它们改而引用合并后留下的类。这个动作将会影响变量的声明、参数的类型以及构造函数</li>
<li>移除我们的目标</li>
<li>编译，测试</li>
</ul>
<h3 id="u5851_u9020_u6A21_u677F_u51FD_u6570_Form_Template_Method"><a href="#u5851_u9020_u6A21_u677F_u51FD_u6570_Form_Template_Method" class="headerlink" title="塑造模板函数 Form Template Method"></a>塑造模板函数 Form Template Method</h3><p>你有一些子类，其中响应的某些函数以相同顺序执行类似的操作，但各个操作在细节上有所不同 -&gt; 将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同。然后将原函数上移至超类</p>
<ul>
<li>在各个子类中分解目标函数，使分解后的各个函数要不完全相同，要不完全不同</li>
<li>运用 Pull Up Method 将各子类内完全相同的函数上移至超类</li>
<li>对于那些完全不同的函数，实施 Rename Method，使所有这些函数的签名完全相同</li>
<li>修改上述所有签名后，编译并测试</li>
<li>运用 Pull Up Method 将所有原函数逐一上移至超类。在超类中将那些代表各种不同操作的函数定义为抽象函数</li>
<li>编译，测试</li>
<li>移除其他子类中的原函数，每删除一个，编译并测试</li>
</ul>
<h3 id="u4EE5_u59D4_u6258_u53D6_u4EE3_u7EE7_u627F_Replace_Inheritance_with_Delegation"><a href="#u4EE5_u59D4_u6258_u53D6_u4EE3_u7EE7_u627F_Replace_Inheritance_with_Delegation" class="headerlink" title="以委托取代继承 Replace Inheritance with Delegation"></a>以委托取代继承 Replace Inheritance with Delegation</h3><p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据 -&gt; 在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系</p>
<ul>
<li>在子类中新建一个字段，使其引用超类的一个实例，并将它初始化为 this</li>
<li>修改子类内的所有函数，让它们不再使用超类，转而使用上述俺哥委托字段。每次修改后，编译并测试</li>
<li>去除两个类之间的继承关系，新建一个受托类的对象赋给受托字段</li>
<li>针对客户端所用的每一个超类函数，为它添加一个简单的委托函数</li>
<li>编译，测试</li>
</ul>
<h3 id="u4EE5_u7EE7_u627F_u53D6_u4EE3_u59D4_u6258_Replace_Delegation_with_Inheritance"><a href="#u4EE5_u7EE7_u627F_u53D6_u4EE3_u59D4_u6258_Replace_Delegation_with_Inheritance" class="headerlink" title="以继承取代委托 Replace Delegation with Inheritance"></a>以继承取代委托 Replace Delegation with Inheritance</h3><p>你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数 -&gt; 让委托类继承受托类</p>
<ul>
<li>让委托端成为受托端的一个子类</li>
<li>编译</li>
<li>将受托字段设为该字段所处对象本身</li>
<li>去掉简单的委托函数</li>
<li>编译并测试</li>
<li>将所有其他涉及委托关系的代码，改为调用对象自身</li>
<li>移除受托字段</li>
</ul>
<h2 id="u5927_u578B_u91CD_u6784"><a href="#u5927_u578B_u91CD_u6784" class="headerlink" title="大型重构"></a>大型重构</h2><p>耗费相当长时间，只在需要添加新功能或修补错误时才进行重构。这一章不写具体做法，很多时候需要灵活变通</p>
<h3 id="u68B3_u7406_u5E76_u5206_u89E3_u7EE7_u627F_u4F53_u7CFB_Tease_Apart_Inheritance"><a href="#u68B3_u7406_u5E76_u5206_u89E3_u7EE7_u627F_u4F53_u7CFB_Tease_Apart_Inheritance" class="headerlink" title="梳理并分解继承体系 Tease Apart Inheritance"></a>梳理并分解继承体系 Tease Apart Inheritance</h3><p>某个继承体系同时承担两项责任 -&gt; 建立两个继承体系，并通过委托关系让其中一个可以调用另一个</p>
<h3 id="u5C06_u8FC7_u7A0B_u5316_u8BBE_u8BA1_u8F6C_u5316_u4E3A_u5BF9_u8C61_u8BBE_u8BA1_Convert_Procedural_Design_to_Objects"><a href="#u5C06_u8FC7_u7A0B_u5316_u8BBE_u8BA1_u8F6C_u5316_u4E3A_u5BF9_u8C61_u8BBE_u8BA1_Convert_Procedural_Design_to_Objects" class="headerlink" title="将过程化设计转化为对象设计 Convert Procedural Design to Objects"></a>将过程化设计转化为对象设计 Convert Procedural Design to Objects</h3><p>你手上有一些传统过程化风格的代码 -&gt; 将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中</p>
<h3 id="u5C06_u9886_u57DF_u548C_u5C55_u793A_u5206_u79BB_Separate_Domain_from_Presentation"><a href="#u5C06_u9886_u57DF_u548C_u5C55_u793A_u5206_u79BB_Separate_Domain_from_Presentation" class="headerlink" title="将领域和展示分离 Separate Domain from Presentation"></a>将领域和展示分离 Separate Domain from Presentation</h3><p>某些 GUI 类之中包含了领域逻辑 -&gt; 将领域逻辑分离出来，为它们建立独立的领域类</p>
<h3 id="u63D0_u70BC_u7EE7_u627F_u4F53_u7CFB_Extract_Hierarchy"><a href="#u63D0_u70BC_u7EE7_u627F_u4F53_u7CFB_Extract_Hierarchy" class="headerlink" title="提炼继承体系 Extract Hierarchy"></a>提炼继承体系 Extract Hierarchy</h3><p>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的 -&gt; 建立继承体系，以一个子类表示一种特殊情况</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>重构：在代码写好之后改进它的设计。</p>]]>
    
    </summary>
    
      <category term="代码" scheme="http://wdxtub.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="读书笔记" scheme="http://wdxtub.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="重构" scheme="http://wdxtub.com/tags/%E9%87%8D%E6%9E%84/"/>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac 工作环境搭建]]></title>
    <link href="http://wdxtub.com/2016/08/08/mac-work-env/"/>
    <id>http://wdxtub.com/2016/08/08/mac-work-env/</id>
    <published>2016-08-08T13:38:14.000Z</published>
    <updated>2016-08-15T14:36:01.000Z</updated>
    <content type="html"><![CDATA[<p>正所谓磨刀不误砍柴工，与其每次在新电脑配置开发环境都要查阅各种各样的资料，不如按照自己的习惯整理一份，在这里跟大家分享一下我习惯的基于 Mac 的开发环境。</p>
<a id="more"></a>
<hr>
<h2 id="u7CFB_u7EDF_u8BBE_u7F6E"><a href="#u7CFB_u7EDF_u8BBE_u7F6E" class="headerlink" title="系统设置"></a>系统设置</h2><p>几个基本原则：</p>
<ul>
<li>除非开发需要，不用 beta 版本的系统和软件 -&gt; 稳定</li>
<li>尽量在屏幕上显示更多的信息，常用信息尽量避免需要二次操作才能看到 -&gt; 效率</li>
<li>尽量保证屏幕空间的可用比例，去掉华而不实的效果</li>
</ul>
<h3 id="u9F20_u6807_/__u89E6_u63A7_u677F_/_Dock"><a href="#u9F20_u6807_/__u89E6_u63A7_u677F_/_Dock" class="headerlink" title="鼠标 / 触控板 / Dock"></a>鼠标 / 触控板 / Dock</h3><p>先说说一下鼠标，设置不多，主要就是把中键弄成了应用程序切换，可以稍微方便一点，直接看图（公司配的依然是旧版鼠标）：</p>
<p><img src="/images/14706635532782.jpg" alt=""></p>
<p>触摸板开启『轻拍来点按』『辅助点按』和『三指拖移』这三个功能，其他我用的不多，看个人了。</p>
<p>Dock 的话把图标弄小，放到左边，不是天天用的，都不要固定在 dock 中，举个例子，我固定的程序只有：iTerm, Mweb 和设置。</p>
<h3 id="Finder_/_Spotlight"><a href="#Finder_/_Spotlight" class="headerlink" title="Finder / Spotlight"></a>Finder / Spotlight</h3><p>显示选项中，把所有『隐藏』条目都弄成『显示』。在偏好设置的高级中，显示所有文件扩展名。搜索时的范围设置为搜索当前文件夹</p>
<p>Spotlight 把快捷键改为 option+space，搜索范围根据自己需要调整，不调整也行，没有太大的区别。</p>
<h2 id="u5F00_u53D1_u5DE5_u5177"><a href="#u5F00_u53D1_u5DE5_u5177" class="headerlink" title="开发工具"></a>开发工具</h2><ul>
<li>Xcode 命令行工具<ul>
<li>安装 <code>xcode-select --install</code></li>
<li>安装完成之后就可以使用很多常用的命令，具体可以通过 <code>ls /Library/Developer/CommandLineTools/usr/bin</code> 来查看</li>
</ul>
</li>
<li>Homebrew 包管理器<ul>
<li>安装 <code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>
<li>添加到环境变量 <code>echo &#39;export PATH=&quot;/usr/local/bin:$PATH&quot;&#39; &gt;&gt; ~/.bash_profile</code></li>
<li>检查并更新 <code>brew doctor; brew update</code></li>
<li>安装包 <code>brew install &lt;package_name&gt;</code></li>
<li>更新包 <code>brew upgrade &lt;package_name&gt;</code></li>
<li>清理旧版本 <code>brew cleanup</code></li>
<li>列出包 <code>brew list --versions</code></li>
</ul>
</li>
<li>Homebrew Cask 安装图形界面程序<ul>
<li>安装 <code>brew tap caskroom/cask</code></li>
<li>可以在 <a href="https://caskroom.github.io/" target="_blank" rel="external">Caskroom.io</a> 搜索 app</li>
<li>一些常用 quicklook 插件<ul>
<li><code>brew cask install qlmarkdown</code></li>
<li><code>brew cask install quicklook-json</code></li>
<li><code>brew cask install quicklook-csv</code></li>
</ul>
</li>
</ul>
</li>
<li>iTerm2<ul>
<li>配色方案有更好，没有其实也行</li>
<li>可以用 zsh，但是远程服务器一般都是 bash，所以就懒得换了</li>
</ul>
</li>
</ul>
<p>Bash 的配色更换，在 <code>~/.bash_profile</code> 中加入下面这段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">"\[\033[0;37m\]\342\224\214\342\224\200\$([[ \$? != 0 ]] &amp;&amp; echo \"[\[\033[0;31m\]\342\234\227\[\033[0;37m\]]\342\224\200\")[<span class="variable">$(if [[ $&#123;EUID&#125; == 0 ]]; then echo '\[\033[0;31m\]\h'; else echo '\[\033[0;33m\]\u\[\033[0;37m\]@\[\033[0;96m\]\h'; fi)</span>\[\033[0;37m\]]\342\224\200[\[\033[0;32m\]\w\[\033[0;37m\]]\n\[\033[0;37m\]\342\224\224\342\224\200\342\224\200\342\225\274 \[\033[0m\]"</span></span><br></pre></td></tr></table></figure>
<h2 id="u5E94_u7528"><a href="#u5E94_u7528" class="headerlink" title="应用"></a>应用</h2><p>很多我在用的工具之前都写过教程，这里简单列一下：</p>
<ul>
<li><a href="http://wdxtub.com/2016/03/30/tmux-guide/">tmux</a> </li>
<li><a href="http://wdxtub.com/2016/03/24/vim-basic-op/">vim</a></li>
<li><a href="http://wdxtub.com/2016/03/24/sublime-guide/">sublime text</a></li>
<li><a href="http://wdxtub.com/2016/03/24/visual-code-guide/">VS Code</a></li>
</ul>
<p>其他我还在用的：</p>
<ul>
<li>Chrome</li>
<li>Parallels</li>
<li>Github</li>
<li>Dropbox</li>
<li>MWeb</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.gitbook.com/book/mba811/mac-dev/details" target="_blank" rel="external">Mac 开发配置手册 by Ashu</a></li>
<li><a href="https://caskroom.github.io/" target="_blank" rel="external">Caskroom.io</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>正所谓磨刀不误砍柴工，与其每次在新电脑配置开发环境都要查阅各种各样的资料，不如按照自己的习惯整理一份，在这里跟大家分享一下我习惯的基于 Mac 的开发环境。</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://wdxtub.com/tags/Mac/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="开发" scheme="http://wdxtub.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【代码整洁之道】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/08/07/clean-code-clip/"/>
    <id>http://wdxtub.com/2016/08/07/clean-code-clip/</id>
    <published>2016-08-07T15:00:15.000Z</published>
    <updated>2016-08-08T14:57:56.000Z</updated>
    <content type="html"><![CDATA[<p>小处诚实非小事，神在细节之中。</p>
<a id="more"></a>
<hr>
<p>习艺之要有二：知和行。你应当习得有关原则、模式和实践的知识，穷尽应知之事，并且要对其了如指掌，通过刻苦实践掌握它。</p>
<h2 id="u6574_u6D01_u4EE3_u7801"><a href="#u6574_u6D01_u4EE3_u7801" class="headerlink" title="整洁代码"></a>整洁代码</h2><p>Bjarne Stroustrup: 我喜欢优雅和高效的代码，代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。</p>
<p>Grady Booch: 整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。</p>
<p>Dave Thomas: 整洁的代码应可由作者之外的开发者阅读和增补。它应有单元测试和验收测试。它使用有意义的命名。它只提供一种而非多种做一件事的途径。它只有尽量少的依赖关系，而且要明确地定义和提供清晰、尽量少的 API。代码应通过其字面表达含义，因为不同的语言导致并非所有必需信息均可通过代码自身清晰表达。</p>
<p>Michael Feathers: 我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的。整洁的代码总是看起来像是某位特别在意它的人写的，几乎没有改进的余地。代码作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给你的代码——全心投入的某人留下的代码。</p>
<p>Ron Jeffries: 近年来，我开始研究贝克的简单代码规则，差不多也都琢磨透了。简单代码，依其重要顺序：能功过所有测试；没有重复代码；体现系统中的全部设计理念；包括尽量少的实体，比如类、方法、函数等</p>
<p>Ward Cunningham: 如果每个例程都让你感到深合己意，那就是整洁代码，如果代码让编程语言看起来像是专为解决那个问题而存在的，就可以称之为漂亮的代码。</p>
<p>光把代码写好可不够。必须时时<strong>保持代码整洁</strong>。我们都见过代码随时间流逝而腐坏。我们应当更积极地组织腐坏的发生。借用美国童子军一条简单的军规：</p>
<blockquote>
<p>让营地比你来时更干净</p>
</blockquote>
<h2 id="u6709_u610F_u4E49_u7684_u547D_u540D"><a href="#u6709_u610F_u4E49_u7684_u547D_u540D" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><p>好名字的简单规则</p>
<ul>
<li>名副其实</li>
<li>避免误导<ul>
<li>别用 <code>accountList</code> 来指一组帐号，除非它真的是 List 类型</li>
<li>提防使用不同之处较小的名称</li>
</ul>
</li>
<li>做有意义的区分</li>
<li>使用读得出来的名称</li>
<li>使用可搜索的名称（单字母名称和数字常量很难在一大篇文字中找出来）</li>
<li>避免使用编码</li>
<li>避免使用思维映射</li>
<li>类名不应当是动词</li>
<li>方法名应当是动词或动词短语</li>
<li>别扮可爱</li>
<li>每个概念对应一个词</li>
<li>别用双关语</li>
<li>使用解决方案领域名称</li>
<li>使用源自所涉问题领域的名称</li>
<li>添加有意义的语境（实在不行可以添加前缀）</li>
<li>不要添加没用的语境</li>
</ul>
<h2 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h2><ul>
<li>短小</li>
<li>只做一件事</li>
<li>每个函数一个抽象层级</li>
<li>switch 语句<ul>
<li>如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他部分看不到，就还能容忍</li>
</ul>
</li>
<li>使用描述性的名称</li>
<li>函数参数<ul>
<li>尽量避免三个或三个以上参数</li>
</ul>
</li>
<li>无副作用</li>
<li>分隔指令与询问</li>
<li>使用异常替代返回错误码<ul>
<li>错误处理代码就能从主路径代码中分离出来</li>
<li>抽离 Try/Catch 代码块：最好把 try 和 catch 代码块的主题部分抽离出来，另外形成函数</li>
<li>错误处理就是一件事</li>
<li>返回错误码通常暗示有某个类或是枚举，定义了所有错误码，这样的类就是一块<strong>依赖磁铁(dependency magnet)</strong>，其他许多类都得导入和使用它</li>
</ul>
</li>
<li>别重复自己</li>
<li>结构化编程</li>
</ul>
<p>每个系统都是使用某种领域特定语言搭建的，而这种语言是程序员设计来描述那个系统的。函数是语言的动词，类是名词。编程艺术是且一直就是语言设计的艺术。</p>
<p>大师级程序员把系统当作故事来讲，而不是当作程序来写。他们使用选定编程语言提供的工具构建一种更为丰富且更具表达力的语言，用来讲那个故事。</p>
<h2 id="u6CE8_u91CA"><a href="#u6CE8_u91CA" class="headerlink" title="注释"></a>注释</h2><p>尽管有时也需要注释，我们也该多花心思尽量减少注释量</p>
<ul>
<li>注释不能美化糟糕的代码</li>
<li>用代码来阐述</li>
<li>好注释<ul>
<li>法律信息</li>
<li>提供信息的注释</li>
<li>对意图的解释</li>
<li>阐释</li>
<li>警示</li>
<li>TODO 注释</li>
<li>放大</li>
<li>公共 API 中的 Javadoc</li>
</ul>
</li>
<li>坏注释<ul>
<li>喃喃自语</li>
<li>多余的注释</li>
<li>误导性注释</li>
<li>循规式注释</li>
<li>日志式注释</li>
<li>废话注释</li>
<li>可怕的废话（Javadoc 也可能是废话）</li>
<li>能用函数或变量时就别用注释</li>
<li>位置标记</li>
<li>括号后面的注释</li>
<li>归属与署名（有源代码控制系统）</li>
<li>注释掉的代码</li>
<li>HTML 注释</li>
<li>非本地信息</li>
<li>信息过多</li>
<li>不明显的联系</li>
<li>函数头</li>
<li>非公共代码中的 Javadoc（八股）</li>
</ul>
</li>
</ul>
<h2 id="u683C_u5F0F"><a href="#u683C_u5F0F" class="headerlink" title="格式"></a>格式</h2><ul>
<li>向报纸学习<ul>
<li>名称应当简单且一目了然。名称本身应该足够告诉我们是否在正确的模块中。源文件最顶部应该给出高层次概念和算法。细节应该往下渐次展开，直到找到源文件中最底层的函数和细节</li>
<li>概念间垂直方向上的区隔</li>
<li>垂直方向上的靠近</li>
<li>垂直距离</li>
<li>垂直顺序 </li>
</ul>
</li>
<li>横向格式<ul>
<li>水平方向上的区隔与靠近</li>
<li>水平对齐</li>
<li>缩进</li>
<li>空范围</li>
</ul>
</li>
<li>团队规则<ul>
<li>在团队中，个人需要满足团队</li>
</ul>
</li>
</ul>
<h2 id="u5BF9_u8C61_u548C_u6570_u636E_u7ED3_u6784"><a href="#u5BF9_u8C61_u548C_u6570_u636E_u7ED3_u6784" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><ul>
<li>数据抽象</li>
<li>数据、对象的反对称性</li>
<li>得墨忒耳律：模块不应了解它所操作对象的内部情形<ul>
<li>火车失事：连串的调用通常被认为是肮脏的风格</li>
<li>混杂</li>
<li>隐藏结构</li>
</ul>
</li>
<li>数据传送对象<ul>
<li>最为精炼的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为数据传送对象，或 DTO(Data Transfer Objects)。DTO 是非常有用的结构，尤其是在与数据库通信、或解析套接字传递的消息之类的场景中</li>
</ul>
</li>
</ul>
<h2 id="u9519_u8BEF_u5904_u7406"><a href="#u9519_u8BEF_u5904_u7406" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。</p>
<ul>
<li>使用异常而非返回码</li>
<li>先写 Try-Catch-Finally 语句</li>
<li>使用不可控异常（可控异常的代价就是违反开放/闭合原则）</li>
<li>给出异常发生的环境说明（创建信息充分的错误消息，并和异常一起传递出去）</li>
<li>依调用者需要定义异常类</li>
<li>定义常规流程</li>
<li>别返回 null 值<ul>
<li>返回 null 值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 null 值，应用程序就会失控</li>
</ul>
</li>
<li>别传递 null 值</li>
</ul>
<p>整洁代码是可读的，但也要强固。可读与强固。可读与强固并不冲突。如果将错误处理隔离看待，独立于主要逻辑之外，就能写出强固而整洁的代码。做到这一步，我们就能单独处理它，也极大地提升了代码的可维护性。</p>
<h2 id="u8FB9_u754C"><a href="#u8FB9_u754C" class="headerlink" title="边界"></a>边界</h2><ul>
<li>使用边界接口<ul>
<li>如果你私用类似 Map 这样的边界接口，就把它保留在类或近亲类中。避免从公共 API 中返回边界接口，或将边界接口作为参数传递给公共 API</li>
</ul>
</li>
<li>浏览和学习边界</li>
<li>学习性测试的好处不只是免费</li>
<li>使用尚不存在的代码</li>
<li>整洁的边界<ul>
<li>边界上会发生有趣的事。改动是其中之一。有良好的软件设计，无需重大投入和重写即可修改</li>
</ul>
</li>
</ul>
<h2 id="u5355_u5143_u6D4B_u8BD5"><a href="#u5355_u5143_u6D4B_u8BD5" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li>TDD 三定律<ul>
<li>在编写不能通过的单元测试前，不可编写生产代码</li>
<li>只可编写刚好无法通过的单元测试，不能编译也算不通过</li>
<li>只可编写刚好足以通过当前失败测试的生产代码</li>
</ul>
</li>
<li>保持测试整洁<ul>
<li>测试代码和生产代码一样重要</li>
</ul>
</li>
<li>整洁的测试<ul>
<li>三要素：可读性、可读性和可读性。</li>
<li>明确、简洁，还有足够的表达力</li>
</ul>
</li>
<li>每个测试一个断言</li>
<li>FIRST 原则<ul>
<li>快速 Fast</li>
<li>独立 Independent</li>
<li>可重复 Repeatable</li>
<li>自足验证 Self-Validating</li>
<li>及时 Timely</li>
</ul>
</li>
</ul>
<h2 id="u7C7B"><a href="#u7C7B" class="headerlink" title="类"></a>类</h2><ul>
<li>类的组织<ul>
<li>从一组变量列表开始。如果有公共静态常量，应该先出现。然后是私有静态变量，以及私有实体变量。很少会有公共变量。</li>
<li>公共函数应跟在变量列表之后。我们喜欢把某个公共函数调用的私有工具函数紧随在该公共函数后面。这符合了自顶向下原则</li>
</ul>
</li>
<li>类应该短小<ul>
<li>单一权责原则(SRP)：类或模块应有且仅有一条加以修改的理由</li>
<li>系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为</li>
<li>内聚：类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量</li>
<li>保持内聚性就会得到许多短小的类</li>
</ul>
</li>
<li>为了修改而组织 </li>
</ul>
<h2 id="u7CFB_u7EDF"><a href="#u7CFB_u7EDF" class="headerlink" title="系统"></a>系统</h2><ul>
<li>将系统的构造与使用分开<ul>
<li>分解 main</li>
<li>工厂</li>
<li>依赖注入</li>
</ul>
</li>
<li>扩容<ul>
<li>软件系统与物理系统可以类比。它们的架构都可以递增式地增长，只要我们持续将关注面恰当地切分</li>
</ul>
</li>
<li>测试驱动系统架构</li>
<li>优化决策</li>
<li>明智使用添加了可论证价值的标准</li>
<li>系统需要领域特定语言</li>
</ul>
<p>系统也应该是整洁的。侵害性架构会湮灭领域逻辑，冲击敏捷能力。当领域逻辑受到困扰，质量也就堪忧，因为缺陷更易隐藏，用户故事更难实现。当敏捷能力受到损害时，生产力会降低，TDD 的好处也遗失殆尽。</p>
<h2 id="u8FED_u8FDB"><a href="#u8FED_u8FDB" class="headerlink" title="迭进"></a>迭进</h2><ul>
<li>简单设计规则 1：运行所有测试</li>
<li>简单设计规则 2~4：重构</li>
<li>不可重复</li>
<li>表达力</li>
<li>尽可能少的类和方法</li>
</ul>
<h2 id="u5E76_u53D1_u7F16_u7A0B"><a href="#u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="并发编程"></a>并发编程</h2><blockquote>
<p>对象是过程的抽象，线程是调度的抽象</p>
</blockquote>
<p>编写整洁的并发程序很难——非常难。并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。在单线程应用中，目的与时机紧密耦合，很多时候只要查看堆栈追踪即可断定应用程序的状态。</p>
<p>解耦目的与时机能明显地改进应用程序的吞吐量和结构。从结构的角度看，应用程序看起来更像是许多台协同工作的计算机，而不是一个大循环。系统因此会更易于被理解，给出了许多切分关注面的有力手段。</p>
<p>并发防御原则</p>
<ul>
<li>单一权责原则：建议分离并发相关代码与其他代码</li>
<li>限制数据作用域：谨记数据封装；严格限制对可能被共享的数据的访问</li>
<li>使用数据副本</li>
<li>线程应尽可能地独立</li>
</ul>
<p>其他需要注意的</p>
<ul>
<li>警惕同步方法之间的依赖</li>
<li>保持同步区域微小</li>
</ul>
<p>测试线程代码的方法：</p>
<ul>
<li>将伪失败看作可能的线程问题</li>
<li>先使非线程代码科工作</li>
<li>编写可插拔的线程代码</li>
<li>编写可调整的线程代码</li>
<li>运行多于处理器数量的线程</li>
<li>在不同平台上运行</li>
<li>调整代码并强迫错误发生</li>
</ul>
<h2 id="u5473_u9053_u4E0E_u542F_u53D1"><a href="#u5473_u9053_u4E0E_u542F_u53D1" class="headerlink" title="味道与启发"></a>味道与启发</h2><p>以下这些都是不好的，需要避免</p>
<ul>
<li>注释<ul>
<li>不恰当的信息</li>
<li>废弃的注释</li>
<li>冗余注释</li>
<li>糟糕的注释</li>
<li>注释掉的代码</li>
</ul>
</li>
<li>环境<ul>
<li>需要多步才能实现的构建</li>
<li>需要多步才能做到的测试</li>
</ul>
</li>
<li>函数<ul>
<li>过多的参数</li>
<li>输出参数</li>
<li>标识参数</li>
<li>死函数</li>
</ul>
</li>
<li>一般性问题<ul>
<li>一个源文件中存在多个语言</li>
<li>明显的行为未被实现</li>
<li>不正确的边界行为</li>
<li>忽视安全</li>
<li>重复</li>
<li>在错误的抽象层级上的代码</li>
<li>基类依赖于派生类</li>
<li>信息过多</li>
<li>死代码</li>
<li>垂直分隔</li>
<li>前后不一致</li>
<li>混淆视听</li>
<li>人为耦合</li>
<li>特性依赖</li>
<li>选择算子参数</li>
<li>晦涩的意图</li>
<li>位置错误的权责</li>
<li>不恰当的静态方法</li>
</ul>
</li>
</ul>
<p>应该做的    </p>
<ul>
<li>使用解释性变量</li>
<li>函数名称应该表达其行为</li>
<li>理解算法</li>
<li>把逻辑依赖改为物理依赖</li>
<li>用多态替代 If/Else 或 Switch/Case</li>
<li>遵循标准约定</li>
<li>用命名常量代替 Magic Number</li>
<li>准确</li>
<li>接哦古甚于约定</li>
<li>封装条件</li>
<li>避免否定性条件</li>
<li>函数只该做一件事</li>
<li>掩蔽时序耦合</li>
<li>别随意</li>
<li>封装边界条件</li>
<li>函数应该只在一个抽象层级上</li>
<li>在较高层级放置科配置数据</li>
<li>避免传递浏览</li>
</ul>
<p>Java 技巧</p>
<ul>
<li>通过使用通配符避免过长的导入清单</li>
<li>不要继承常量</li>
<li>用枚举代替常量</li>
</ul>
<p>名称</p>
<ul>
<li>采用描述性名称</li>
<li>名称应与抽象层级相符</li>
<li>尽可能使用标准命名法</li>
<li>五歧义的名称</li>
<li>为较大做用范围选用较长名称</li>
<li>避免编码（前缀等没必要）</li>
<li>名称应该说明副作用</li>
</ul>
<p>测试</p>
<ul>
<li>测试不足</li>
<li>使用覆盖率工具</li>
<li>别略过小测试</li>
<li>被忽略的测试是对不确定事物的疑问</li>
<li>测试边界条件</li>
<li>全面测试相近的缺陷</li>
<li>测试失败的模式有启发性</li>
<li>测试覆盖率的模式有启发性</li>
<li>测试应该快速</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>小处诚实非小事，神在细节之中。</p>]]>
    
    </summary>
    
      <category term="代码" scheme="http://wdxtub.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="读书笔记" scheme="http://wdxtub.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="质量" scheme="http://wdxtub.com/tags/%E8%B4%A8%E9%87%8F/"/>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【修改代码的艺术】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/08/07/working-effectively-with-legacy-code-clip/"/>
    <id>http://wdxtub.com/2016/08/07/working-effectively-with-legacy-code-clip/</id>
    <published>2016-08-07T11:08:58.000Z</published>
    <updated>2016-08-07T14:05:38.000Z</updated>
    <content type="html"><![CDATA[<p>六六三十六，数中有术，术中有数。阴阳燮理，机在其中。机不可设，设则不中。</p>
<a id="more"></a>
<hr>
<p>本书教你如何扭转腐化，教你在面对一个错综复杂的、不透明的、令人费解的系统时如何慢慢地、逐步地将其变成一个简单的、有良好组织和设计的系统。</p>
<p>没有编写测试的代码是糟糕的代码，不管我们有多细心地去编写它们，不管它们有多漂亮、面向对象或封装良好，只要没有编写测试，我们实际上就不知道修改后的代码是变得更好了还是更糟了。反之，有了测试，我们就能够迅速、可验证地修改代码的行为。</p>
<p>良好的设计应当是所有开发者的追求，然而对于遗留代码来说，良好的设计只是我们不断逼近的目标。</p>
<h2 id="u4FEE_u6539_u8F6F_u4EF6"><a href="#u4FEE_u6539_u8F6F_u4EF6" class="headerlink" title="修改软件"></a>修改软件</h2><p>修改软件的四个主要起因：</p>
<ol>
<li>添加新特性</li>
<li>修正 bug</li>
<li>改善设计</li>
<li>优化资源使用</li>
</ol>
<p>行为对于软件来说是最重要的一样东西。软件的用户要依赖于软件的行为。用户喜欢我们添加行为（前提是新的行为确实是他们所需要的），然而如果我们改变或移除了他们原本所依赖的行为（引入 bug），那么他们就不会再相信我们。</p>
<p>保留既有行为不变是软件开发中最具挑战性的任务之一。即便是在改变主要特性时，通常也有很多行为是必须保留不变的。</p>
<h2 id="u5E26_u7740_u53CD_u9988_u5DE5_u4F5C"><a href="#u5E26_u7740_u53CD_u9988_u5DE5_u4F5C" class="headerlink" title="带着反馈工作"></a>带着反馈工作</h2><p>单元测试是用于对付遗留代码的极其重要的组件之一。系统层面的回归测试地区很棒，然而相比之下，小巧而局部性的测试才是无价之宝，它们能够在进行改动的过程中不断给你反馈，是重构工作的安全性大大增强。</p>
<p>依赖性是软件开发中最为关键的问题之一。在处理遗留代码的过程中很大一部分工作都是围绕着『解除依赖性以便使改动变得更容易』这个目标来进行的。</p>
<h2 id="u63A5_u7F1D_u6A21_u578B"><a href="#u63A5_u7F1D_u6A21_u578B" class="headerlink" title="接缝模型"></a>接缝模型</h2><p>接缝(seam)，顾名思义，就是指程序中的一些特殊的点，在这些点上你无需作任何修改就可以达到改动程序行为的目的。</p>
<p>每个接缝都有一个激活点，在这些点上你可以决定使用哪种行为。</p>
<h2 id="u5DE5_u5177"><a href="#u5DE5_u5177" class="headerlink" title="工具"></a>工具</h2><p>重构：名词，对软件内部结构的一种调整，目的是在不改变软件的外在行为的前提下，提高其可理解性，降低其修改成本。</p>
<p>xUnit 测试框架的关键特性为：</p>
<ul>
<li>它允许程序员使用开发语言来编写测试</li>
<li>所有测试互不干扰独立运行</li>
<li>一组测试可以集合起来成为一个测试套件(suite)，根据需要不断运行</li>
</ul>
<h2 id="u65F6_u95F4_u7D27_u8FEB_uFF0C_u4F46_u5FC5_u987B_u4FEE_u6539"><a href="#u65F6_u95F4_u7D27_u8FEB_uFF0C_u4F46_u5FC5_u987B_u4FEE_u6539" class="headerlink" title="时间紧迫，但必须修改"></a>时间紧迫，但必须修改</h2><h3 id="u65B0_u751F_u65B9_u6CD5"><a href="#u65B0_u751F_u65B9_u6CD5" class="headerlink" title="新生方法"></a>新生方法</h3><p>当需要往一个系统中添加特性且这个特性可以用全新的代码来编写时，建议你将这些代码放在一个新的方法中，并在需要用到这个新功能的地方调用这一方法。</p>
<p>任何时候，只要你发现待添加的功能可以写成一块独立的代码，或者暂时还没法用测试来覆盖待修改方法时，我都建议你采用<strong>新生方法</strong>。这比直接往原方法中添加代码好多了。</p>
<p><strong>优缺点</strong></p>
<p>新生方法技术有优点也有缺点。先来看看缺点。当使用它时，效果上等于暂时放弃了原方法以及它所属的类，也就是暂时不打算将它们置于测试之下和改善它们了。突出的优点在于新旧代码被清楚地隔开。这样即使暂时没法将旧代码置于测试之下，至少还能单独去关注所要作的改动，并在新旧代码之间建立清晰的接口。你会看到所有被影响到的变量，更容易确定新的代码在上下文中是否是正确的。</p>
<h3 id="u65B0_u751F_u7C7B"><a href="#u65B0_u751F_u7C7B" class="headerlink" title="新生类"></a>新生类</h3><p>两种情况下我们得使用『新生类(Sprout Class)』。第一种情况：所要进行的修改迫使你为某个类添加一个全新的职责。第二种情况：我们想要添加的只是一点小小的功能，可以将它放入一个现有的类中，但问题是我们无法将这个类放入测试用具。</p>
<p><strong>优缺点</strong></p>
<p>新生类技术的主要优点就在于，它让你在进行侵入性较强的修改时有更大的自信去继续开展自己的工作。主要缺点在于它可能会使系统中的概念复杂化。</p>
<h3 id="u5916_u8986_u65B9_u6CD5"><a href="#u5916_u8986_u65B9_u6CD5" class="headerlink" title="外覆方法"></a>外覆方法</h3><p>当需要添加行为时，可以考虑使用不那么『纠缠』的方式。可以使用的技术之一就是新生方法，但还有一项技术有些时候也是很有用的，我把它称为『外覆方法(Wrap Method)』。</p>
<p>一个典型的运用方法是：创建一个与原方法同名的新方法，并在新方法中调用更名后的原方法。</p>
<p>外覆方法还有另一种运用形式，如果只是想增加一个尚未有任何人调用的新方法，就采用这一形式。</p>
<p>要想在添加新特性的同时引入接缝，外覆方法是极好的选择。它只有少数几个缺点。第一，你添加的新特性无法跟旧特性的逻辑『交融』在一起。它们要么在旧特性之前要么在之后完成。事实上这并非坏事，建议你尽量这么做。第二个缺点，也是更为实际的一个缺点就是，你得为原方法中的旧代码起一个新名字。</p>
<h3 id="u5916_u8986_u7C7B"><a href="#u5916_u8986_u7C7B" class="headerlink" title="外覆类"></a>外覆类</h3><p>外覆方法的类版本便是『外覆类(Wrap Class)』，两者概念几乎一模一样。如果需要往一个系统中添加行为，我们固然可以将该行为放到一个现有的方法中，但我们同样可以将它放到一个使用了该方法的类当中。</p>
<p>该技术在设计模式里面被称作装饰模式。</p>
<h2 id="u6F2B_u957F_u7684_u4FEE_u6539"><a href="#u6F2B_u957F_u7684_u4FEE_u6539" class="headerlink" title="漫长的修改"></a>漫长的修改</h2><p>随着代码量的增加，项目就会变得越来越难理解。于是人们也就需要花费越来越多的时间才能弄清应当修改什么。</p>
<p>还有一个非常普遍的因素会导致修改耗时的延长，这个因素就是时滞(lag time)，是指从做出修改到得到反馈所经历的时间。</p>
<p><strong>依赖倒置原则</strong>：如果你的代码依赖与一个接口，那么这个依赖一般来说是很次要的。除非这个接口发生改变，否则你的代码是无须改变的。</p>
<p>当为了解依赖而往设计中引入了额外的接口和包之后，重新构建整个系统的时间就会稍微变长一点。因为有更多的文件要去编译。但基于需要被重编译的文件而进行的局部重建的平均时耗反而大大缩短了。</p>
<h2 id="u6DFB_u52A0_u7279_u6027"><a href="#u6DFB_u52A0_u7279_u6027" class="headerlink" title="添加特性"></a>添加特性</h2><p>作者非常推崇 TDD，流程如下：</p>
<ol>
<li>编写一个失败测试用例</li>
<li>让他通过编译</li>
<li>让测试通过</li>
<li>消除重复</li>
<li>重复上述步骤</li>
</ol>
<h2 id="u4FEE_u6539_u65F6_u5E94_u5F53_u6D4B_u8BD5_u54EA_u4E9B_u65B9_u6CD5"><a href="#u4FEE_u6539_u65F6_u5E94_u5F53_u6D4B_u8BD5_u54EA_u4E9B_u65B9_u6CD5" class="headerlink" title="修改时应当测试哪些方法"></a>修改时应当测试哪些方法</h2><p>倘若你的代码结构良好，则其中的大多数方法的影响结构也会比较简单。实际上，衡量软件好坏的标准之一便是，看看该软件对外部世界的相当复杂的影响能否由代码内的一组相对简单得多的影响所构成。任何改动，只要能够使代码的影响结构图简单化，就能够使其更易理解和维护。</p>
<p>在画影响结构图的时候，你得确保找到了所考察的类的所有客户端，如果你的类有一个基类或派生类，那么得注意一下它们里面是不是还有没有被注意到的客户代码。</p>
<p>影响在代码中的传递有三种基本途径：</p>
<ol>
<li>调用方法使用被调用函数的返回值</li>
<li>修改传参传进来的对象，且后者接下来会被使用到</li>
<li>修改后面会用到的静态或全局数据</li>
</ol>
<p>不过有些语言中也有其他途径。例如，在面向切片(aspect-oriented)的语言中，程序员可以编写所谓的『切片』代码，后者能够影响系统中其他地方的代码行为。</p>
<h2 id="u4FEE_u6539_u65F6_u5E94_u8BE5_u600E_u6837_u5199_u6D4B_u8BD5"><a href="#u4FEE_u6539_u65F6_u5E94_u8BE5_u600E_u6837_u5199_u6D4B_u8BD5" class="headerlink" title="修改时应该怎样写测试"></a>修改时应该怎样写测试</h2><p>特征测试描述了一块代码的实际行为。在编写特征测试的时候如果发现某些结果与我们所期望的不一致，最好弄清它。因为我们遇到的可能是个 bug。但这并不是说我们就不能把该测试放进测试套装中，而是说我们应该将它标记为可疑的，并搞清修正它会带来哪些影响。</p>
<p>当准备在遗留系统中使用一个方法之前，请查看一下是否已有针对它的测试。没有的话就自己写一个，始终保持这一习惯，你的测试就能起到信息传递媒介的作用。别人只要一看到你的测试就能够知道对于某方法他们应该期待什么而不该期待什么，视图使一个类变得可测试这以行为本身往往能够改善代码的质量。</p>
<p>在为代码分支编写测试时，应该考虑除了那个分支被执行之外是否还存在其他能令测试通过的条件。如果不确定的话，可以使用一个感知变量或调试器来确定你的测试是否恰好命中目标。</p>
<p>最有价值的特征测试覆盖某条特定的代码路径并检查这条路径上的每个转换。</p>
<h2 id="u68D8_u624B_u7684_u5E93_u4F9D_u8D56_u95EE_u9898"><a href="#u68D8_u624B_u7684_u5E93_u4F9D_u8D56_u95EE_u9898" class="headerlink" title="棘手的库依赖问题"></a>棘手的库依赖问题</h2><p>尽量避免在你的代码中到处出现对库的直接调用。你可能会觉得永远也不会需要去修改这些调用，但最终可能只是自欺欺人。</p>
<p>借助于语言特性来施加设计约束的库设计者们往往是犯了一个错误。他们忘记了根本的一条，那就是好的代码除了要能在产品环境中运行之外，还要能在测试环境中运行。然而针对产品环境而施加在代码上的约束则常常会导致代码在测试环境中寸步难行。</p>
<p>有时候使用编码惯例并不比使用某种限制性的语言特性差。你得为自己的测试考虑考虑。</p>
<h2 id="u5BFC_u51FA_u90FD_u662F_API__u8C03_u7528"><a href="#u5BFC_u51FA_u90FD_u662F_API__u8C03_u7528" class="headerlink" title="导出都是 API 调用"></a>导出都是 API 调用</h2><p>从许多方面来讲，到处都是库调用的系统比系统完全自己编写的系统还难对付。其首要原因就是，对于这种系统你很难看出如何才能让代码的结构变得好起来。</p>
<p>剥离并外覆 API 在以下场合表现良好：</p>
<ul>
<li>API 规模相对较小</li>
<li>想要完全分离出对第三方库的依赖</li>
<li>没有现成测试，而且你也没法去编写，因为你没法通过 API 来进行测试</li>
</ul>
<p>基于职责的提取则在以下场合比较适合：</p>
<ul>
<li>API 较为复杂</li>
<li>手头有支持安全的方法提取的重构工具，或者你觉得不用工具也能安全地完成提取</li>
</ul>
<h2 id="u6BEB_u65E0_u7ED3_u6784_u53EF_u8A00"><a href="#u6BEB_u65E0_u7ED3_u6784_u53EF_u8A00" class="headerlink" title="毫无结构可言"></a>毫无结构可言</h2><p>一个开发周期很长的应用会越来越复杂臃肿。一开始的时候它或许还拥有设计良好的架构，然而几年之后，在进度的压力之下，其结构或许就复杂到没人能够真正理解的地步了。</p>
<p>一个残酷的事实是，架构师不是少数人所专有的，而必须是大家的，因为这个角色太重要了。有架构师固然是件好事，但要想发挥架构师的最大作用，关键还是要看团队的成员是否能够清楚架构师到底意味着什么，并能狗感到架构师是跟他们休戚相关的一个角色。每一个接触代码的人都应该了解架构，而其他每一个接触代码的人都应该能够从刚才那个人所学到的东西那儿获益。如果团队里的每个人都有共同的想法，那么整体的力量就会大大增强。</p>
<p><strong>讲述系统故事</strong></p>
<p>在跟团队共事的过程中，我常常会使用一种手法，叫做『讲述系统的故事』。要成功实施这一手法至少需要两个人。像唱双簧那样，一个人开始问，『该系统的架构是怎样的？』然后另一个人就回答，他应该尽量只使用两到三个概念就把系统的架构解释清楚。如果你就是那个负责解释的人，那么就假设另一方对该系统一无所知。你用寥寥数句就解释清楚系统的设计由哪些部分构成以及它们之间是如何进行交互的，你就清楚地解释了这个系统最为本质的东西。接下来再选第二重要的方面来讲述。就这样，一直到你们把有关这个系统的核心设计的所有重要的方面都说明白了为止。</p>
<h2 id="u5904_u7406_u5927_u7C7B"><a href="#u5904_u7406_u5927_u7C7B" class="headerlink" title="处理大类"></a>处理大类</h2><p>庞大的类有哪些问题呢？首先就是容易混淆。</p>
<p>单一职责原则(SRP)：每个类应该仅承担一个职责 - 它在系统中的意图应当是单一的，且修改它的原因应该只有一个</p>
<p>探索式方法</p>
<ol>
<li>方法分组：寻找相似的方法名。将一个类上的所有方法列出来（别忘了它们的访问权限），找出那些看起来是一伙的</li>
<li>观察隐藏方法：注意那些私有或受保护的方法。大量私有或受保护的方法往往意味着一个类内部有另一个类迫切地想要独立出来</li>
<li>寻找可以更改的决定：指已经作出的决定，比如代码中有什么地方（与数据库交互、与另一组对象交互，等等）采用了硬编码吗？你可以设想它们发生变化后的情况吗？</li>
<li>寻找内部关系：寻找成员变量和方法之间的关系。『这个变量只被这些方法使用吗？』</li>
<li>寻找主要职责：尝试仅用一句话来描述该类的职责</li>
<li>当所有方法都行不通时，作一点草稿式重构</li>
<li>关注当前工作</li>
</ol>
<h2 id="u9700_u8981_u4FEE_u6539_u5927_u91CF_u76F8_u540C_u7684_u4EE3_u7801"><a href="#u9700_u8981_u4FEE_u6539_u5927_u91CF_u76F8_u540C_u7684_u4EE3_u7801" class="headerlink" title="需要修改大量相同的代码"></a>需要修改大量相同的代码</h2><p>如果两个方法看上去大致相同，则可以抽取出它们之间的差异成分，通过这种做法，我们往往能够令它们变得完全一样，从而消除掉其中一个。</p>
<p>类名和方法名缩写是问题的来源之一。缩写风格一致的话倒还好，但总的来说我不喜欢这种做法。</p>
<h2 id="u5F53_u4F60_u611F_u5230_u7EDD_u671B_u65F6"><a href="#u5F53_u4F60_u611F_u5230_u7EDD_u671B_u65F6" class="headerlink" title="当你感到绝望时"></a>当你感到绝望时</h2><p>对付遗留系统的人们常常希望他们能去做全新的系统。从头开始构建一个系统固然有意思，但坦白地说，全新的系统也有它们自己的问题。</p>
<p>要想在对付遗留代码时保持积极向上的心态，关键是要找到动力。</p>
<h2 id="u89E3_u4F9D_u8D56_u6280_u672F"><a href="#u89E3_u4F9D_u8D56_u6280_u672F" class="headerlink" title="解依赖技术"></a>解依赖技术</h2><ul>
<li>接口应传达职责而非实现细节。这样的接口令代码易于阅读和维护</li>
<li>安全第一，一旦测试到位，你便可以更有信心地进行侵入性的改动了</li>
<li>定义补全</li>
<li>封装全局引用<ul>
<li>如果若干全局变量总是被一起使用一起修改，则它们应属于同一个类</li>
<li>命名一个类的时候，考虑最终会位于它里面的方法。当然我们应当给它起一个好名字，但并不一定是完美的。别忘了，你总是可以重命名它的</li>
<li>你想到的类名可能已经被用掉了。这时候可以考虑重命名那些使用了该名字的实体，从而将该名字腾出来</li>
<li>从引用一个简单的全局变量到引用一个类成员只是第一步。之后你还需要考虑是否应当使用引入静态设置方法或参数化构造函数，又或者参数化方法</li>
<li>在使用封装全局引用手法时，从数据或小型方法开始着手。稍大一点的方法可以等测试到位之后再移至新类中</li>
<li>要封装对全局自由函数的引用，只需创建一个接口类，然后从它派生出伪类及产品类。产品类中的代码什么都不用做，只需直接委托/调用相应的全局函数即可</li>
</ul>
</li>
<li>暴露静态方法<ul>
<li>在没有测试的情况下解依赖时，尽可能对方法进行签名保持。对整个方法进行剪切/复制可以降低引入错误的可能性 </li>
</ul>
</li>
<li>提取并重写调用</li>
<li>提取并重写工厂方法<ul>
<li>构造函数中固定了的初始化工作可能会给测试带来很大的麻烦</li>
</ul>
</li>
<li>提取并重写获取方法<ul>
<li>要对对象的生命周期格外小心，确保你释放测试用对象的方式跟产品代码释放产品用对象的方式是一致的 </li>
</ul>
</li>
<li>实现提取<ul>
<li>命名是设计的关键部分，好的名字有助于人们理解系统，并令系统更容易对付。反之，糟糕的名字则会影响理解，并给你身后的程序员带来无尽烦恼</li>
</ul>
</li>
<li>接口提取</li>
<li>引入实例委托</li>
<li>引入静态设置方法</li>
<li>连接替换</li>
<li>参数化构造函数</li>
<li>参数化方法</li>
<li>朴素化参数</li>
<li>特性提升</li>
<li>依赖下推</li>
<li>换函数为函数指针</li>
<li>以获取方法替换全局引用</li>
<li>子类化并重写方法</li>
<li>替换实例变量</li>
<li>模板重定义</li>
<li>文本重定义</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>六六三十六，数中有术，术中有数。阴阳燮理，机在其中。机不可设，设则不中。</p>]]>
    
    </summary>
    
      <category term="代码" scheme="http://wdxtub.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
      <category term="修改" scheme="http://wdxtub.com/tags/%E4%BF%AE%E6%94%B9/"/>
    
      <category term="读书笔记" scheme="http://wdxtub.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【卓有成效的程序员】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/08/07/the-productive-programmer-clip/"/>
    <id>http://wdxtub.com/2016/08/07/the-productive-programmer-clip/</id>
    <published>2016-08-07T05:05:30.000Z</published>
    <updated>2016-08-07T10:52:46.000Z</updated>
    <content type="html"><![CDATA[<p>关注本质，而非形式。</p>
<a id="more"></a>
<hr>
<p>生产率是指在一定的时间内所完成的有效工作量。本书包含两部分。第一部分讨论生产率的机制，以及一些能使你在软件开发过程中变得更加高效的工具。第二部分讨论一些提高生产率的实践，以及如何利用你的知识和他人的知识来更快更好地开发软件。</p>
<p>VI 和 Emacs 都支持一个非常重要的加速器：永远不要将你的双手从字符按键上移开。即使是下移到键盘上的箭头按钮都会使你慢下来，因为你必须再次回到主排键来输入字符。真正有用的编辑器会使你的手保持在最佳位置，同时进行输入和导航。</p>
<p>使用多显示器，你可以在一个显示器上写代码在另一个显示器上调试，或是在编程的同时始终把文档放在旁边。不过多显示器只是第一步，因为你还可以利用虚拟桌面把这两个工作空间各自变成一组具有特定功能的视图。</p>
<p>现代社会让我们很难保持专注。但为了充分发挥潜力，你必须根据周围的情况创造出一个能让自己专心工作的空间和环境来，这将极大地提高你的生产率。</p>
<p>当你打算把某个任务自动化时，项目经理可能会担心你的工作失控。要控制这种风险，最好的办法就是『时间盒(timebox)』：首先订好一段时间和探索和了解情况，时间一到就客观地评估是否值得去做这件事。使用时间盒是为了掌握更多信息，以便作出切合实际的决策。时间和到期以后，如果掌握的信息不够，你也可以再增加一个时间盒，以便找出更多信息。</p>
<p>单元测试是一项提升代码质量的极佳实践。经过测试的代码能更好地保证编码意图和实际结果相符。</p>
<p>框架并非十恶不赦之物。恰好相反，框架已成为最受喜爱的一种抽象方式。面向对象开发和组件潮流中许诺的代码重用大多是靠框架来兑现的。但要是框架的功能远超出你的需要，它就会对项目造成伤害，因为框架必然增加复杂度。</p>
<p>古代哲学家们所创立的一些在现在看来显而易见的思想，在当时却需要非凡的才智和莫大的勇气。</p>
<p>SLAP(Single Level of Abstraction Principle, 单一抽象层次原则)强调每个方法中的所有代码都处于同一级抽象层级。换句话说，你不应该在一个方法中既处理底层的数据库连接，又包含高层的业务代码，甚至还包含对 Web 服务的处理。</p>
<h2 id="u63D0_u793A_u90E8_u5206"><a href="#u63D0_u793A_u90E8_u5206" class="headerlink" title="提示部分"></a>提示部分</h2><ul>
<li>一个应用程序列表的有用程度与它的长度成反比</li>
<li>华而不实的东子中看不中用</li>
<li>键盘输入总比导航快</li>
<li>首选键盘而非鼠标</li>
<li>花点时间来学习你手边所有隐藏的快捷键</li>
<li>环境切换会消耗时间</li>
<li>成批复制要比反复多次复制粘贴快</li>
<li>忘记历史就意味着你得再输入一遍</li>
<li>嵌入图形化工具的命令提示符让你鱼与熊掌兼得</li>
<li>在资源管理器中嵌入命令提示符使环境切换更容易</li>
<li>编程时始终有限使用键盘而非鼠标</li>
<li>在上下文中学习 IDE 快捷键，而不要去背长长的列表</li>
<li>当你第二次输入一个复杂结构时，将它做成模板</li>
<li>如果要对多行文本做同样的操作，就应该找出其中的模式，并把它记录为一个宏</li>
<li>在一段文本上执行某个特定操作的次数越多，就越有可能会再次重复它</li>
<li>不要总是重复输入相同的命令</li>
<li>每天花一点点时间来使每一天都更高效</li>
<li>经历越集中，思维越缜密</li>
<li>草堆越大，从中找到一根针就越难</li>
<li>不要文件树，要搜索</li>
<li>在诉诸高级搜索之前，先尝试简单的搜索</li>
<li>有根视图把资源管理器变成了项目管理工具</li>
<li>充分利用内建的机制（例如颜色）来帮助你集中注意力</li>
<li>用链接来创建虚拟的项目管理目录</li>
<li>虚拟桌面可以让原本杂乱无章的一大堆窗口变得整洁</li>
<li>做简单重复的事实在浪费注意力</li>
<li>以创造性的方式解决问题，有助于在将来解决类似的问题</li>
<li>是否应该自动化的关键在于投资回报率和缓解风险</li>
<li>研究性的工作应该放在时间盒里做</li>
<li>对于任何你不自己去构建的东西，只在版本控制中保存一份副本</li>
<li>使用间接机制创建友善的工作空间(workspace)</li>
<li>使用间接机制来保持文件同步</li>
<li>通过复制粘贴来复用是邪恶的，不论你复制粘贴的是什么</li>
<li>利用虚拟平台使项目依赖标准化</li>
<li>不要让对象 - 关系映射工具（O/R 映射器）违反规范原则</li>
<li>通过扩展。开放类(open class)，或者部分类(partial class)来为生成的代码增加行为</li>
<li>使用迁移为数据库结构的改动创建可重复的快照</li>
<li>过时的文档比没有文档更糟，因为它会主动误导你</li>
<li>对管理者来说，文档意味着缓解风险</li>
<li>始终保持『活』的文档</li>
<li>任何需要费劲创造的东西，都让它的创造者欲罢不能</li>
<li>白板 + 数码相机强过任何 CASE 工具</li>
<li>尽量生成所有技术文档</li>
<li>永远不要为同一份信息保存两份拷贝（比如代码和描述它的图）</li>
<li>重复是软件开发中最大的阻力</li>
<li>测试代表着软件开发行为中工程式的严谨部分</li>
<li>把注释重构成方法</li>
<li>静态分析工具提供了便宜实惠的验证手段</li>
<li>不要创建全局变量，即使是对象层次的全局变量</li>
<li>如无必要，勿增加复杂度</li>
<li>软件开发首先是一场沟通博弈</li>
<li>致力本质复杂度，去除附属复杂性</li>
<li>关注那些『古老的』软件技术学说</li>
<li>元编程改变了你的语法辞典，给你提供了更多表达自己的方式</li>
<li>重构成组合方法能暴露出隐藏的可复用代码</li>
<li>TDD 实践推动组合放方法模式</li>
<li>把所有的实现细节封装在公共方法之外</li>
<li>寻找属于你的完美编辑器，并从里到外去了解它</li>
<li>你可以使用宏来记录所有重复的文本操作</li>
<li>掌握好正则表达式将为我们节省大量经历</li>
<li>如果能批处理，就不要来回做重复的工作</li>
<li>将行为保留在（可测试的）代码中</li>
<li>关注每个小工具的演化</li>
<li>尽量少交复杂税</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>关注本质，而非形式。</p>]]>
    
    </summary>
    
      <category term="效率" scheme="http://wdxtub.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="程序员" scheme="http://wdxtub.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="读书笔记" scheme="http://wdxtub.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Unix 编程艺术】读书笔记]]></title>
    <link href="http://wdxtub.com/2016/08/06/art-of-unix-programming-clip/"/>
    <id>http://wdxtub.com/2016/08/06/art-of-unix-programming-clip/</id>
    <published>2016-08-06T14:48:02.000Z</published>
    <updated>2016-08-07T04:57:58.000Z</updated>
    <content type="html"><![CDATA[<p>不懂 Unix 的人注定最终还要重复发明一个蹩脚的 Unix。</p>
<a id="more"></a>
<hr>
<h2 id="u54F2_u5B66"><a href="#u54F2_u5B66" class="headerlink" title="哲学"></a>哲学</h2><p>Unix 有它自己的文化，有独特的编程艺术，有一套影响深远的设计哲学。理解这些传统，会使你写出更好的软件。</p>
<p>工程和设计的每个分支都有自己的技术文化。在大多数工程领域中，就一个专业人员的素养组成来说，有些不成文的行业素养具有与标准手册及教科书同等重要的地位（并且随着专业人员经验的日积月累，这些经验常常会比书本更重要）。自身工程师们在工作中会积累大量的隐性知识，他们用类似禅宗『教外别传』的方式，通过言传身教传授给后辈。</p>
<p>性能-时间的指数曲线对软件开发过程所引发的结果，就是每过十八个月，就有一半的知识会过时。Unix 并不承诺让你免遭此劫，只是让你的知识投资更趋稳定。因为不变的东西有很多：语言、系统调用、工具用法。</p>
<p>Unix 应用程序通常会提供很多的行为选项和令人眼花缭乱的定制功能。这种倾向也反映出 Unix 的遗风：原本是为技术人员设计的操作系统；同时也表明设计的信念：最终用户永远比操作系统设计人员更清楚他们究竟需要什么。</p>
<p>Unix 具有非常彻底的灵活性。Unix 提供众多的程序粘合手段，这意味着 Unix 基本工具箱的各种组件连纵开合后，将收到单个工具设计者无法想象的功效。</p>
<p>Unix 传统将重点放在尽力使各个接口相对小巧、简洁和正交——这也是另一个提高灵活性的方面。</p>
<p>从设计角度来说，趣味性也绝非无足轻重。对于程序员和开发人员来说，如果完成某项任务所需要付出的努力对他们是个挑战却又恰好还在力所能及的范围内，他们就会觉得很有乐趣。因此，趣味性是一个峰值效率的标志。充满痛苦的开发环境只会浪费劳动力和创造力，这样的环境会在无形之中耗费大量时间、资金还有机会。</p>
<p>Unix 哲学起源于 Ken Thompson 早期关于如何设计一个服务接口简洁、小巧精干的操作系统的思考，同时还从其它许多地方博采众长。</p>
<p>Unix 哲学说来不算是一种正规设计方法。它并不打算从计算机科学的理论高度搞产生理论上完美的软件。</p>
<p>Unix 哲学（同其他工程领域的民间传统一样）是自下而上的，而不是自上而下的。Unix 哲学注重实效，立足于丰富的经验。你不会在正规方法学和标准中找到它，它更接近于隐形的半本能的知识，即 Unix 文化所传播的专业经验。它鼓励那种分清轻重缓急的感觉，以及怀疑一切的态度，并鼓励你以幽默达观的态度对待这些。</p>
<p>Unix 管道的发明人、Unix 传统的奠基人之一 Doug Mcllroy 曾经说过：</p>
<ol>
<li>让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂</li>
<li>假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式输入。不要坚持使用交互式输入</li>
<li>尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。</li>
<li>优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器。</li>
</ol>
<p>后来他这样总结到（来自《Unix 的四分之一世纪》）：Unix 哲学是这样的 - 一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。</p>
<p>Rob Pike，最伟大的 C 语言大师之一，在《Notes on C Programming》中从另一个稍微不同的角度描述了 Unix 的哲学</p>
<ul>
<li>原则一：你无法断定程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在</li>
<li>原则二：估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度</li>
<li>原则三：花哨的算法在 n 很小时通常很慢，而 n 通常很小。花哨算法的常数复杂度很大。除非你确定 n 总是很大，否则不要用花哨算法（即使 n 很大，也优先考虑原则 2）</li>
<li>原则四：花哨的算法比简单算法更容易出 bug、更难实现。尽量使用简单的算法配合简单的数据结构</li>
<li>原则五：数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法</li>
<li>原则六：没有原则六</li>
</ul>
<p>Ken Thompson - Unix 最初版本的设计者和实现者，禅宗般地对 Pike 的原则作了强调：拿不准就穷举。</p>
<p>Unix 哲学中更多的内容不是这些先哲们口头表述出来的，而是由他们所作的一切和 Unix 本身所作出的榜样体现出来的。从整体上来说，可以概括为以下几点：</p>
<ol>
<li>模块原则：使用简洁的接口拼合简单的部件</li>
<li>清晰原则：清晰胜于机巧</li>
<li>组合原则：设计时考虑拼接组合</li>
<li>分离原则：策略通机制分裂，接口同引擎分类</li>
<li>简洁原则：设计要简洁，复杂度能低则低</li>
<li>吝啬原则：除非确无它法，不要编写庞大的程序</li>
<li>透明性原则：设计要可见，以便审查和调试</li>
<li>健壮原则：健壮源于透明与简洁</li>
<li>表示原则：把知识叠入数据以求逻辑质朴而健壮</li>
<li>通俗原则：接口设计避免标新立异</li>
<li>缄默原则：如果一个程序没什么好说的，就沉默</li>
<li>补救原则：出现异常时，马上退出并给出足够错误信息</li>
<li>经济原则：宁花机器一分，不花程序员一秒</li>
<li>生成原则：避免手工 hack，尽量编写程序去生成程序</li>
<li>优化原则：雕琢前先要有原型，跑之前先学会走</li>
<li>多样原则：绝不相信所谓『不二法门』的断言</li>
<li>扩展原则：设计着眼未来，未来总比预想来得快</li>
</ol>
<p>浓缩为一条铁律：KISS(Keep It Simple, Stupid!)</p>
<p>应用 Unix 哲学的的部分内容</p>
<ul>
<li>只要可行，一切都应该做成与来源和目标无关的过滤器</li>
<li>数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）</li>
<li>数据库部署和应用协议应尽可能文本化（让人可以阅读和编辑）</li>
<li>复杂的前端（用户界面）和后端应该泾渭分明</li>
<li>如果可能，用 C 编写前，先用解释性语言搭建原型</li>
<li>当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好</li>
<li>宽收严发（对接收的东西要包容，对输出的东西要严格）</li>
<li>过滤时，不需要丢弃的信息决不丢</li>
<li>小就是美。在确保完成任务的基础上，程序功能尽可能少</li>
</ul>
<p>态度也要紧！</p>
<p>看到该做的就去做 - 短期来看似乎是多做了，但从长期来看，这才是最佳捷径。如果不能确定什么是对的，那么就只做最少量的工作，确保任务完成就行，至少直到明白什么是对的。</p>
<p>要良好的运用 Unix 哲学，你就应该不断追求卓越。你必须相信，软件设计是一门技艺，值得你付出所有的智慧、创造力和激情。否则，你的视线就不会超越那些简单、老套的设计和实现；你就会在应该思考的时候急急忙忙跑去编程。你就会在该无情删繁就简的时候把问题复杂化——然后你还会反过来奇怪你的代码怎么会那么臃肿、那么难以调试。</p>
<p>要良好地运用 Unix 哲学，你应该珍惜你的时间决不浪费。一旦某人已经解决了某个问题，就直接拿来利用，不要让骄傲或偏见拽住你又去重做一遍。永远不要蛮干；要多用巧劲，省下力气到需要的时候再用，好钢用在刀刃上。善用工具，尽可能将一切都自动化。</p>
<p>软件设计和实现应该是一门充满快乐的艺术，一种高水平的游戏。要良好地运用 Unix 哲学，你需要具备这种态度。你需要用心。你需要去游戏。你需要乐于探索。</p>
<h2 id="u5386_u53F2"><a href="#u5386_u53F2" class="headerlink" title="历史"></a>历史</h2><p>小型实验原型系统的后继产品往往备受令人讨厌的『第二版效应』折磨。由于迫切希望把所有首次开发时遗漏的功能都添加进去，往往导致设计十分庞大、过于复杂。其实，还有一个因不常遇到而鲜为人知的『第三版效应』：有时候，在第二系统不堪自身重负而崩溃之后，有可能返璞归真，走上正道。</p>
<p>最初的 Unix 就是一个第三系统。</p>
<p>到 1993 年年末，Linux 已经具备有 Internet 能力和 X 系统。整套 GNU 工具包从一开始就内置其中，以提供高质量的开发工具。除了 GNU 工具，Linux 好像一个魅力聚宝盆，囊括了二十年来分散在十几种专有 Unix 平台上的开源软件之精华。</p>
<p>在旧学派的 Unix 开发者中，一部分脑筋活络的人开始注意到，做了多年的平价 Unix 之梦从一个意想不到的方向悄然成真。它就这样从 Internet 的石头缝中跳了出来，浑然天成，以令人惊奇的方式重新规划拼装了 Unix 的传统元素。</p>
<p>Unix 传统是一种隐性的文化，不只是一书袋的技术窍门。这种传统传达着一个有关美和优秀设计的价值体系：里面有它的江湖和侠客。Unix 传统、黑客文化以及开源运动间的关系微妙而复杂。三种隐性文化背后往往是同一群人，然而期间的关系并未因此而简化。但是，从 1990 年以来，Unix 的故事很大程度上成了开源世界的黑客们改变规则、从保守的专有 Unix 厂商手中夺取主动权的故事。因此，今天 Unix 身后的历史，有一半就是黑客的历史。</p>
<p>在 Unix 历史中，最大的规律就是：距开源越接近就越繁荣。任何将 Unix 专有化的企业，只能陷入停滞和衰败。对今后的教训就是：过度依赖任何一种技术或者商业模式都是错误的——相反，保持软件及其设计传统的灵活性才是长存之道。</p>
<h2 id="u6A21_u5757_u6027_uFF1A_u4FDD_u6301_u6E05_u6670_uFF0C_u4FDD_u6301_u7B80_u6D01"><a href="#u6A21_u5757_u6027_uFF1A_u4FDD_u6301_u6E05_u6670_uFF0C_u4FDD_u6301_u7B80_u6D01" class="headerlink" title="模块性：保持清晰，保持简洁"></a>模块性：保持清晰，保持简洁</h2><p>模块化原则在这里展开来说就是：要编写复杂软件又不至于一败涂地的唯一方法，就是用定义清晰的接口把若干简单模块组合起来，如此一来，多数问题只会出现在局部，那么还有希望对局部进行改进或优化，而不至于牵动全身。</p>
<h3 id="u5C01_u88C5_u548C_u6700_u4F73_u6A21_u5757_u5927_u5C0F"><a href="#u5C01_u88C5_u548C_u6700_u4F73_u6A21_u5757_u5927_u5C0F" class="headerlink" title="封装和最佳模块大小"></a>封装和最佳模块大小</h3><p>模块化代码的首要特质就是封装。封装良好的模块不会过多向外部披露自身的细节，不会直接调用其他模块的实现码，也不会胡乱共享全局数据。模块之间通过应用程序编写接口（API）——一组严密、定义零号的程序调用和数据结构来通信。这就是模块化原则的内容。</p>
<p>API 在模块间扮演双重角色。在实现层面，作为模块之间的滞塞点(choke point)，阻止各自的内部细节被相邻模块知晓；在设计层面，正是 API（而不是模块间的实现代码）真正定义了整个体系。</p>
<p>有一种很好的方式来验证 API 是否设计良好：如果试着用纯人类语言描述设计（不许摘录任何源代码），能否把事情说清楚？</p>
<p>模块分解得越彻底，每一块就越小，API 的定义也就越重要。全局复杂度和受 bug 影响的程度也会相应降低。软件系统应设计成由层次分明的嵌套模块组成，而且每个层面上的模块粒度应降至最低。</p>
<h3 id="u7D27_u51D1_u578B_u548C_u6B63_u4EA4_u6027"><a href="#u7D27_u51D1_u578B_u548C_u6B63_u4EA4_u6027" class="headerlink" title="紧凑型和正交性"></a>紧凑型和正交性</h3><p>紧凑性就是一个设计是否能装进人脑中的特性。测试软件紧凑性的一个很实用的好方法是：有经验的用户通常需要操作手册吗？如果不需要，那么这个设计就是紧凑的。</p>
<p>在通用编程语言中，C 和 Python 是半紧凑的（Go 也是），Perl/Java/shell 则不是.</p>
<p>在纯粹的正交设计中，任何操作均无副作用。每一个动作（无论是 API 调用、宏调用还是语言运算）只改变一件事，不会影响其它。无论你控制的是什么系统，改变每个属性的方法有且只有一个。</p>
<p>正交性的一个原则就是『不要重复自身(DRY, Don’t Repeat Yourself)』，在本书中，我们更愿意把这个原则称为『真理的单点性(SPOT, Single Point of Truth)』。</p>
<p>重复会导致前后矛盾、产生隐微问题的代码，原因是当你修改重复点时，往往只改变了一部分而非全部。通常，这也意味着你对代码的组织没有想清楚。</p>
<p>常量、表和元数据应该只声明和初始化一次，并导入其它地方。无论何时，重复代码都是危险信号。复杂度是要花代价的，不要为此重复付出。</p>
<p>SPOT 原则就是提倡寻找一种数据结构，使得模型中的状态跟真实世界的状态能够一一对应。</p>
<p>要达到紧凑、正交的设计，就从零开始。禅教导我们：依附导致痛苦；软件设计的经验教导我们：依附于被人忽略的假定将导致非正交、不紧凑的设计，项目不是失败就是成为维护的梦魇。</p>
<h3 id="u8F6F_u4EF6_u662F_u591A_u5C42_u7684"><a href="#u8F6F_u4EF6_u662F_u591A_u5C42_u7684" class="headerlink" title="软件是多层的"></a>软件是多层的</h3><p>一般来说，设计函数或对象的层次结构可以选择两个方向。选择何种方向、何时选择，对代码的分层有着深远的影响。</p>
<p>实际代码往往是自顶向下和自底向上的综合产物。同一个项目中经常同时兼有自顶向下的代码和自底向上的代码。这就导致了『胶合层』的出现。</p>
<p>Unix 程序员几十年的教训之一就是：胶合层是个挺讨厌的东西，必须尽可能薄，这一点极为重要。胶合层用来将东西粘在一起，但不应该用来隐藏各层的裂痕和不平整。</p>
<p>薄胶合层原则可以看作是分离原则的升华。策略（应用逻辑）应该与机制（域原语集）清晰地分离。如果有许多代码既不属于策略又不属于机制，就很有可能除了增加系统的整体复杂度之外，没有任何其他用处。</p>
<h3 id="u7A0B_u5E8F_u5E93"><a href="#u7A0B_u5E8F_u5E93" class="headerlink" title="程序库"></a>程序库</h3><p>Unix 编程风格强调模块性和定义零号的 API，它所产生的影响之一就是：强烈倾向于把程序分解成由胶合层连接的库集合，特别是共享库。</p>
<p>库分层的一个重要形式是插件，即拥有一套已知入口、可在启动以后动态从入口处来执行特定任务的库。这种模式必须将调用程序作为文档详备的服务库组织起来，使得插件可以回调。</p>
<h3 id="Unix__u548C_u9762_u5411_u5BF9_u8C61_u8BED_u8A00"><a href="#Unix__u548C_u9762_u5411_u5BF9_u8C61_u8BED_u8A00" class="headerlink" title="Unix 和面向对象语言"></a>Unix 和面向对象语言</h3><p>OO 设计理念的价值最初在图形系统、图形用户界面和某些仿真程序中被认可。使大家惊讶并逐渐失望的是，很难发现 OO 设计在这些领域以外还有多少显著优点。其中原因值得我们去探究一番。</p>
<p>在 Unix 的模块化传统和围绕 OO 语言发展起来的使用模式之间，存在着某些紧张对立的关系。Unix 程序员一直比其他程序员对 OO 更持怀疑态度，原因之一就源于多样性原则。</p>
<p>所有的 OO 语言都显示出某种使程序员陷入过度分层陷阱的倾向。对象框架和对象浏览器并不能代替良好的设计和文档，却常常被混为一谈。过多的层次破坏了透明性：我们很难看清这些层次，无法在头脑中理清代码到底是怎样运行的。简洁、清晰和透明原则统统被破坏了，结果代码中充满了 bug，始终存在维护问题。</p>
<p>可能正是因为许多编程课程都把厚重的软件分层作为实现表达原则的方法来教授，这种趋势还在恶化。根据这种观点，拥有很多类就等于在数据中嵌入了很多知识。问题在于，胶合层中的『智能数据』却经常不代表任何程序处理的自然实体——仅仅是胶合物而已。</p>
<p>Unix 风格程序设计所面临的主要挑战就是如何将分离法的优点（将问题从原始的场景中简化、归纳）同代码和设计的薄胶合、浅平透层次结构的优点相结合。</p>
<h3 id="u6A21_u5757_u5F0F_u7F16_u7801"><a href="#u6A21_u5757_u5F0F_u7F16_u7801" class="headerlink" title="模块式编码"></a>模块式编码</h3><p>模块性体现在良好的代码中，但首先来自良好的设计。在编写代码时，问问自己以下问题：</p>
<ul>
<li>有多少全局变量？全局变量对模块化是毒药，很容易使各模块轻率、混乱地互相泄露信息</li>
<li>单个模块的大小是否在 Hatton 的『最佳范围』内，也就是 200~400 行。知道自己的『最佳范围』是多少吗？知道与你合作的其他程序员的最佳范围是多少吗？如果不知道，最好保守点</li>
<li>模块内的单个函数是不是太大了？与其说这是一个行数计算问题，还不如说是一个内部复杂性问题。如果不能用一句话来简单描述一个函数与其调用程序之间的约定，这个函数可能太大了</li>
<li>代码是不是有内部 API——即可作为单元向其他人描述的函数调用集和数据结构集，并且每个单元都封装了某一层次的函数，不受其他代码的影响？好的 API 应该是意义清除，不用看具体如何实现就能够理解的。</li>
<li>API 的入口点是不是超过七个？有没有哪个类有七个以上的方法？数据结构的成员是不是超过七个？</li>
<li>整个项目中每个模块的入口点数量如何分布？是不是不均匀？有很多入口点的模块真的需要这么多入口点吗？模块复杂性往往和入口点数量的平方成正比——这也是简单 API 优于复杂 API 的另一个原因</li>
</ul>
<h2 id="u6587_u672C_u5316_uFF1A_u597D_u534F_u8BAE_u4EA7_u751F_u597D_u5B9E_u8DF5"><a href="#u6587_u672C_u5316_uFF1A_u597D_u534F_u8BAE_u4EA7_u751F_u597D_u5B9E_u8DF5" class="headerlink" title="文本化：好协议产生好实践"></a>文本化：好协议产生好实践</h2><p>互用性、透明性、可扩展性和存储/事务处理的经济性——这些都是设计文件格式和应用协议时需要考虑的重要方面。互用性和透明性要求我们在此类设计中要重点考虑数据表达的清晰问题，而不是首先考虑实现的方便性和可能达到的最高性能。</p>
<h3 id="u6587_u672C_u5316_u7684_u91CD_u8981_u6027"><a href="#u6587_u672C_u5316_u7684_u91CD_u8981_u6027" class="headerlink" title="文本化的重要性"></a>文本化的重要性</h3><p>管道和套接字即可以传输文本也可以传输二进制数据。但文本流是非常有用的通用格式，因为人无需专门工具就可以很容易地读写和编辑文本流，这些格式是透明的。</p>
<h3 id="u6570_u636E_u6587_u4EF6_u5143_u683C_u5F0F"><a href="#u6570_u636E_u6587_u4EF6_u5143_u683C_u5F0F" class="headerlink" title="数据文件元格式"></a>数据文件元格式</h3><p>数据文件元格式是一套句法和词法约定，这套约定或者已经正式标准化，或者已经通过实践得到了充分的确定，已有标准服务库来处理列集和散集操作。</p>
<p>Unix 已经形成或采纳了适合多种应用程序的不同元格式。尽可能使用这些元格式是个好习惯。第一个好处是使用服务库可以避免编写大量的用户解析代码和生成代码。但最重要的好处还是开发者甚至很多用户都能立即认出这些格式，有亲切感，这就减少了学习新程序的磨合成本(friction cost)。</p>
<p>『传统 Unix 工具』指 <code>grep</code>, <code>sed</code>, <code>awk</code> 和 <code>cut</code></p>
<ul>
<li>DSV 风格<ul>
<li>DSV 表示 Delimiter-Separated Values（分隔符分隔值）。在 Unix 中，对字段值可能包含空格的 DSV 格式，冒号是默认的分隔符。这种风格的数据文件一般应通过反斜杠 <code>\</code> 转义符支持在数据域中包含冒号。</li>
<li>事实上，Microsoft 版的 CSV 是一个如何设计文本文件格式的典型反面例子</li>
</ul>
</li>
<li>RFC 822 格式<ul>
<li>RFC 822 格式源自互联网电子邮件信息采用的文本格式。在这种元格式中，记录属性每行存放一个，有类似邮件头字段名的标记命名，用冒号后接空白作为结束。字段名不得包含空格；通常用横线代替空格。</li>
</ul>
</li>
<li>Cookie-Jar 格式<ul>
<li>Cookie-jar 格式是 <code>fortune</code> 程序为随机引用数据库而使用的一种格式。这种格式很适合记录只是一堆非结构化文本的情况。这种格式简单使用跟随 <code>%%</code> 的新行符（或者有时只有一个 <code>%</code>）。</li>
<li>简单的 cookie-jar 格式适用于词以上结构没有自然顺序，而且结构不易区别的文本段，或适用于搜索关键字而不是文本上下文的文本段。</li>
</ul>
</li>
<li>Record-Jar 格式<ul>
<li>cookie-jar 记录分隔符和 RFC 822 记录元格式结合得非常好，产生一种我们称之为 record-jar 的格式。Record-jar 格式适合于那些类似 DSV 文件、但又有可变字段数目而且可能伴随无结构文本的字段属性关系集合。</li>
</ul>
</li>
<li>XML<ul>
<li>XML 非常适合复杂的数据格式。一个优势在于经常无需知道数据语义，仅通过语法检查就能发现形式不良、损坏或者错误生成的数据。最严重的问题是无法很好和传统的 Unix 工具协作。同时 XML 本身也相当庞大，要在所有的标记中找到数据很困难</li>
</ul>
</li>
<li>Windows INI 格式<ul>
<li>这种格式可读性好，设计得不错，但和 XML 一样，不能与 <code>grep</code> 或常规 Unix 脚本工具很好地配合使用</li>
</ul>
</li>
</ul>
<h3 id="Unix__u6587_u672C_u6587_u4EF6_u683C_u5F0F_u7684_u7EA6_u5B9A"><a href="#Unix__u6587_u672C_u6587_u4EF6_u683C_u5F0F_u7684_u7EA6_u5B9A" class="headerlink" title="Unix 文本文件格式的约定"></a>Unix 文本文件格式的约定</h3><ul>
<li><strong>如果可能，以新行符结束的每一行只存一个记录。</strong>这样用文本流工具提取记录就非常容易。为了和其他操作系统交换数据，最好让文件格式的解析器不受行结束符是 LF 还是 CR-LF 的影响。在这种格式中，习惯上忽略结尾的空白，以防范常见的编辑错误</li>
<li><strong>如果可能，每行不超过 80 个字符。</strong>这样使格式可以在普通尺寸的终端视窗上浏览。如果很多记录一定要超过 80 个字符，考虑使用分节格式(stanza format)</li>
<li><strong>使用 <code>#</code> 引入注释。</strong>能在数据文件中嵌入注解和说明会非常好。最好是把它们作为文件结构的一部分，便可被知道这种格式的工具保存下来。对于解析时不保存的说明，惯例上采用 <code>#</code> 作为起始字符</li>
<li><strong>支持反斜杠约定。</strong>支持嵌入不可打印控制字符的最自然方法，就是解析 C 语言风格的反斜杠转义。</li>
<li><strong>在每行一条记录的格式中。</strong>冒号约定似乎起源于 Unix 的口令文件。如果某个字段必须包含分隔符，使用反斜杠前缀进行转义</li>
<li><strong>不要过分区别 tab 和 whitespace。</strong>否则，当用户编辑器的 tab 设置不同时，会产生很多令人头疼的麻烦。这条原则是治愈头痛的良方</li>
<li><strong>优先选用十六进制而不是八进制。</strong></li>
<li><strong>对于复杂的记录，使用『节(stanza)』格式：一个记录若有多行，就使用 <code>%%\n</code> 或 <code>%\n</code> 作为记录分隔符。</strong>在人们肉眼检查文件时，这种分隔符是非常有用而且直观的边界标志</li>
<li><strong>在节格式中，要么每行一个记录字段，要么让记录格式和 RFC 822 电子邮件头类似，用冒号终止的字段名关键字作为引导字段。</strong>当字段经常空缺或者超过 80 个字符，或者当记录很稀疏时（如经常有空字段），适用第二种方案。</li>
<li><strong>在节格式中，支持连续行。</strong>解释文件时，或者抛弃空格符之后的反斜杠，或者将空格符之后的新行符解释为单个空格；这样，一个很长的逻辑行就能够折叠成多个很短（容易编辑！）的物理行。在这些格式中，习惯上忽略结尾的空格，可防范常见的编辑错误</li>
<li><strong>要么包含一个版本号，要么将格式设计成相互独立的自描述字节块。</strong>哪怕只存在一丁点格式发生改变或扩展的可能性，也要包含一个版本号，这样代码才能够有条件地在所有版本上正确运行。换句话说，将格式设计成自描述字节块，无须立即破坏旧代码就可以增加新的块类型</li>
<li><strong>注意浮点数取整问题。</strong>由于所用转换库质量的不同，浮点数从二进制转换成文本格式再转换回二进制格式时可能会有精度损失。如果列集/散集的结构中包含浮点数，应该从两个方向都测试一下转换。如果看上去任何一个方向的转换都可能存在取整误差，做好将浮点字段作为未处理器的二进制格式或字符串编码形式转储的准备</li>
<li><strong>不要仅对文件的一部分进行压缩或二进制编码。</strong></li>
</ul>
<h2 id="u900F_u660E_u6027_uFF1A_u6765_u70B9_u5149"><a href="#u900F_u660E_u6027_uFF1A_u6765_u70B9_u5149" class="headerlink" title="透明性：来点光"></a>透明性：来点光</h2><p>如果没有阴暗的角度和隐藏的深度，软件系统就是透明的。透明性是一种被动品质。如果实际上能预测到程序行为的全部或大部分情况，并能建立简单的心理模型，这个程序就是透明的，因为可以看透机器究竟在干什么。</p>
<p>如果软件系统所包含的功能是为了帮助人们对软件建立正确的『做什么，怎样做』的心理模型而设计，这个软件系统就是可显的。可显性降低进入门槛；透明性则减少代码中的存在成本。</p>
<p>编写透明、可显的系统而节省的精力，将来完全可能就是自己的财富。</p>
<p>要追求代码的透明，最有效的方法很简单，就是不要在具体操作的代码上叠放太多的抽象层。</p>
<p>禅的一个主要教导是，通常我们都透过源于欲望的偏见和成见的迷雾观察世界。要开悟，我们必须循序禅的教导，不仅要『去欲望，少依恋』，还要『如实见』——不要让偏见和成见蒙住了眼。</p>
<p>和禅宗一样，优秀 Unix 代码的简洁依赖于严格自律和高水平技艺，这两者乍看未必会看得出来。透明性是项辛苦的工作，但值得我们努力追求，而且并不为附庸风雅。和禅宗不一样的是，软件需要调试——而且通常在整个使用期都需要不断的维护、向前移植和改写。因此，透明性不仅是一种美学意义上的成功，更是一种胜利，反映在软件整个生命周期上，意味着更低的成本。</p>
<p>透明性和可显性同模块性一样，主要是设计的特性而不是代码的特性。仅仅做对一些底层风格要素，如清晰且统一的代码缩进，或具有良好的变量命名约定，是不够的。这些特性更多与代码中不易硬性规定的特性有关。以下这些问题需要好好思考：</p>
<ul>
<li>程序调用层次中最大的静态深度是多少？提示：如果大于四，就要当心</li>
<li>代码是否具有强大、明显的不变性质？不变性质帮助人们推演代码和发现有问题的情况</li>
<li>每个 API 中的各个函数调用是否正交？或者是否存在太多的特征标志(magic flags)和模式位，使得一个调用要完成多个任务？完全避免模式标志会导致混乱的 API，里面包括太多一模一样的函数，但是频繁使用模式标志更容易产生错误（很多易忘并且易混的模式标记）</li>
<li>是否存在一些顺手可用的关键数据结构或全局唯一的记录器(scoreboard)，捕获了系统的高层级状态？这个状态是否容易被形象化和检验，还是分布在数目众多的各个全局变量或对象中，而难以找到？</li>
<li>程序的数据结构或分类和它们所代表的外部实体之间，是否存在清晰的一对一映射？</li>
<li>是否容易找到给定函数的代码部分？不仅单个函数、模块，还有整个代码，需要花多少精力才能读懂</li>
<li>代码增加了特殊情况还是避免了特殊情况？每一个特殊情况可能对任何其它特殊情况产生英系那个；所有隐含的冲突都是 bug 滋生的温床。然而更重要的是，特殊情况是得代码更难理解</li>
<li>代码中有多少个 magic number（意义含糊的常量）？通过审查是否很容易查出实现代码中的限制（比如关键缓冲区的大小）？</li>
</ul>
<p>代码能简单最好。但是如果代码很好地解决了上述问题，则代码也可以很复杂，而且不会对维护人员造成认知负担。</p>
<p>如果作者以外的其他人能够顺利地理解和修改软件，则这个软件就是可维护的。可维护性不仅要求代码能够运行；还要求代码能够遵循清晰原则，并且和人以及计算机成功沟通。</p>
<h2 id="u591A_u9053_u7A0B_u5E8F_u8BBE_u8BA1_uFF1A_u5206_u79BB_u8FDB_u7A0B_u4E3A_u72EC_u7ACB_u7684_u529F_u80FD"><a href="#u591A_u9053_u7A0B_u5E8F_u8BBE_u8BA1_uFF1A_u5206_u79BB_u8FDB_u7A0B_u4E3A_u72EC_u7ACB_u7684_u529F_u80FD" class="headerlink" title="多道程序设计：分离进程为独立的功能"></a>多道程序设计：分离进程为独立的功能</h2><p>Unix 最具特点的程序模块化技法就是将大型程序分解成多个协作进程。多道程序设计是设计中的蛮荒之地，几乎没有号的实践方针。许多程序员尽管精于判断如何将代码分解成子过程(subroutine)，然而最终还是编写出单个庞然大物般的单进程程序，而这些程序往往失败在自身的内部复杂度之上。</p>
<p>无论在协作进程还是在同一进程的协作子过程层面上，Unix 设计风格都运用『做单件事并做好』的方法，强调用定义良好的进程间通信或共享文件来连通小型进程。因此，Unix 操作系统提倡把程序分解成更简单的子进程，并专注考虑这些子进程间的接口。</p>
<p>尽管将程序划分成协作进程带来了全局复杂度降低的好处，但代价是我们必须更多地关注在进程间传递信息和命令的协议设计（在所有种类的软件系统中，接口都是 bug 聚集之地）</p>
<h2 id="u914D_u7F6E_uFF1A_u8FC8_u51FA_u6B63_u786E_u7684_u7B2C_u4E00_u6B65"><a href="#u914D_u7F6E_uFF1A_u8FC8_u51FA_u6B63_u786E_u7684_u7B2C_u4E00_u6B65" class="headerlink" title="配置：迈出正确的第一步"></a>配置：迈出正确的第一步</h2><p>什么应是可配置的？Unix 的回答是『一切』。这种方式产生的程序往往功能强大，专家用户用起来会非常顺手；但它所产生的接口往往选项过多，并且配置文件像杂草一样疯长，从而彻底打击了新手和一般用户。</p>
<p>无论何时想增加配置选项，请考虑以下这些较普遍的问题：</p>
<ul>
<li>能省掉这个功能吗？为什么在加厚手册之外还要加重用户负担？</li>
<li>能否用某种无伤大雅的方式改变程序的常规行为从而无需这个选项？</li>
<li>这个选项是否花哨没用？是否应该少考虑用户界面的可配置性而多考虑正确性？</li>
<li>这个选项附加的行为是否应该用一个独立的程序来代替？</li>
</ul>
<p>传统上，一个 Unix 程序可以在启动环境的五个地方寻找控制信息：</p>
<ul>
<li><code>/etc</code> 下的运行控制文件（或者系统中其他固有位置）</li>
<li>由系统设置的环境变量</li>
<li>用户主目录中的运行控制文件</li>
<li>由用户设置的环境变量</li>
<li>启动程序的命令行所传递的开关和参数</li>
</ul>
<p>用户和系统环境变量的共同点是，在必须复制大量应用程序运行控制文件所包含的信息时特别麻烦，而且尤其令人讨厌的是，只要优先选项改变就必须到处去改变信息。</p>
<h2 id="u63A5_u53E3_uFF1AUnix__u73AF_u5883_u4E0B_u7684_u7528_u6237_u63A5_u53E3_u8BBE_u8BA1_u6A21_u5F0F"><a href="#u63A5_u53E3_uFF1AUnix__u73AF_u5883_u4E0B_u7684_u7528_u6237_u63A5_u53E3_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="接口：Unix 环境下的用户接口设计模式"></a>接口：Unix 环境下的用户接口设计模式</h2><p>我们将使用五种度量标准对接口风格进行分类：简洁、表现力、易用、透明和脚本化能力。</p>
<p>接口设计模式</p>
<ul>
<li>过滤器模式：接受标准输入的数据，转换成某种格式后，再将结果发送到标准输出端。例子 <code>tr</code>, <code>grep</code>, <code>cat</code></li>
<li>Cantrip 模式：没有输入，没有输出，只被调用一次，产生退出状态数值。一个 cantrip 程序的行为只能由启动条件来控制。例子 <code>clear</code>, <code>rm</code>, <code>touch</code></li>
<li>源模式：类似过滤器的程序，不需要输入；它的输出只能在启动条件中控制。例子 <code>ls</code>, <code>who</code>, <code>ps</code></li>
<li>接收器模式：类似过滤器的程序，只接纳标准输入而不发送任何东西到标准输出。同样，它对输入端数据的做用行为只能在启动条件中控制。较少用到，一个例子是 <code>lpr</code></li>
<li>编译器模式：既无标准输出也无标准输入；然而它们会将错误信息发送到标准错误端。例子 <code>gcc</code></li>
<li><code>ed</code> 模式：前面的模式交互能力极低。这种模式在启动之后需要由用户持续的会话来驱动，<code>ed</code> 来源于 Unix 的行编辑器 <code>ed</code>，其他例子 <code>ftp</code>, <code>sh</code></li>
<li>Roguelike 模式：运行在系统控制台，X 终端模拟器或视频显示终端上的游戏，使用全屏幕、支持可视界面风格，但使用字符阵列显示，而非图形和鼠标界面。例子 <code>vi</code>, <code>emacs</code>（一般来说 hjkl 固定做光标键）</li>
</ul>
<h2 id="u4F18_u5316"><a href="#u4F18_u5316" class="headerlink" title="优化"></a>优化</h2><p>程序员工具箱中最强大的额优化技术就是不做优化（因为摩尔定律的存在）</p>
<p>有三种常规的策略来减少时延：</p>
<ol>
<li>对可以共享启动开销的事务进行批处理</li>
<li>允许事务重叠</li>
<li>缓存</li>
</ol>
<h2 id="u5DE5_u5177_uFF1A_u5F00_u53D1_u7684_u6218_u672F"><a href="#u5DE5_u5177_uFF1A_u5F00_u53D1_u7684_u6218_u672F" class="headerlink" title="工具：开发的战术"></a>工具：开发的战术</h2><ul>
<li>编辑器：vi 和 Emacs</li>
<li>专用代码生成器：yacc 和 lex</li>
<li>自动化编译：make</li>
<li>版本控制：git</li>
<li>性能分析：profiler</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>不懂 Unix 的人注定最终还要重复发明一个蹩脚的 Unix。</p>]]>
    
    </summary>
    
      <category term="Unix" scheme="http://wdxtub.com/tags/Unix/"/>
    
      <category term="哲学" scheme="http://wdxtub.com/tags/%E5%93%B2%E5%AD%A6/"/>
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://wdxtub.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第八周 - 南屏晚钟]]></title>
    <link href="http://wdxtub.com/2016/08/05/nan-ping-wan-zhong/"/>
    <id>http://wdxtub.com/2016/08/05/nan-ping-wan-zhong/</id>
    <published>2016-08-05T13:57:54.000Z</published>
    <updated>2016-08-05T15:17:46.000Z</updated>
    <content type="html"><![CDATA[<p>我匆匆地走入森林中，森林它一丛丛；我找不到她的行踪，只听见树摇风。</p>
<a id="more"></a>
<hr>
<p>这周最重要的内容，其实在<a href="http://wdxtub.com/2016/08/03/report-little-thought/">『汇报后的小思考』</a>中都写出来了。所以这篇周记就算是查漏补缺，把这周剩下的事儿简单写写吧。</p>
<p>台风带来的一天假期着实让我放松了一把，睡了一天，算是把周末游泳留下的一身疲惫给洗净了。周末还去欢乐海岸吃了烤鱼看了灯光表演，都有些忘记无所事事的感觉了。虽然命运的车轮与我所愿越来越快，但是一路狂奔的同时也注定要错过很多吧。或许有一天会停下来走走看看，但是总不能在山腰放弃嘛。</p>
<p>转眼周记也来到了第八周，慢慢也固定下来了早睡早起早去早回的工作节奏，虽然公司里有各种冗余繁杂和不科学的流程，不过快速发展难免粗放，做事情的方法还是得慢慢改进。只是以后如果自立门户，一定要从第一天起就把追求效率放在第一位，并且重点在于做，而不是写在员工守则里，很多人却以『不让自己承担责任』在做工作。尤其是跨部门，各种踢皮球，也慢慢能够理解为啥政府部门这么缓慢了，其实在哪都一样，不是大领导强势推进，谁都不愿意背莫须有的黑锅。</p>
<p>这周又看了几本经典教材，不同教材不同的写作思路以及不同的核心思想都给了我很多启发，正所谓温故而知新嘛，从更高层级看教材，感觉才和作者更加贴近了，的确，从知识点抽象出来，才能真正看到重要的联系，这也是我着力想要写出来的。</p>
<p>跑步回家应该是工作日最佳的设计，工作完一天，一边运动一边回家，既锻炼又省钱，蚂蚁再小也是肉嘛。跑着跑着仿佛回到了两三年前，和小伙伴们一起在马路上奔跑。仔细想想，我们现在也还在跑着，只是各有各的跑道罢了。</p>
<p>最后再碎碎念几句吧。跟别人合作，克服自己『怕麻烦』的惯性，把大家都哄开心了，工作才能做得更好。对待朋友，甚至是陌生人，如果别人以诚相待，我也要努力做个更温柔的人，毕竟也许只是一两句话，就能让别人开心很多呢。</p>
<p>我看不到她的行踪，只听到南屏晚钟。南屏晚钟，随风飘送，它好像是敲呀敲在我心坎中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我匆匆地走入森林中，森林它一丛丛；我找不到她的行踪，只听见树摇风。</p>]]>
    
    </summary>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="生活" scheme="http://wdxtub.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[汇报后的小思考]]></title>
    <link href="http://wdxtub.com/2016/08/03/report-little-thought/"/>
    <id>http://wdxtub.com/2016/08/03/report-little-thought/</id>
    <published>2016-08-03T12:52:04.000Z</published>
    <updated>2016-08-03T13:56:13.000Z</updated>
    <content type="html"><![CDATA[<p>工作了一段时间之后，才深深意识到，所谓做事，最重要的不是怎么做，而是到底要做什么。</p>
<a id="more"></a>
<hr>
<p>前两天第一次跟公司研发的 VP 汇报，虽然只有短短二十分钟，但是学到了不少东西，这里简要记录一下自己的一些思考。</p>
<p>汇报工作最重要的是做足准备，和电梯演讲一样，一定要用简单的话语把事情说清楚，也就是说，要概念清晰干货满满，任何一点模棱两可都只能说明准备不充足，恐怕是很难留下好印象的。</p>
<p>因为公司的资源是有限的，所以最重要的就是要说服老板『为什么应该做这个事儿』。为了支撑『应该做这个事儿』，就需要从各个维度找到理由，比方说从竞争对手的角度，从法律法规的角度，从用户体验的角度，从安全性的角度等等。给出的论据也不能像互联网分析师那样假大空，一定要以事实、逻辑和数据做支撑，一环扣一环，才是『讲道理』的汇报。</p>
<p>因为是跨国跨团队合作项目，所以老板着重问的是另一个团队有没有做有价值的输出，所谓有价值，指的是那些不是简单搜索就能搜到，而是涉及相关技术细节和具体的规格文档之类的东西。毕竟每天老板都会听到各种各样『忽悠』，一个东西不能别人说什么就是什么，得有一个方法来验证。</p>
<p>总结来说，老板的思维很清晰：资源是有限的，理清核心需求，找出核心贡献点，太长远的且依赖别人的暂时看来虚无缥缈的需求不做，尽量用最小的成本做出最大的效果。</p>
<p>这应该是我学到的最宝贵的东西，真正以一个『企业家』的角度去思考问题，之后在工作中和汇报中都应该站在老板的角度去思考一下，看看到底能够怎样体现自己的价值。</p>
<p>最近成了两个项目的第一负责人，虽然这只是意味着项目出了问题我得第一个顶上加班，但还是很高兴能够有机会去试着成为独当一面的人。</p>
<p>技术上的问题虽然有难度，虽然不一定能找到最好的解决方案，但至少能做出来。但是沟通上和管理上的问题，恐怕需要斟酌拿捏的地方要多好几个数量级，希望自己能小步快跑，努力成长起来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工作了一段时间之后，才深深意识到，所谓做事，最重要的不是怎么做，而是到底要做什么。</p>]]>
    
    </summary>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="汇报" scheme="http://wdxtub.com/tags/%E6%B1%87%E6%8A%A5/"/>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
  </entry>
  
</feed>
