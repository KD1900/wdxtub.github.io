title: 软件架构与设计 第 1 课 总览
categories:
- Technique
date: 2016-01-13 23:21:21
toc: true
tags:
- CMU
- 架构
- 设计
---

记得大二的时候，我走进老师办公室，问怎么样成为一个架构师，或者成为一个游戏制作人。五年快要过去了，总算是在两个方向都摸到了一点门道。上这门课与其说是学东西，更不如说是验证自己的想法。

<!-- more -->

---

如果你打算做一个软件工程师，那么职业道路大概是这样的：初级软件工程师 -> 中级软件工程师 -> 高级软件工程师 -> ... -> 软件架构师。总而言之，就是当你技术懂得足够多，经验足够丰富之后，就可以不再局限于一招一式，而是去思考如何让一群人发挥全部实力做好一件事情了。

为什么需要软件架构呢？因为随着软件规模的日益扩大，如何让各个组件能够尽可能好的融合在一起，一个模块发生问题不至于产生雪崩式的影响，如何能够让大规模开发成为现实，这些的背后都需要有一个好的架构来支持。

可是说得容易做得难，设计一个好的架构要面对诸多问题，不仅仅是技术上的挑战，而且项目规模越大，失败的可能也就越高。日常生活中有很多东西都属于架构精良的，比方说互联网和飞机航线。

因此，这门课主要会介绍以下内容：

+ 架构概览
+ 微观架构模式（设计模式）
+ 宏观架构模式（现代模式）
+ 面向服务架构
+ 架构建模
+ 视角和观点
+ 架构分析技术 - ATAM
+ 架构策略 - QoS
+ 其他一些进阶话题

除此之外，这门课有什么特别的地方呢？

+ 面向系统的软件工程
	+ 服务计算(h/w & s/w)
	+ 面向服务的软件工程(第三代)
+ 实战学习
	+ 最新的技术
	+ XaaS(Saas, PaaS)，大数据，云计算，移动计算，社交网络，互联网，网络中心合作，HPC，SDX
	+ 企业规模的系统
	+ 由高科技公司和政府部门资助

主要使用的技术是：

+ 需要软件工程的基本知识
+ Java 或 Python
+ 大量的编码和设计
+ 每周交付
+ 许多开源软件和环境

重要的时间节点：

+ 16.5.5 期末考试 Week 17
+ 16.3.3 期中考试 Week 8
+ 十次个人作业
+ 一个小组项目
	+ 四人一组，春假后开始
	+ 技术报告 16.5.6，包括：文档(20%)，教程(5%)，Docker 镜像(8%)，Github 帐号(10%)，视频(7%)
	+ 最终展示 PPT(16.4.25，5%)，课堂上展示(Week 15，10%)
	+ Demo：Final(16.4.29，10%)，Sprint 1(3.25，7%), 2(4.8，8%), 3(4.22，10%)

项目的主要任务

1. 研究现有架构
2. 分析评估现有架构
3. 开发现代架构模型
	+ 微观设计模式
	+ 宏观架构模型
	+ 云计算，移动服务，社交网络，大数据
4. 开发新架构
5. 课堂展示

---

言归正传，软件开发的主要挑战是：Complexity, Conformity, Changeability, Intangibility。在这之中，可重用是非常重要的，包括：想法，知识，模式，经验，架构，行为，实现，测试套件等等。

用通俗的话来说，软件架构的主要目的是把大系统分解为可以被独立制作的小系统，并且每个部分都有其商业价值，在开发完成后能够直接集成到现有系统中。衡量架构的一些维度：性能，可维护性，可测试性，安全性，可用性。

同一个架构，在不同的人眼中也有不同的关注点。所以，软件架构扮演的角色到底是什么呢？主要有两点：

1. 定义系统的功能接口
2. 决定系统的重要性质

## Accidental Difficulties

这类问题存在某种解决方案，可能只是等待被人发现。例如：

+ 不够强大的程序结构和抽象
	+ 可行方案：用高级编程语言重写
+ 程序运行需要大量时间
	+ 可行方案：利用分时系统
+ 难以运行各种各样的程序
	+ 可行方案：集成软件开发环境

## Essential Difficulties

这类问题可能只有部分有解决方案，无论如何无法抽象：

+ Complexity：没有两个软件组件是相似的
	+ 如果相似了，应该被抽象成同一个
	+ 复杂度增长是非线性的，爆炸增长
+ Conformity：需要和其运行环境与硬件保持一致性
+ Changeability：可能会因为各种各样的原因改变，有无限的扩展性
+ Intangibility：通常来说不受物理定律限制，也没有明显的表达形式

## Pewter Bullets 锡弹

+ Ada, C++, Java 和其他高级语言
+ 面向对象设计/分析/编程
+ 人工智能
+ 自动编程
+ 图像化编程
+ 程序验证
+ 环境和工具
+ 工作站

1987年提出的的一个关于复杂度的问题：当你需要开发一个功能或者模块的时候，是从外面买还是自己做呢？

采用增量式开发有许多好处，比如方便长期开发，可以方便的回溯，能够尽早拿出原型。

## WWW 万维网

WWW 是一个极佳的学习架构的例子：

+ WWW 可以看作是各类资源的集合，每个资源都有一个唯一且统一的标识，称为 URL
+ 每个资源都标记着一些信息
+ 通信是由客户端发起的
+ 资源可以进行修改
+ 客户端和服务端的通信基于一个简单且通用的协议(HTTP)
+ 所有的通信都是完整的，也就是说是无状态的(不依赖之前或者之后的状态)
+ Web 的架构和代码完全无关

## Desktop 桌面

桌面环境也是一个很好的例子：

+ 利用 pipes 和 filters 来处理信息
+ 基于少量原则
+ 可以由非程序员来进行创作

## 总结

+ 软件是复杂的
+ 软件工程师可以从其他领域学习知识
+ 需要建立起自己的知识架构

